<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AnyFS Ecosystem Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for AnyFS: pluggable virtual filesystem backends + container layer for Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-3caf12ec.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-a787d6ec.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">AnyFS Ecosystem Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/vfs-design-manual" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="anyfs-ecosystem"><a class="header" href="#anyfs-ecosystem">AnyFS Ecosystem</a></h1>
<p><strong>An open standard for pluggable virtual filesystem backends in Rust.</strong></p>
<hr>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>AnyFS is an <strong>open standard</strong> for virtual filesystem backends using a <strong>Tower-style middleware pattern</strong> for composable functionality.</p>
<p>You get:</p>
<ul>
<li>A familiar <code>std::fs</code>-aligned API</li>
<li>Composable middleware (limits, logging, security)</li>
<li>Choice of storage: memory, SQLite, host filesystem, or custom</li>
</ul>
<hr>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FilesContainer&lt;B&gt;                      │  ← Ergonomics (std::fs API)
├─────────────────────────────────────────┤
│  Middleware (composable):               │
│    LimitedBackend&lt;B&gt;                    │  ← Quotas
│    FeatureGatedBackend&lt;B&gt;               │  ← Security
│    LoggingBackend&lt;B&gt;                    │  ← Audit
├─────────────────────────────────────────┤
│  VfsBackend                             │  ← Storage
│  (Memory, SQLite, VRootFs, custom...)   │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>Each layer has one job.</strong> Compose only what you need.</p>
<hr>
<h2 id="three-crate-structure"><a class="header" href="#three-crate-structure">Three-Crate Structure</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract: <code>VfsBackend</code> trait + types</td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware</td></tr>
<tr><td><code>anyfs-container</code></td><td>Ergonomic <code>FilesContainer&lt;B&gt;</code> wrapper</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, LimitedBackend, FeatureGatedBackend};
use anyfs_container::FilesContainer;

// Compose: storage -&gt; limits -&gt; security
let backend = FeatureGatedBackend::new(
    LimitedBackend::new(SqliteBackend::open("data.db")?)
        .with_max_total_size(100 * 1024 * 1024)
)
.with_symlinks();

let mut fs = FilesContainer::new(backend);

fs.create_dir_all("/data")?;
fs.write("/data/file.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="how-to-use-this-manual"><a class="header" href="#how-to-use-this-manual">How to Use This Manual</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Section</th><th>Audience</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Overview</td><td>Stakeholders</td><td>One-page understanding</td></tr>
<tr><td>Getting Started</td><td>Developers</td><td>Practical examples</td></tr>
<tr><td>Design &amp; Architecture</td><td>Contributors</td><td>Detailed design</td></tr>
<tr><td>Traits &amp; APIs</td><td>Backend authors</td><td>Contract and types</td></tr>
<tr><td>Implementation</td><td>Implementers</td><td>Plan + backend guide</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Design</td><td>Complete</td></tr>
<tr><td>Implementation</td><td>Not started</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="authoritative-documents"><a class="header" href="#authoritative-documents">Authoritative Documents</a></h2>
<ol>
<li><code>AGENTS.md</code> (for AI assistants)</li>
<li><code>book/src/architecture/design-overview.md</code></li>
<li><code>book/src/architecture/adrs.md</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---executive-summary"><a class="header" href="#anyfs---executive-summary">AnyFS - Executive Summary</a></h1>
<p>One-page overview for stakeholders and decision-makers.</p>
<hr>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>AnyFS is an <strong>open standard</strong> for pluggable virtual filesystem backends in Rust, using a <strong>Tower-style middleware pattern</strong> for composable functionality.</p>
<p>You get:</p>
<ul>
<li>A familiar <code>std::fs</code>-aligned API</li>
<li>Composable middleware for limits, logging, and security</li>
<li>Choice of storage: memory, SQLite, host filesystem, or custom</li>
</ul>
<hr>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FilesContainer&lt;B&gt;                      │  ← Ergonomics (std::fs API)
├─────────────────────────────────────────┤
│  Middleware (composable):               │
│    LimitedBackend&lt;B&gt;                    │  ← Quotas
│    FeatureGatedBackend&lt;B&gt;               │  ← Security
│    LoggingBackend&lt;B&gt;                    │  ← Audit
├─────────────────────────────────────────┤
│  VfsBackend                             │  ← Storage
└─────────────────────────────────────────┘
</code></pre>
<hr>
<h2 id="why-does-it-matter"><a class="header" href="#why-does-it-matter">Why does it matter?</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Problem</th><th>How AnyFS helps</th></tr>
</thead>
<tbody>
<tr><td>Multi-tenant isolation</td><td>Separate backend instances per tenant</td></tr>
<tr><td>Portability</td><td>SQLite backend: tenant data = single <code>.db</code> file</td></tr>
<tr><td>Security</td><td>FeatureGatedBackend disables dangerous features by default</td></tr>
<tr><td>Resource control</td><td>LimitedBackend enforces quotas</td></tr>
<tr><td>Audit compliance</td><td>LoggingBackend records all operations</td></tr>
<tr><td>Custom storage</td><td>Implement VfsBackend for any medium</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="key-design-points"><a class="header" href="#key-design-points">Key design points</a></h2>
<ul>
<li>
<p><strong>Three-crate structure</strong></p>
<ul>
<li><code>anyfs-backend</code>: trait contract</li>
<li><code>anyfs</code>: backends + middleware</li>
<li><code>anyfs-container</code>: ergonomic wrapper</li>
</ul>
</li>
<li>
<p><strong>Middleware pattern</strong> (like Axum/Tower)</p>
<ul>
<li>Each middleware has one job</li>
<li>Compose only what you need</li>
<li>Complete separation of concerns</li>
</ul>
</li>
<li>
<p><strong>std::fs alignment</strong></p>
<ul>
<li>Familiar method names</li>
<li><code>impl AsRef&lt;Path&gt;</code> everywhere</li>
</ul>
</li>
</ul>
<hr>
<h2 id="quick-example-1"><a class="header" href="#quick-example-1">Quick example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, LimitedBackend, FeatureGatedBackend};
use anyfs_container::FilesContainer;

// Compose: storage + limits + security
let backend = FeatureGatedBackend::new(
    LimitedBackend::new(SqliteBackend::open("tenant.db")?)
        .with_max_total_size(100 * 1024 * 1024)
)
.with_symlinks();

let mut fs = FilesContainer::new(backend);

fs.create_dir_all("/documents")?;
fs.write("/documents/hello.txt", b"Hello!")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Design</td><td>Complete</td></tr>
<tr><td>Implementation</td><td>Not started</td></tr>
</tbody>
</table>
</div>
<hr>
<p>For details, see <code>book/src/architecture/design-overview.md</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---project-structure"><a class="header" href="#anyfs---project-structure">AnyFS - Project Structure</a></h1>
<p><strong>Status:</strong> Current
<strong>Last updated:</strong> 2025-12-24</p>
<hr>
<h2 id="repository-layout"><a class="header" href="#repository-layout">Repository Layout</a></h2>
<pre><code>anyfs-backend/              # Crate 1: trait + types
  Cargo.toml
  src/
    lib.rs
    backend.rs              # VfsBackend trait
    types.rs                # Metadata, DirEntry, Permissions, StatFs
    error.rs                # VfsError

anyfs/                      # Crate 2: backends + middleware
  Cargo.toml
  src/
    lib.rs
    backends/
      memory.rs             # MemoryBackend [feature: memory, default]
      sqlite.rs             # SqliteBackend [feature: sqlite]
      vrootfs.rs            # VRootFsBackend [feature: vrootfs]
    middleware/
      limited.rs            # LimitedBackend&lt;B&gt;
      logging.rs            # LoggingBackend&lt;B&gt;
      feature_gated.rs      # FeatureGatedBackend&lt;B&gt;

anyfs-container/            # Crate 3: ergonomic wrapper
  Cargo.toml
  src/
    lib.rs
    container.rs            # FilesContainer&lt;B&gt;
</code></pre>
<hr>
<h2 id="dependency-model"><a class="header" href="#dependency-model">Dependency Model</a></h2>
<pre><code>anyfs-backend (trait + types)
     ^
     |-- anyfs (backends + middleware)
     |     ^-- vrootfs feature uses strict-path
     |
     +-- anyfs-container (ergonomic wrapper)
</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>Custom backends depend only on <code>anyfs-backend</code></li>
<li><code>anyfs</code> provides built-in backends and middleware</li>
<li><code>anyfs-container</code> provides the ergonomic <code>FilesContainer</code> wrapper</li>
</ul>
<hr>
<h2 id="middleware-pattern"><a class="header" href="#middleware-pattern">Middleware Pattern</a></h2>
<pre><code>FilesContainer&lt;B&gt;
    wraps -&gt; LoggingBackend&lt;B&gt;
        wraps -&gt; FeatureGatedBackend&lt;B&gt;
            wraps -&gt; LimitedBackend&lt;B&gt;
                wraps -&gt; SqliteBackend (or any VfsBackend)
</code></pre>
<p>Each layer implements <code>VfsBackend</code>, enabling composition.</p>
<hr>
<h2 id="cargo-features"><a class="header" href="#cargo-features">Cargo Features</a></h2>
<p>Features in <code>anyfs</code> select which backends to include:</p>
<ul>
<li><code>memory</code> — In-memory storage (default)</li>
<li><code>sqlite</code> — SQLite-backed persistent storage</li>
<li><code>vrootfs</code> — Host filesystem backend (uses <code>strict-path</code>)</li>
</ul>
<p>Middleware is always available (no feature flags).</p>
<hr>
<h2 id="where-to-start"><a class="header" href="#where-to-start">Where To Start</a></h2>
<ul>
<li>Application usage: <code>book/src/getting-started/guide.md</code></li>
<li>Trait details: <code>book/src/traits/vfs-trait.md</code></li>
<li>Middleware: <code>book/src/architecture/design-overview.md</code></li>
<li>Decisions: <code>book/src/architecture/adrs.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--getting-started-guide"><a class="header" href="#anyfs--getting-started-guide">AnyFS — Getting Started Guide</a></h1>
<p><strong>A practical introduction with examples</strong></p>
<hr>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
anyfs = "0.1"
anyfs-container = "0.1"  # Optional: for ergonomic wrapper
</code></pre>
<p>For additional backends:</p>
<pre><code class="language-toml">[dependencies]
anyfs = { version = "0.1", features = ["sqlite", "vrootfs"] }
</code></pre>
<p>Available features:</p>
<ul>
<li><code>memory</code> — In-memory storage (default)</li>
<li><code>sqlite</code> — SQLite-backed persistent storage</li>
<li><code>vrootfs</code> — Host filesystem backend</li>
</ul>
<hr>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut fs = FilesContainer::new(MemoryBackend::new());

    fs.write("/hello.txt", b"Hello, AnyFS!")?;
    let content = fs.read("/hello.txt")?;
    println!("{}", String::from_utf8_lossy(&amp;content));

    Ok(())
}</code></pre>
<h3 id="with-limits-limitedbackend"><a class="header" href="#with-limits-limitedbackend">With Limits (LimitedBackend)</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{SqliteBackend, LimitedBackend};
use anyfs_container::FilesContainer;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let backend = LimitedBackend::new(SqliteBackend::open_or_create("data.db")?)
        .with_max_total_size(100 * 1024 * 1024)  // 100 MB
        .with_max_file_size(10 * 1024 * 1024);   // 10 MB per file

    let mut fs = FilesContainer::new(backend);

    fs.create_dir_all("/documents")?;
    fs.write("/documents/notes.txt", b"Meeting notes")?;

    Ok(())
}</code></pre>
<h3 id="with-feature-gates-featuregatedbackend"><a class="header" href="#with-feature-gates-featuregatedbackend">With Feature Gates (FeatureGatedBackend)</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{MemoryBackend, FeatureGatedBackend};
use anyfs_container::FilesContainer;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let backend = FeatureGatedBackend::new(MemoryBackend::new())
        .with_symlinks()      // Enable symlinks
        .with_hard_links();   // Enable hard links

    let mut fs = FilesContainer::new(backend);

    fs.write("/original.txt", b"content")?;
    fs.symlink("/original.txt", "/shortcut")?;

    Ok(())
}</code></pre>
<h3 id="full-stack-limits--feature-gates"><a class="header" href="#full-stack-limits--feature-gates">Full Stack (Limits + Feature Gates)</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{SqliteBackend, LimitedBackend, FeatureGatedBackend};
use anyfs_container::FilesContainer;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Compose: storage -&gt; limits -&gt; feature gates
    let backend = FeatureGatedBackend::new(
        LimitedBackend::new(SqliteBackend::open_or_create("data.db")?)
            .with_max_total_size(100 * 1024 * 1024)
    )
    .with_symlinks();

    let mut fs = FilesContainer::new(backend);

    fs.create_dir_all("/data")?;
    fs.write("/data/file.txt", b"hello")?;

    Ok(())
}</code></pre>
<hr>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<h3 id="creating-directories"><a class="header" href="#creating-directories">Creating Directories</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.create_dir("/documents")?;              // Single level
fs.create_dir_all("/documents/2024/q1")?;  // Recursive
<span class="boring">}</span></code></pre>
<h3 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and Writing Files</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.write("/data.txt", b"line 1\n")?;       // Create or overwrite
fs.append("/data.txt", b"line 2\n")?;      // Append

let content = fs.read("/data.txt")?;                    // Read all
let partial = fs.read_range("/data.txt", 0, 6)?;        // Read range
let text = fs.read_to_string("/data.txt")?;             // Read as String
<span class="boring">}</span></code></pre>
<h3 id="listing-directories"><a class="header" href="#listing-directories">Listing Directories</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in fs.read_dir("/documents")? {
    println!("{}: {:?}", entry.name, entry.file_type);
}
<span class="boring">}</span></code></pre>
<h3 id="checking-existence-and-metadata"><a class="header" href="#checking-existence-and-metadata">Checking Existence and Metadata</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if fs.exists("/file.txt")? {
    let meta = fs.metadata("/file.txt")?;
    println!("Size: {} bytes", meta.size);
}
<span class="boring">}</span></code></pre>
<h3 id="copying-and-moving"><a class="header" href="#copying-and-moving">Copying and Moving</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.copy("/original.txt", "/copy.txt")?;
fs.rename("/original.txt", "/renamed.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="deleting"><a class="header" href="#deleting">Deleting</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.remove_file("/old-file.txt")?;
fs.remove_dir("/empty-folder")?;
fs.remove_dir_all("/old-folder")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware"><a class="header" href="#middleware">Middleware</a></h2>
<h3 id="limitedbackend--quota-enforcement"><a class="header" href="#limitedbackend--quota-enforcement">LimitedBackend — Quota Enforcement</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, LimitedBackend};

let backend = LimitedBackend::new(MemoryBackend::new())
    .with_max_total_size(500 * 1024 * 1024)  // 500 MB total
    .with_max_file_size(50 * 1024 * 1024)    // 50 MB per file
    .with_max_node_count(100_000)             // 100K files/dirs
    .with_max_dir_entries(5_000)              // 5K per directory
    .with_max_path_depth(32);                 // Max nesting

// Check usage
let usage = backend.usage();
println!("Using {} bytes", usage.total_size);

// Check remaining
let remaining = backend.remaining();
if !remaining.can_write {
    println!("Storage full!");
}
<span class="boring">}</span></code></pre>
<h3 id="featuregatedbackend--least-privilege"><a class="header" href="#featuregatedbackend--least-privilege">FeatureGatedBackend — Least Privilege</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FeatureGatedBackend};

// All features disabled by default
let backend = FeatureGatedBackend::new(MemoryBackend::new())
    .with_symlinks()                  // Enable symlink operations
    .with_max_symlink_resolution(40)  // Max hops (default: 40)
    .with_hard_links()                // Enable hard links
    .with_permissions();              // Enable set_permissions

// Disabled operations return VfsError::FeatureNotEnabled
<span class="boring">}</span></code></pre>
<h3 id="loggingbackend--audit-trail"><a class="header" href="#loggingbackend--audit-trail">LoggingBackend — Audit Trail</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, LoggingBackend};

let backend = LoggingBackend::new(MemoryBackend::new())
    .with_logger(MyLogger::new());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::VfsError;

match fs.write("/file.txt", &amp;large_data) {
    Ok(()) =&gt; println!("Written"),

    Err(VfsError::NotFound(p)) =&gt; println!("Not found: {}", p),
    Err(VfsError::AlreadyExists(p)) =&gt; println!("Exists: {}", p),
    Err(VfsError::QuotaExceeded) =&gt; println!("Quota exceeded"),
    Err(VfsError::FeatureNotEnabled(f)) =&gt; println!("Feature disabled: {}", f),

    Err(e) =&gt; println!("Error: {}", e),
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

#[test]
fn test_write_and_read() {
    let mut fs = FilesContainer::new(MemoryBackend::new());

    fs.write("/test.txt", b"test data").unwrap();
    let content = fs.read("/test.txt").unwrap();

    assert_eq!(content, b"test data");
}
<span class="boring">}</span></code></pre>
<p>With limits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, LimitedBackend};
use anyfs_container::FilesContainer;

#[test]
fn test_quota_exceeded() {
    let backend = LimitedBackend::new(MemoryBackend::new())
        .with_max_total_size(1024);  // 1 KB
    let mut fs = FilesContainer::new(backend);

    let big_data = vec![0u8; 2048];  // 2 KB
    let result = fs.write("/big.bin", &amp;big_data);

    assert!(result.is_err());
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-use-appropriate-backend"><a class="header" href="#1-use-appropriate-backend">1. Use Appropriate Backend</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Backend</th></tr>
</thead>
<tbody>
<tr><td>Testing</td><td><code>MemoryBackend</code></td></tr>
<tr><td>Production</td><td><code>SqliteBackend</code></td></tr>
<tr><td>Host filesystem</td><td><code>VRootFsBackend</code></td></tr>
</tbody>
</table>
</div>
<h3 id="2-compose-middleware-for-your-needs"><a class="header" href="#2-compose-middleware-for-your-needs">2. Compose Middleware for Your Needs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Minimal: just storage
let fs = FilesContainer::new(MemoryBackend::new());

// With limits
let fs = FilesContainer::new(
    LimitedBackend::new(MemoryBackend::new())
        .with_max_total_size(100 * 1024 * 1024)
);

// Full security
let fs = FilesContainer::new(
    FeatureGatedBackend::new(
        LimitedBackend::new(SqliteBackend::open("data.db")?)
    )
    .with_symlinks()
);
<span class="boring">}</span></code></pre>
<h3 id="3-handle-errors-gracefully"><a class="header" href="#3-handle-errors-gracefully">3. Handle Errors Gracefully</a></h3>
<p>Always check for quota exceeded, feature not enabled, and other errors.</p>
<hr>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#anyfs--api-quick-reference">API Quick Reference</a></li>
<li><a href="#anyfs---design-overview">Design Overview</a></li>
<li><a href="#backend-implementers-guide">Backend Implementer’s Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--api-quick-reference"><a class="header" href="#anyfs--api-quick-reference">AnyFS — API Quick Reference</a></h1>
<p><strong>Condensed reference for developers</strong></p>
<hr>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
anyfs = "0.1"
anyfs-container = "0.1"  # Optional
</code></pre>
<p>With backends and optional features:</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["sqlite", "vrootfs", "bytes"] }
</code></pre>
<hr>
<h2 id="creating-a-backend-stack"><a class="header" href="#creating-a-backend-stack">Creating a Backend Stack</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, LimitedBackend, FeatureGatedBackend, TracingBackend};
use anyfs_container::FilesContainer;

// Simple
let fs = FilesContainer::new(MemoryBackend::new());

// With limits
let fs = FilesContainer::new(
    LimitedBackend::new(SqliteBackend::open("data.db")?)
        .with_max_total_size(100 * 1024 * 1024)
        .with_max_file_size(10 * 1024 * 1024)
);

// Full stack (manual composition)
let fs = FilesContainer::new(
    TracingBackend::new(
        FeatureGatedBackend::new(
            LimitedBackend::new(SqliteBackend::open("data.db")?)
                .with_max_total_size(100 * 1024 * 1024)
        )
        .with_symlinks()
        .with_hard_links()
    )
);

// Layer-based composition
use anyfs::{LimitedLayer, FeatureGateLayer, TracingLayer};

let backend = SqliteBackend::open("data.db")?
    .layer(LimitedLayer::new().max_total_size(100 * 1024 * 1024))
    .layer(FeatureGateLayer::new().allow_symlinks())
    .layer(TracingLayer::new());

// BackendStack builder (fluent API)
use anyfs_container::BackendStack;

let fs = BackendStack::new(SqliteBackend::open("data.db")?)
    .limited(|l| l.max_total_size(100 * 1024 * 1024))
    .feature_gated(|g| g.allow_symlinks())
    .traced()
    .into_container();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="limitedbackend-methods"><a class="header" href="#limitedbackend-methods">LimitedBackend Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LimitedBackend::new(backend)
    .with_max_total_size(bytes)      // Total storage limit
    .with_max_file_size(bytes)       // Per-file limit
    .with_max_node_count(count)      // Max files/dirs
    .with_max_dir_entries(count)     // Max entries per dir
    .with_max_path_depth(depth)      // Max nesting

// Query
backend.usage()        // -&gt; Usage { total_size, file_count, ... }
backend.limits()       // -&gt; Limits { max_total_size, ... }
backend.remaining()    // -&gt; Remaining { bytes, can_write, ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="featuregatedbackend-methods"><a class="header" href="#featuregatedbackend-methods">FeatureGatedBackend Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FeatureGatedBackend::new(backend)    // All disabled by default
    .with_symlinks()                  // Enable symlink ops
    .with_max_symlink_resolution(40)  // Max hops
    .with_hard_links()                // Enable hard links
    .with_permissions()               // Enable set_permissions
<span class="boring">}</span></code></pre>
<hr>
<h2 id="tracingbackend-methods"><a class="header" href="#tracingbackend-methods">TracingBackend Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TracingBackend::new(backend)
    .with_target("anyfs")             // tracing target
    .with_level(tracing::Level::DEBUG)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="vfsbackendext-methods"><a class="header" href="#vfsbackendext-methods">VfsBackendExt Methods</a></h2>
<p>Extension methods available on all backends:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::VfsBackendExt;

// JSON support
let config: Config = fs.read_json("/config.json")?;
fs.write_json("/config.json", &amp;config)?;

// Type checks
if fs.is_file("/path")? { ... }
if fs.is_dir("/path")? { ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check existence
fs.exists("/path")?                     // -&gt; bool

// Metadata
let meta = fs.metadata("/path")?;
meta.size                                // file size
meta.file_type                           // File | Directory | Symlink
meta.permissions
meta.created                             // Option&lt;SystemTime&gt;
meta.modified

// Read
let bytes = fs.read("/path")?;           // -&gt; Vec&lt;u8&gt;
let text = fs.read_to_string("/path")?;  // -&gt; String
let chunk = fs.read_range("/path", 0, 1024)?;

// List directory
let entries = fs.read_dir("/path")?;     // -&gt; Vec&lt;DirEntry&gt;

// Write
fs.write("/path", b"content")?;          // Create or overwrite
fs.append("/path", b"more")?;            // Append

// Directories
fs.create_dir("/path")?;
fs.create_dir_all("/path")?;

// Delete
fs.remove_file("/path")?;
fs.remove_dir("/path")?;                 // Empty only
fs.remove_dir_all("/path")?;             // Recursive

// Move/Copy
fs.rename("/from", "/to")?;
fs.copy("/from", "/to")?;

// Links (requires FeatureGatedBackend)
fs.symlink("/target", "/link")?;
fs.hard_link("/original", "/link")?;
fs.read_link("/link")?;                  // -&gt; PathBuf

// Permissions (requires FeatureGatedBackend)
fs.set_permissions("/path", perms)?;

// File size
fs.truncate("/path", 1024)?;             // Resize to 1024 bytes

// Durability
fs.sync()?;                              // Flush all writes
fs.fsync("/path")?;                      // Flush writes for one file
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::VfsError;

match result {
    Err(VfsError::NotFound { path, operation }) =&gt; {
        // e.g., path="/file.txt", operation="read"
    }
    Err(VfsError::AlreadyExists { path, operation }) =&gt; ...
    Err(VfsError::NotADirectory { path }) =&gt; ...
    Err(VfsError::NotAFile { path }) =&gt; ...
    Err(VfsError::DirectoryNotEmpty { path }) =&gt; ...
    Err(VfsError::QuotaExceeded { limit, requested, usage }) =&gt; ...
    Err(VfsError::FileSizeExceeded { path, size, limit }) =&gt; ...
    Err(VfsError::FeatureNotEnabled { feature, operation }) =&gt; ...
    Err(VfsError::Serialization(msg)) =&gt; ...   // from VfsBackendExt
    Err(VfsError::Deserialization(msg)) =&gt; ... // from VfsBackendExt
    Err(e) =&gt; ...
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="built-in-backends"><a class="header" href="#built-in-backends">Built-in Backends</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td><code>memory</code> (default)</td><td>In-memory</td></tr>
<tr><td><code>SqliteBackend</code></td><td><code>sqlite</code></td><td>Persistent</td></tr>
<tr><td><code>VRootFsBackend</code></td><td><code>vrootfs</code></td><td>Host filesystem</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="middleware-1"><a class="header" href="#middleware-1">Middleware</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>LimitedBackend&lt;B&gt;</code></td><td>Quota enforcement</td></tr>
<tr><td><code>FeatureGatedBackend&lt;B&gt;</code></td><td>Least privilege</td></tr>
<tr><td><code>TracingBackend&lt;B&gt;</code></td><td>Instrumentation (tracing ecosystem)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="layers"><a class="header" href="#layers">Layers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Creates</th></tr>
</thead>
<tbody>
<tr><td><code>LimitedLayer</code></td><td><code>LimitedBackend&lt;B&gt;</code></td></tr>
<tr><td><code>FeatureGateLayer</code></td><td><code>FeatureGatedBackend&lt;B&gt;</code></td></tr>
<tr><td><code>TracingLayer</code></td><td><code>TracingBackend&lt;B&gt;</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="type-reference"><a class="header" href="#type-reference">Type Reference</a></h2>
<h3 id="from-anyfs-backend"><a class="header" href="#from-anyfs-backend">From <code>anyfs-backend</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>VfsBackend</code></td><td>Core trait</td></tr>
<tr><td><code>Layer</code></td><td>Middleware composition trait</td></tr>
<tr><td><code>VfsBackendExt</code></td><td>Extension methods trait</td></tr>
<tr><td><code>VfsError</code></td><td>Error type (with context)</td></tr>
<tr><td><code>FileType</code></td><td><code>File</code>, <code>Directory</code>, <code>Symlink</code></td></tr>
<tr><td><code>Metadata</code></td><td>File/dir metadata</td></tr>
<tr><td><code>DirEntry</code></td><td>Directory entry</td></tr>
<tr><td><code>Permissions</code></td><td>File permissions</td></tr>
<tr><td><code>StatFs</code></td><td>Filesystem stats</td></tr>
</tbody>
</table>
</div>
<h3 id="from-anyfs"><a class="header" href="#from-anyfs">From <code>anyfs</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>In-memory backend</td></tr>
<tr><td><code>SqliteBackend</code></td><td>SQLite backend</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Host FS backend</td></tr>
<tr><td><code>LimitedBackend&lt;B&gt;</code></td><td>Quota middleware</td></tr>
<tr><td><code>FeatureGatedBackend&lt;B&gt;</code></td><td>Feature gate middleware</td></tr>
<tr><td><code>TracingBackend&lt;B&gt;</code></td><td>Tracing middleware</td></tr>
<tr><td><code>LimitedLayer</code></td><td>Layer for LimitedBackend</td></tr>
<tr><td><code>FeatureGateLayer</code></td><td>Layer for FeatureGatedBackend</td></tr>
<tr><td><code>TracingLayer</code></td><td>Layer for TracingBackend</td></tr>
</tbody>
</table>
</div>
<h3 id="from-anyfs-container"><a class="header" href="#from-anyfs-container">From <code>anyfs-container</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FilesContainer&lt;B&gt;</code></td><td>Ergonomic wrapper</td></tr>
<tr><td><code>BackendStack</code></td><td>Fluent builder for middleware stacks</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---design-overview"><a class="header" href="#anyfs---design-overview">AnyFS - Design Overview</a></h1>
<p><strong>Status:</strong> Current
<strong>Last updated:</strong> 2025-12-24</p>
<hr>
<h2 id="what-this-project-is"><a class="header" href="#what-this-project-is">What This Project Is</a></h2>
<p>AnyFS is an <strong>open standard</strong> for pluggable virtual filesystem backends in Rust. It uses a <strong>middleware/decorator pattern</strong> (like Axum/Tower) for composable functionality with complete separation of concerns.</p>
<p>Anyone can:</p>
<ul>
<li>Implement a custom backend for their storage needs</li>
<li>Compose middleware to add limits, logging, feature gates</li>
<li>Use the ergonomic <code>FilesContainer</code> wrapper</li>
</ul>
<hr>
<h2 id="architecture-tower-style-middleware"><a class="header" href="#architecture-tower-style-middleware">Architecture (Tower-style Middleware)</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FilesContainer&lt;B&gt;                      │  ← Ergonomics only (std::fs API)
├─────────────────────────────────────────┤
│  Middleware (optional, composable):     │
│    LimitedBackend&lt;B&gt;                    │  ← Quota enforcement
│    TracingBackend&lt;B&gt;                    │  ← Instrumentation (tracing ecosystem)
│    FeatureGatedBackend&lt;B&gt;               │  ← Symlink/hardlink whitelist
├─────────────────────────────────────────┤
│  VfsBackend                             │  ← Pure storage + fs semantics
│  (Memory, SQLite, VRootFs, custom...)   │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>Each layer has exactly one responsibility:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Responsibility</th></tr>
</thead>
<tbody>
<tr><td><code>VfsBackend</code></td><td>Storage + filesystem semantics</td></tr>
<tr><td><code>LimitedBackend&lt;B&gt;</code></td><td>Quota enforcement</td></tr>
<tr><td><code>TracingBackend&lt;B&gt;</code></td><td>Instrumentation / audit trail</td></tr>
<tr><td><code>FeatureGatedBackend&lt;B&gt;</code></td><td>Feature whitelist</td></tr>
<tr><td><code>FilesContainer&lt;B&gt;</code></td><td>Ergonomic std::fs-aligned API</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th><th>Contains</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract</td><td><code>VfsBackend</code> trait, <code>Layer</code> trait, types, <code>VfsBackendExt</code></td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware</td><td>Built-in backends, <code>LimitedBackend</code>, <code>TracingBackend</code>, <code>FeatureGatedBackend</code></td></tr>
<tr><td><code>anyfs-container</code></td><td>Ergonomic wrapper</td><td><code>FilesContainer&lt;B&gt;</code>, <code>BackendStack</code> builder</td></tr>
</tbody>
</table>
</div>
<h3 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency Graph</a></h3>
<pre><code>anyfs-backend (trait + types)
     ^
     |-- anyfs (backends + middleware)
     |     ^-- vrootfs feature may use strict-path
     |
     +-- anyfs-container (ergonomic wrapper)
</code></pre>
<hr>
<h2 id="core-trait-vfsbackend-in-anyfs-backend"><a class="header" href="#core-trait-vfsbackend-in-anyfs-backend">Core Trait: <code>VfsBackend</code> (in <code>anyfs-backend</code>)</a></h2>
<p><code>VfsBackend</code> is a path-based trait aligned with <code>std::fs</code>. It handles <strong>storage + filesystem semantics only</strong>. No policy, no limits.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{Read, Write};
use std::path::{Path, PathBuf};

pub trait VfsBackend: Send {
    // Read
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, VfsError&gt;;
    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt;;
    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
    fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, VfsError&gt;;
    fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, VfsError&gt;;

    // Write
    fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn append(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn create_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn create_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_file(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn rename(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn copy(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // Links
    fn symlink(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn hard_link(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // Permissions
    fn set_permissions(&amp;mut self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), VfsError&gt;;

    // Streaming I/O
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, VfsError&gt;;
    fn open_write(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, VfsError&gt;;

    // File size
    fn truncate(&amp;mut self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), VfsError&gt;;

    // Durability
    fn sync(&amp;mut self) -&gt; Result&lt;(), VfsError&gt;;
    fn fsync(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // Filesystem info
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware-in-anyfs"><a class="header" href="#middleware-in-anyfs">Middleware (in <code>anyfs</code>)</a></h2>
<p>Each middleware is itself a <code>VfsBackend</code> that wraps another backend. This enables composition.</p>
<h3 id="limitedbackend"><a class="header" href="#limitedbackend">LimitedBackend<b></b></a></h3>
<p>Enforces quota limits. Tracks usage and rejects operations that would exceed limits.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, LimitedBackend};

let backend = LimitedBackend::new(SqliteBackend::open("data.db")?)
    .with_max_total_size(100 * 1024 * 1024)   // 100 MB
    .with_max_file_size(10 * 1024 * 1024)     // 10 MB per file
    .with_max_node_count(10_000)               // 10K files/dirs
    .with_max_dir_entries(1_000)               // 1K entries per dir
    .with_max_path_depth(64);

// Check usage
let usage = backend.usage();
let remaining = backend.remaining();
<span class="boring">}</span></code></pre>
<h3 id="featuregatedbackend"><a class="header" href="#featuregatedbackend">FeatureGatedBackend<b></b></a></h3>
<p>Enforces least-privilege by disabling features by default.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FeatureGatedBackend};

let backend = FeatureGatedBackend::new(MemoryBackend::new())
    .with_symlinks()                          // Enable symlink operations
    .with_max_symlink_resolution(40)          // Max symlink hops
    .with_hard_links()                        // Enable hard links
    .with_permissions();                      // Enable set_permissions
<span class="boring">}</span></code></pre>
<p>When a feature is disabled, operations return <code>VfsError::FeatureNotEnabled</code>.</p>
<h3 id="tracingbackend"><a class="header" href="#tracingbackend">TracingBackend<b></b></a></h3>
<p>Integrates with the <a href="https://docs.rs/tracing">tracing</a> ecosystem for structured logging and instrumentation.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, TracingBackend};

let backend = TracingBackend::new(SqliteBackend::open("data.db")?)
    .with_target("anyfs")           // tracing target
    .with_level(tracing::Level::DEBUG);

// Users configure tracing subscribers as they prefer
tracing_subscriber::fmt::init();
<span class="boring">}</span></code></pre>
<p><strong>Why tracing instead of custom logging?</strong></p>
<ul>
<li>Works with existing tracing infrastructure</li>
<li>Structured logging with spans</li>
<li>Compatible with OpenTelemetry, Jaeger, etc.</li>
<li>Users choose their subscriber (console, file, distributed tracing)</li>
</ul>
<hr>
<h2 id="filescontainer-in-anyfs-container"><a class="header" href="#filescontainer-in-anyfs-container">FilesContainer (in <code>anyfs-container</code>)</a></h2>
<p><code>FilesContainer&lt;B&gt;</code> is a <strong>thin ergonomic wrapper</strong>. It provides a familiar std::fs-aligned API but does nothing else. All policy (limits, feature gates) is handled by middleware.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let mut fs = FilesContainer::new(MemoryBackend::new());

fs.create_dir_all("/documents")?;
fs.write("/documents/hello.txt", b"Hello!")?;
let content = fs.read("/documents/hello.txt")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-trait-in-anyfs-backend"><a class="header" href="#layer-trait-in-anyfs-backend">Layer Trait (in <code>anyfs-backend</code>)</a></h2>
<p>The <code>Layer</code> trait (inspired by Tower) standardizes middleware composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A layer that wraps a backend to add functionality.
pub trait Layer&lt;B: VfsBackend&gt; {
    type Backend: VfsBackend;
    fn layer(self, backend: B) -&gt; Self::Backend;
}
<span class="boring">}</span></code></pre>
<p>Each middleware provides a corresponding <code>Layer</code> implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// LimitedLayer, TracingLayer, FeatureGateLayer, etc.
pub struct LimitedLayer { /* config */ }

impl&lt;B: VfsBackend&gt; Layer&lt;B&gt; for LimitedLayer {
    type Backend = LimitedBackend&lt;B&gt;;
    fn layer(self, backend: B) -&gt; Self::Backend {
        LimitedBackend::new(backend).with_limits(self.limits)
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="composing-middleware"><a class="header" href="#composing-middleware">Composing Middleware</a></h2>
<p>Middleware composes by wrapping. Order matters - innermost applies first.</p>
<h3 id="manual-composition"><a class="header" href="#manual-composition">Manual Composition</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, LimitedBackend, FeatureGatedBackend, TracingBackend};
use anyfs_container::FilesContainer;

// Build from inside out:
let backend = SqliteBackend::open("data.db")?;

let limited = LimitedBackend::new(backend)
    .with_max_total_size(100 * 1024 * 1024);

let gated = FeatureGatedBackend::new(limited)
    .with_symlinks();

let traced = TracingBackend::new(gated);

let mut fs = FilesContainer::new(traced);
<span class="boring">}</span></code></pre>
<h3 id="layer-based-composition"><a class="header" href="#layer-based-composition">Layer-based Composition</a></h3>
<p>Use the <code>Layer</code> trait for Axum-style composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, LimitedLayer, FeatureGateLayer, TracingLayer};

let backend = SqliteBackend::open("data.db")?
    .layer(LimitedLayer::new().max_total_size(100 * 1024 * 1024))
    .layer(FeatureGateLayer::new().allow_symlinks())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<h3 id="backendstack-builder"><a class="header" href="#backendstack-builder">BackendStack Builder</a></h3>
<p>For complex stacks, use <code>BackendStack</code> for a fluent API:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_container::BackendStack;

let fs = BackendStack::new(SqliteBackend::open("data.db")?)
    .limited(|l| l
        .max_total_size(100 * 1024 * 1024)
        .max_file_size(10 * 1024 * 1024))
    .feature_gated(|g| g
        .allow_symlinks()
        .allow_hard_links())
    .traced()
    .into_container();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="built-in-backends-1"><a class="header" href="#built-in-backends-1">Built-in Backends</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td><code>memory</code> (default)</td><td>In-memory storage</td></tr>
<tr><td><code>SqliteBackend</code></td><td><code>sqlite</code></td><td>Single-file portable database</td></tr>
<tr><td><code>VRootFsBackend</code></td><td><code>vrootfs</code></td><td>Host filesystem via strict-path</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="path-handling"><a class="header" href="#path-handling">Path Handling</a></h2>
<p>All layers use <code>impl AsRef&lt;Path&gt;</code>, aligned with <code>std::fs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All of these work
fs.write("/file.txt", data)?;
fs.write(String::from("/file.txt"), data)?;
fs.write(Path::new("/file.txt"), data)?;
fs.write(PathBuf::from("/file.txt"), data)?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<p>Security is achieved through composition:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Solution</th></tr>
</thead>
<tbody>
<tr><td>Path containment</td><td>Backend-specific (VRootFsBackend uses strict-path)</td></tr>
<tr><td>Resource exhaustion</td><td><code>LimitedBackend</code> enforces quotas</td></tr>
<tr><td>Feature restriction</td><td><code>FeatureGatedBackend</code> disables dangerous features</td></tr>
<tr><td>Audit trail</td><td><code>TracingBackend</code> instruments operations</td></tr>
<tr><td>Tenant isolation</td><td>Separate backend instances</td></tr>
</tbody>
</table>
</div>
<p><strong>Defense in depth:</strong> Compose multiple middleware layers for comprehensive security.</p>
<hr>
<h2 id="extension-traits-in-anyfs-backend"><a class="header" href="#extension-traits-in-anyfs-backend">Extension Traits (in <code>anyfs-backend</code>)</a></h2>
<p>The <code>VfsBackendExt</code> trait provides convenience methods without modifying <code>VfsBackend</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, de::DeserializeOwned};

/// Extension methods for VfsBackend (auto-implemented for all backends).
pub trait VfsBackendExt: VfsBackend {
    /// Read and deserialize JSON.
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, VfsError&gt; {
        let bytes = self.read(path)?;
        serde_json::from_slice(&amp;bytes).map_err(|e| VfsError::Deserialization(e.to_string()))
    }

    /// Serialize and write JSON.
    fn write_json&lt;T: Serialize&gt;(&amp;mut self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), VfsError&gt; {
        let bytes = serde_json::to_vec(value).map_err(|e| VfsError::Serialization(e.to_string()))?;
        self.write(path, &amp;bytes)
    }

    /// Check if path is a file.
    fn is_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt; {
        self.metadata(path).map(|m| m.file_type == FileType::File)
    }

    /// Check if path is a directory.
    fn is_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt; {
        self.metadata(path).map(|m| m.file_type == FileType::Directory)
    }
}

// Blanket implementation for all backends
impl&lt;B: VfsBackend&gt; VfsBackendExt for B {}
<span class="boring">}</span></code></pre>
<p>Users can define their own extension traits for domain-specific operations.</p>
<hr>
<h2 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h2>
<h3 id="bytes-support-feature-bytes"><a class="header" href="#bytes-support-feature-bytes">Bytes Support (feature: <code>bytes</code>)</a></h3>
<p>For zero-copy efficiency, enable the <code>bytes</code> feature to use <code>Bytes</code> instead of <code>Vec&lt;u8&gt;</code>:</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["bytes"] }
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bytes::Bytes;

// With bytes feature, read returns Bytes (O(1) slicing)
let data: Bytes = backend.read("/large-file.bin")?;
let slice = data.slice(1000..2000);  // Zero-copy!
<span class="boring">}</span></code></pre>
<p><strong>When to use:</strong></p>
<ul>
<li>Large file handling with frequent slicing</li>
<li>Network-backed storage</li>
<li>Streaming scenarios</li>
</ul>
<p><strong>Default:</strong> <code>Vec&lt;u8&gt;</code> (no extra dependency)</p>
<hr>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<p><code>VfsError</code> includes context for better debugging:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum VfsError {
    /// Path not found.
    NotFound {
        path: PathBuf,
        operation: &amp;'static str,  // "read", "metadata", etc.
    },

    /// Path already exists.
    AlreadyExists {
        path: PathBuf,
        operation: &amp;'static str,
    },

    /// Expected a file, found directory.
    NotAFile { path: PathBuf },

    /// Expected a directory, found file.
    NotADirectory { path: PathBuf },

    /// Directory not empty (for remove_dir).
    DirectoryNotEmpty { path: PathBuf },

    /// Quota exceeded.
    QuotaExceeded {
        limit: u64,
        requested: u64,
        usage: u64,
    },

    /// File size limit exceeded.
    FileSizeExceeded {
        path: PathBuf,
        size: u64,
        limit: u64,
    },

    /// Feature not enabled (from FeatureGatedBackend).
    FeatureNotEnabled {
        feature: &amp;'static str,  // "symlinks", "hard_links", "permissions"
        operation: &amp;'static str,
    },

    /// Serialization error (from VfsBackendExt).
    Serialization(String),

    /// Deserialization error (from VfsBackendExt).
    Deserialization(String),

    /// Backend-specific error.
    Backend(String),

    /// I/O error.
    Io(std::io::Error),
}
<span class="boring">}</span></code></pre>
<p>All error variants include enough context for meaningful error messages.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="two-layer-design-ergonomic-paths--validated-paths"><a class="header" href="#two-layer-design-ergonomic-paths--validated-paths">Two-Layer Design: Ergonomic Paths + Validated Paths</a></h1>
<p>AnyFS intentionally uses two layers of path handling:</p>
<ol>
<li><strong>User-facing</strong>: <code>FilesContainer</code> methods take <code>impl AsRef&lt;Path&gt;</code>.</li>
<li><strong>Backend-facing</strong>: <code>VfsBackend</code> methods take <code>&amp;VirtualPath</code> (from <code>strict-path</code>).</li>
</ol>
<p>This keeps application code ergonomic while giving backends a single, validated path type.</p>
<hr>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<ul>
<li><strong>Least privilege</strong>: validation happens once at the boundary.</li>
<li><strong>Backend simplicity</strong>: backends do not re-parse strings or fight <code>..</code> traversal edge cases.</li>
<li><strong>Consistency</strong>: all backends receive the same normalized representation.</li>
</ul>
<hr>
<h2 id="flow"><a class="header" href="#flow">Flow</a></h2>
<pre><code>User code:
  container.write("/data/file.txt", b"...")

FilesContainer:
  VirtualPath::new("/data/file.txt") -&gt; VirtualPath
  backend.write(&amp;vpath, data)

Backend:
  receives &amp;VirtualPath (already validated)
</code></pre>
<hr>
<h2 id="important-interaction-with-security"><a class="header" href="#important-interaction-with-security">Important Interaction With Security</a></h2>
<p><code>FilesContainer</code> is the enforcement point for:</p>
<ul>
<li>quota/limit checks</li>
<li>feature whitelisting (deny-by-default for advanced behavior)</li>
</ul>
<p>The backend provides storage and filesystem semantics, but the container decides what is allowed for a given application.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---architecture-decision-records"><a class="header" href="#anyfs---architecture-decision-records">AnyFS - Architecture Decision Records</a></h1>
<p>This file captures the decisions for the current AnyFS design.</p>
<hr>
<h2 id="adr-index"><a class="header" href="#adr-index">ADR Index</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ADR</th><th>Title</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>ADR-001</td><td>Path-based <code>VfsBackend</code> trait</td><td>Accepted</td></tr>
<tr><td>ADR-002</td><td>Three-crate structure</td><td>Accepted</td></tr>
<tr><td>ADR-003</td><td><code>impl AsRef&lt;Path&gt;</code> for all path parameters</td><td>Accepted</td></tr>
<tr><td>ADR-004</td><td>Tower-style middleware pattern</td><td>Accepted</td></tr>
<tr><td>ADR-005</td><td><code>std::fs</code>-aligned method names</td><td>Accepted</td></tr>
<tr><td>ADR-006</td><td>LimitedBackend for quota enforcement</td><td>Accepted</td></tr>
<tr><td>ADR-007</td><td>FeatureGatedBackend for least-privilege</td><td>Accepted</td></tr>
<tr><td>ADR-008</td><td>FilesContainer as thin ergonomic wrapper</td><td>Accepted</td></tr>
<tr><td>ADR-009</td><td>Built-in backends are feature-gated</td><td>Accepted</td></tr>
<tr><td>ADR-010</td><td>Sync-first, async-ready design</td><td>Accepted</td></tr>
<tr><td>ADR-011</td><td>Layer trait for standardized composition</td><td>Accepted</td></tr>
<tr><td>ADR-012</td><td>TracingBackend for instrumentation</td><td>Accepted</td></tr>
<tr><td>ADR-013</td><td>VfsBackendExt for extension methods</td><td>Accepted</td></tr>
<tr><td>ADR-014</td><td>Optional Bytes support</td><td>Accepted</td></tr>
<tr><td>ADR-015</td><td>Contextual VfsError</td><td>Accepted</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="adr-001-path-based-vfsbackend-trait"><a class="header" href="#adr-001-path-based-vfsbackend-trait">ADR-001: Path-based <code>VfsBackend</code> trait</a></h2>
<p><strong>Decision:</strong> Backends implement a path-based trait aligned with <code>std::fs</code> method naming.</p>
<p><strong>Why:</strong> Filesystem operations are naturally path-oriented; a single, familiar trait surface is easier to implement and adopt than graph-store or inode models.</p>
<hr>
<h2 id="adr-002-three-crate-structure"><a class="header" href="#adr-002-three-crate-structure">ADR-002: Three-crate structure</a></h2>
<p><strong>Decision:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract: <code>VfsBackend</code> trait, <code>Layer</code> trait, <code>VfsBackendExt</code>, types</td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware (LimitedBackend, FeatureGatedBackend, TracingBackend)</td></tr>
<tr><td><code>anyfs-container</code></td><td>Ergonomic wrapper: <code>FilesContainer&lt;B&gt;</code>, <code>BackendStack</code> builder</td></tr>
</tbody>
</table>
</div>
<p><strong>Why:</strong></p>
<ul>
<li>Backend authors only need <code>anyfs-backend</code> (no heavy dependencies).</li>
<li>Middleware is composable and lives with backends in <code>anyfs</code>.</li>
<li><code>FilesContainer</code> is purely ergonomic - no policy logic.</li>
</ul>
<hr>
<h2 id="adr-003-impl-asrefpath-for-all-path-parameters"><a class="header" href="#adr-003-impl-asrefpath-for-all-path-parameters">ADR-003: <code>impl AsRef&lt;Path&gt;</code> for all path parameters</a></h2>
<p><strong>Decision:</strong> Both <code>VfsBackend</code> and <code>FilesContainer</code> accept <code>impl AsRef&lt;Path&gt;</code> for all path parameters.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Aligned with <code>std::fs</code> API conventions.</li>
<li>Works across all platforms (not limited to UTF-8).</li>
<li>Ergonomic: accepts <code>&amp;str</code>, <code>String</code>, <code>&amp;Path</code>, <code>PathBuf</code>.</li>
</ul>
<hr>
<h2 id="adr-004-tower-style-middleware-pattern"><a class="header" href="#adr-004-tower-style-middleware-pattern">ADR-004: Tower-style middleware pattern</a></h2>
<p><strong>Decision:</strong> Use composable middleware (decorator pattern) for cross-cutting concerns like limits, logging, and feature gates. Each middleware implements <code>VfsBackend</code> by wrapping another <code>VfsBackend</code>.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Complete separation of concerns - each layer has one job.</li>
<li>Composable - use only what you need.</li>
<li>Familiar pattern (Axum/Tower use the same approach).</li>
<li>No code duplication - middleware written once, works with any backend.</li>
<li>Testable - each layer can be tested in isolation.</li>
</ul>
<p><strong>Example:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = TracingBackend::new(
    FeatureGatedBackend::new(
        LimitedBackend::new(SqliteBackend::open("data.db")?)
    )
);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-005-stdfs-aligned-method-names"><a class="header" href="#adr-005-stdfs-aligned-method-names">ADR-005: <code>std::fs</code>-aligned method names</a></h2>
<p><strong>Decision:</strong> Prefer <code>read_dir</code>, <code>create_dir_all</code>, <code>remove_file</code>, etc.</p>
<p><strong>Why:</strong> Familiarity and reduced cognitive overhead.</p>
<hr>
<h2 id="adr-006-limitedbackend-for-quota-enforcement"><a class="header" href="#adr-006-limitedbackend-for-quota-enforcement">ADR-006: LimitedBackend for quota enforcement</a></h2>
<p><strong>Decision:</strong> Quota/limit enforcement is handled by <code>LimitedBackend&lt;B&gt;</code> middleware, not by backends or FilesContainer.</p>
<p><strong>Configuration:</strong></p>
<ul>
<li><code>with_max_total_size(bytes)</code> - total storage limit</li>
<li><code>with_max_file_size(bytes)</code> - per-file limit</li>
<li><code>with_max_node_count(count)</code> - max files/directories</li>
<li><code>with_max_dir_entries(count)</code> - max entries per directory</li>
<li><code>with_max_path_depth(depth)</code> - max directory nesting</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Limits are policy, not storage semantics.</li>
<li>Written once, works with any backend.</li>
<li>Optional - users who don’t need limits skip this middleware.</li>
</ul>
<hr>
<h2 id="adr-007-featuregatedbackend-for-least-privilege"><a class="header" href="#adr-007-featuregatedbackend-for-least-privilege">ADR-007: FeatureGatedBackend for least-privilege</a></h2>
<p><strong>Decision:</strong> Dangerous features (symlinks, hard links, permission mutation) are disabled by default via <code>FeatureGatedBackend&lt;B&gt;</code> middleware.</p>
<p><strong>Configuration:</strong></p>
<ul>
<li><code>.with_symlinks()</code> - enable symlink creation/following</li>
<li><code>.with_hard_links()</code> - enable hard link creation</li>
<li><code>.with_permissions()</code> - enable <code>set_permissions</code></li>
<li><code>.with_max_symlink_resolution(n)</code> - limit symlink hops (default: 40)</li>
</ul>
<p>When disabled, operations return <code>VfsError::FeatureNotEnabled</code>.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Reduces attack surface by default.</li>
<li>Explicit opt-in for dangerous features.</li>
<li>Separate from backend - works with any backend.</li>
</ul>
<hr>
<h2 id="adr-008-filescontainer-as-thin-ergonomic-wrapper"><a class="header" href="#adr-008-filescontainer-as-thin-ergonomic-wrapper">ADR-008: FilesContainer as thin ergonomic wrapper</a></h2>
<p><strong>Decision:</strong> <code>FilesContainer&lt;B&gt;</code> is a thin wrapper that provides std::fs-aligned ergonomics only. It contains NO policy logic.</p>
<p><strong>What it does:</strong></p>
<ul>
<li>Provides familiar method names</li>
<li>Accepts <code>impl AsRef&lt;Path&gt;</code> for convenience</li>
<li>Delegates all operations to the wrapped backend</li>
</ul>
<p><strong>What it does NOT do:</strong></p>
<ul>
<li>Quota enforcement (use LimitedBackend)</li>
<li>Feature gating (use FeatureGatedBackend)</li>
<li>Instrumentation (use TracingBackend)</li>
<li>Any other policy</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Single responsibility - ergonomics only.</li>
<li>Users who don’t need ergonomics can use backends directly.</li>
<li>Policy is composable via middleware, not hardcoded.</li>
</ul>
<hr>
<h2 id="adr-009-built-in-backends-are-feature-gated"><a class="header" href="#adr-009-built-in-backends-are-feature-gated">ADR-009: Built-in backends are feature-gated</a></h2>
<p><strong>Decision:</strong> <code>anyfs</code> uses Cargo features so users only pull the dependencies they need.</p>
<ul>
<li><code>memory</code> (default)</li>
<li><code>sqlite</code> (optional)</li>
<li><code>vrootfs</code> (optional)</li>
</ul>
<p><strong>Why:</strong> Minimizes binary size and compile time for users who don’t need all backends.</p>
<hr>
<h2 id="adr-010-sync-first-async-ready-design"><a class="header" href="#adr-010-sync-first-async-ready-design">ADR-010: Sync-first, async-ready design</a></h2>
<p><strong>Decision:</strong> VfsBackend is synchronous for v1. The API is designed to allow adding <code>AsyncVfsBackend</code> later without breaking changes.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>All built-in backends are naturally synchronous:
<ul>
<li><code>MemoryBackend</code> - in-memory, instant</li>
<li><code>SqliteBackend</code> - rusqlite is sync</li>
<li><code>VRootFsBackend</code> - std::fs is sync</li>
</ul>
</li>
<li>Sync is simpler - no runtime dependency (tokio/async-std)</li>
<li>Users can wrap sync backends in <code>spawn_blocking</code> if needed</li>
</ul>
<p><strong>Async-ready design principles:</strong></p>
<ul>
<li>Trait requires <code>Send</code> - compatible with async executors</li>
<li>Return types are <code>Result&lt;T, VfsError&gt;</code> - works with async</li>
<li>No internal blocking assumptions</li>
<li>Methods are stateless per-call - no hidden blocking state</li>
</ul>
<p><strong>Future async path (Option 2):</strong>
When async is needed (e.g., network-backed storage), add a parallel trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-backend
pub trait AsyncVfsBackend: Send + Sync {
    async fn read(&amp;self, path: impl AsRef&lt;Path&gt; + Send) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    async fn write(&amp;mut self, path: impl AsRef&lt;Path&gt; + Send, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    // ... mirrors VfsBackend with async

    // Streaming uses AsyncRead/AsyncWrite
    async fn open_read(&amp;self, path: impl AsRef&lt;Path&gt; + Send)
        -&gt; Result&lt;Box&lt;dyn AsyncRead + Send + Unpin&gt;, VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Migration notes:</strong></p>
<ul>
<li><code>AsyncVfsBackend</code> would be a separate trait, not replacing <code>VfsBackend</code></li>
<li>Blanket impl possible: <code>impl&lt;T: VfsBackend&gt; AsyncVfsBackend for T</code> using <code>spawn_blocking</code></li>
<li>Middleware would need async variants: <code>AsyncLimitedBackend&lt;B&gt;</code>, etc.</li>
<li>No breaking changes to existing sync API</li>
</ul>
<p><strong>Why not async now:</strong></p>
<ul>
<li>Complexity without benefit - all current backends are sync</li>
<li>Rust 1.75 makes async traits easy, so adding later is low-cost</li>
<li>Better to wait for real async backend requirements</li>
</ul>
<hr>
<h2 id="adr-011-layer-trait-for-standardized-composition"><a class="header" href="#adr-011-layer-trait-for-standardized-composition">ADR-011: Layer trait for standardized composition</a></h2>
<p><strong>Decision:</strong> Provide a <code>Layer</code> trait (inspired by Tower) that standardizes middleware composition.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Layer&lt;B: VfsBackend&gt; {
    type Backend: VfsBackend;
    fn layer(self, backend: B) -&gt; Self::Backend;
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li>Standardized composition pattern familiar to Tower/Axum users.</li>
<li>IDE autocomplete for available layers.</li>
<li>Enables <code>BackendStack</code> fluent builder in anyfs-container.</li>
<li>Each middleware provides a corresponding <code>*Layer</code> type.</li>
</ul>
<p><strong>Example:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = SqliteBackend::open("data.db")?
    .layer(LimitedLayer::new().max_total_size(100_000))
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-012-tracingbackend-for-instrumentation"><a class="header" href="#adr-012-tracingbackend-for-instrumentation">ADR-012: TracingBackend for instrumentation</a></h2>
<p><strong>Decision:</strong> Use <code>TracingBackend&lt;B&gt;</code> integrated with the <code>tracing</code> ecosystem instead of a custom logging solution.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Works with existing tracing infrastructure (tracing-subscriber, OpenTelemetry, Jaeger).</li>
<li>Structured logging with spans for each operation.</li>
<li>Users choose their subscriber - no logging framework lock-in.</li>
<li>Consistent with modern Rust ecosystem practices.</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TracingBackend::new(backend)
    .with_target("anyfs")
    .with_level(tracing::Level::DEBUG)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-013-vfsbackendext-for-extension-methods"><a class="header" href="#adr-013-vfsbackendext-for-extension-methods">ADR-013: VfsBackendExt for extension methods</a></h2>
<p><strong>Decision:</strong> Provide <code>VfsBackendExt</code> trait with convenience methods, auto-implemented for all backends.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait VfsBackendExt: VfsBackend {
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, VfsError&gt;;
    fn write_json&lt;T: Serialize&gt;(&amp;mut self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), VfsError&gt;;
    fn is_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt;;
    fn is_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt;;
}

impl&lt;B: VfsBackend&gt; VfsBackendExt for B {}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li>Adds convenience without bloating <code>VfsBackend</code> trait.</li>
<li>Blanket impl means all backends get these methods for free.</li>
<li>Users can define their own extension traits for domain-specific operations.</li>
<li>Follows Rust convention (e.g., <code>IteratorExt</code>, <code>StreamExt</code>).</li>
</ul>
<hr>
<h2 id="adr-014-optional-bytes-support"><a class="header" href="#adr-014-optional-bytes-support">ADR-014: Optional Bytes support</a></h2>
<p><strong>Decision:</strong> Support the <code>bytes</code> crate via an optional feature for zero-copy efficiency.</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["bytes"] }
</code></pre>
<p><strong>Why:</strong></p>
<ul>
<li><code>Bytes</code> provides O(1) slicing via reference counting.</li>
<li>Beneficial for large file handling, network backends, streaming.</li>
<li>Optional - users who don’t need it avoid the dependency.</li>
<li>Default remains <code>Vec&lt;u8&gt;</code> for simplicity.</li>
</ul>
<p><strong>Trade-off:</strong> With <code>bytes</code> feature, <code>read</code> returns <code>Bytes</code> instead of <code>Vec&lt;u8&gt;</code>. This is a compile-time choice.</p>
<hr>
<h2 id="adr-015-contextual-vfserror"><a class="header" href="#adr-015-contextual-vfserror">ADR-015: Contextual VfsError</a></h2>
<p><strong>Decision:</strong> <code>VfsError</code> variants include context for better debugging.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>VfsError::NotFound {
    path: PathBuf,
    operation: &amp;'static str,  // "read", "metadata", etc.
}

VfsError::QuotaExceeded {
    limit: u64,
    requested: u64,
    usage: u64,
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li>Error messages include enough context to understand what failed.</li>
<li>No need for separate error context crate (like anyhow) for basic usage.</li>
<li>Operation field helps distinguish “file not found during read” vs “during metadata”.</li>
<li>Quota errors include all relevant numbers for debugging.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vfsbackend-trait-anyfs-backend"><a class="header" href="#vfsbackend-trait-anyfs-backend">VfsBackend Trait (anyfs-backend)</a></h1>
<p><strong>The core backend contract for AnyFS</strong></p>
<hr>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><code>VfsBackend</code> is the minimal interface a storage backend implements.</p>
<ul>
<li>It is <strong>path-based</strong> and aligned with <code>std::fs</code> naming.</li>
<li>It uses <code>impl AsRef&lt;Path&gt;</code> for paths (same as <code>std::fs</code>).</li>
<li>It handles <strong>storage + filesystem semantics only</strong> - no policy, no limits.</li>
</ul>
<p>Policy (limits, feature gates, logging) is handled by middleware.</p>
<hr>
<h2 id="trait-definition"><a class="header" href="#trait-definition">Trait Definition</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{Read, Write};
use std::path::{Path, PathBuf};

pub trait VfsBackend: Send {
    // ═══════════════════════════════════════════════════════════════════════
    // READ OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, VfsError&gt;;
    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt;;
    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
    fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, VfsError&gt;;
    fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, VfsError&gt;;

    // ═══════════════════════════════════════════════════════════════════════
    // WRITE OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════
    fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn append(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn create_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn create_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_file(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn rename(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn copy(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // ═══════════════════════════════════════════════════════════════════════
    // LINKS
    // ═══════════════════════════════════════════════════════════════════════
    fn symlink(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn hard_link(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // ═══════════════════════════════════════════════════════════════════════
    // PERMISSIONS
    // ═══════════════════════════════════════════════════════════════════════
    fn set_permissions(&amp;mut self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), VfsError&gt;;

    // ═══════════════════════════════════════════════════════════════════════
    // STREAMING I/O
    // ═══════════════════════════════════════════════════════════════════════
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, VfsError&gt;;
    fn open_write(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, VfsError&gt;;

    // ═══════════════════════════════════════════════════════════════════════
    // FILE SIZE
    // ═══════════════════════════════════════════════════════════════════════
    fn truncate(&amp;mut self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), VfsError&gt;;

    // ═══════════════════════════════════════════════════════════════════════
    // DURABILITY
    // ═══════════════════════════════════════════════════════════════════════
    fn sync(&amp;mut self) -&gt; Result&lt;(), VfsError&gt;;
    fn fsync(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // ═══════════════════════════════════════════════════════════════════════
    // FILESYSTEM INFO
    // ═══════════════════════════════════════════════════════════════════════
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="semantics"><a class="header" href="#semantics">Semantics</a></h2>
<ul>
<li><code>read</code>/<code>write</code>/<code>metadata</code>/<code>exists</code>/<code>copy</code> follow symlinks.</li>
<li><code>symlink_metadata</code> and <code>read_link</code> do not follow.</li>
<li><code>remove_file</code> removes the symlink itself, not the target.</li>
<li>Streaming methods (<code>open_read</code>, <code>open_write</code>) enable large file handling.</li>
<li><code>truncate</code> resizes a file: shrinks by discarding bytes, extends with zeros.</li>
<li><code>sync</code> flushes all pending writes to durable storage.</li>
<li><code>fsync</code> flushes pending writes for a specific file.</li>
<li><code>statfs</code> returns filesystem capacity information.</li>
</ul>
<hr>
<h2 id="what-vfsbackend-does-not-do"><a class="header" href="#what-vfsbackend-does-not-do">What VfsBackend Does NOT Do</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Where It Lives</th></tr>
</thead>
<tbody>
<tr><td>Quota enforcement</td><td><code>LimitedBackend&lt;B&gt;</code> middleware</td></tr>
<tr><td>Feature gating</td><td><code>FeatureGatedBackend&lt;B&gt;</code> middleware</td></tr>
<tr><td>Audit logging</td><td><code>LoggingBackend&lt;B&gt;</code> middleware</td></tr>
<tr><td>Ergonomic API</td><td><code>FilesContainer&lt;B&gt;</code> wrapper</td></tr>
</tbody>
</table>
</div>
<p>Backends focus on storage. Policy is middleware.</p>
<hr>
<h2 id="implementing-a-backend"><a class="header" href="#implementing-a-backend">Implementing a Backend</a></h2>
<ul>
<li>Depend on <code>anyfs-backend</code> only.</li>
<li>Accept <code>impl AsRef&lt;Path&gt;</code> for all path parameters.</li>
<li>Return <code>std::fs</code>-like errors.</li>
</ul>
<p>See <code>book/src/implementation/backend-guide.md</code> for a step-by-step guide.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="filescontainer-anyfs-container"><a class="header" href="#filescontainer-anyfs-container">FilesContainer (anyfs-container)</a></h1>
<p><strong>Thin ergonomic wrapper for std::fs-aligned API</strong></p>
<hr>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p><code>FilesContainer&lt;B: VfsBackend&gt;</code> is a <strong>thin wrapper</strong> that provides a familiar std::fs-aligned API.</p>
<p><strong>It does ONE thing:</strong> Ergonomics. Nothing else.</p>
<p>All policy (limits, feature gates, logging) is handled by middleware, not FilesContainer.</p>
<hr>
<h2 id="creating-a-container"><a class="header" href="#creating-a-container">Creating a Container</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

// Simple: just ergonomics
let mut fs = FilesContainer::new(MemoryBackend::new());
<span class="boring">}</span></code></pre>
<p>With middleware:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, LimitedBackend, FeatureGatedBackend};
use anyfs_container::FilesContainer;

// Compose middleware, then wrap in FilesContainer
let backend = FeatureGatedBackend::new(
    LimitedBackend::new(SqliteBackend::open("data.db")?)
        .with_max_total_size(100 * 1024 * 1024)
)
.with_symlinks();

let mut fs = FilesContainer::new(backend);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="stdfs-aligned-methods"><a class="header" href="#stdfs-aligned-methods">std::fs-aligned Methods</a></h2>
<p>FilesContainer mirrors std::fs naming:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FilesContainer</th><th>std::fs</th></tr>
</thead>
<tbody>
<tr><td><code>read()</code></td><td><code>std::fs::read</code></td></tr>
<tr><td><code>read_to_string()</code></td><td><code>std::fs::read_to_string</code></td></tr>
<tr><td><code>write()</code></td><td><code>std::fs::write</code></td></tr>
<tr><td><code>read_dir()</code></td><td><code>std::fs::read_dir</code></td></tr>
<tr><td><code>create_dir()</code></td><td><code>std::fs::create_dir</code></td></tr>
<tr><td><code>create_dir_all()</code></td><td><code>std::fs::create_dir_all</code></td></tr>
<tr><td><code>remove_file()</code></td><td><code>std::fs::remove_file</code></td></tr>
<tr><td><code>remove_dir()</code></td><td><code>std::fs::remove_dir</code></td></tr>
<tr><td><code>remove_dir_all()</code></td><td><code>std::fs::remove_dir_all</code></td></tr>
<tr><td><code>rename()</code></td><td><code>std::fs::rename</code></td></tr>
<tr><td><code>copy()</code></td><td><code>std::fs::copy</code></td></tr>
<tr><td><code>metadata()</code></td><td><code>std::fs::metadata</code></td></tr>
<tr><td><code>symlink_metadata()</code></td><td><code>std::fs::symlink_metadata</code></td></tr>
<tr><td><code>read_link()</code></td><td><code>std::fs::read_link</code></td></tr>
<tr><td><code>set_permissions()</code></td><td><code>std::fs::set_permissions</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="what-filescontainer-does-not-do"><a class="header" href="#what-filescontainer-does-not-do">What FilesContainer Does NOT Do</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Use Instead</th></tr>
</thead>
<tbody>
<tr><td>Quota enforcement</td><td><code>LimitedBackend&lt;B&gt;</code></td></tr>
<tr><td>Feature gating</td><td><code>FeatureGatedBackend&lt;B&gt;</code></td></tr>
<tr><td>Audit logging</td><td><code>LoggingBackend&lt;B&gt;</code></td></tr>
<tr><td>Path containment</td><td>Backend-specific (VRootFsBackend)</td></tr>
</tbody>
</table>
</div>
<p>FilesContainer is <strong>purely ergonomic</strong>. If you need policy, compose middleware.</p>
<hr>
<h2 id="layer-helper"><a class="header" href="#layer-helper">Layer Helper</a></h2>
<p>For Axum-style composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = FilesContainer::new(SqliteBackend::open("data.db")?)
    .layer(LimitedLayer::new().max_total_size(100 * 1024 * 1024))
    .layer(FeatureGateLayer::new().allow_symlinks());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="direct-backend-access"><a class="header" href="#direct-backend-access">Direct Backend Access</a></h2>
<p>If you don’t need ergonomics, use backends directly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, LimitedBackend};
use anyfs_backend::VfsBackend;

let mut backend = LimitedBackend::new(MemoryBackend::new())
    .with_max_total_size(100 * 1024 * 1024);

// Use VfsBackend methods directly
backend.write("/file.txt", b"data")?;
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="which-crate-should-i-use"><a class="header" href="#which-crate-should-i-use">Which Crate Should I Use?</a></h1>
<hr>
<h2 id="decision-guide"><a class="header" href="#decision-guide">Decision Guide</a></h2>
<ul>
<li>Building an application? Use <code>anyfs-container</code> (<code>FilesContainer</code>).</li>
<li>Need a built-in backend (memory/sqlite/vrootfs)? Use <code>anyfs</code>.</li>
<li>Implementing your own backend? Depend only on <code>anyfs-traits</code>.</li>
</ul>
<hr>
<h2 id="quick-examples"><a class="header" href="#quick-examples">Quick Examples</a></h2>
<h3 id="application-code-recommended"><a class="header" href="#application-code-recommended">Application code (recommended)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let mut container = FilesContainer::new(MemoryBackend::new());
container.create_dir_all("/data")?;
container.write("/data/file.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<h3 id="application-code-with-policy-quotas--feature-whitelist"><a class="header" href="#application-code-with-policy-quotas--feature-whitelist">Application code with policy (quotas + feature whitelist)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::ContainerBuilder;

let mut container = ContainerBuilder::new(SqliteBackend::open_or_create("tenant.db")?)
    .max_total_size(100 * 1024 * 1024)
    .symlinks()
    .max_symlink_resolution(40)
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="custom-backend-implementation"><a class="header" href="#custom-backend-implementation">Custom backend implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_traits::{VfsBackend, VirtualPath};

pub struct MyBackend;

impl VfsBackend for MyBackend {
    fn read(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt; {
        todo!()
    }

    // ... implement the remaining methods
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="common-mistake"><a class="header" href="#common-mistake">Common Mistake</a></h2>
<p>If you are implementing a backend, avoid depending on <code>anyfs</code> unless you specifically need built-in backends.
Use <code>anyfs-traits</code> as your dependency.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs-container---comparison-and-positioning"><a class="header" href="#anyfs-container---comparison-and-positioning">AnyFS Container - Comparison and Positioning</a></h1>
<p><strong>How AnyFS Container compares to existing solutions</strong></p>
<p>AnyFS Container (<code>anyfs-container</code>) is a policy layer (quotas + isolation) over a pluggable virtual filesystem backend (<code>VfsBackend</code> from <code>anyfs-traits</code>). With the SQLite backend (<code>anyfs</code> feature <code>sqlite</code>), a tenant’s filesystem becomes a single portable <code>.db</code> file. It defaults to a least-privilege feature set; advanced features (symlinks, hard links, permissions) are opt-in.</p>
<hr>
<h2 id="executive-comparison"><a class="header" href="#executive-comparison">Executive Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Solution</th><th>Type</th><th style="text-align: right">Isolation</th><th style="text-align: right">Portability</th><th style="text-align: right">Multi-tenant</th><th style="text-align: right">Backend choice</th></tr>
</thead>
<tbody>
<tr><td><strong>AnyFS Container</strong></td><td>Library</td><td style="text-align: right">Yes</td><td style="text-align: right">Backend-dependent (SQLite = single file)</td><td style="text-align: right">Yes (per-tenant containers + quotas)</td><td style="text-align: right">Yes (trait-based)</td></tr>
<tr><td>SQLAR</td><td>Archive format</td><td style="text-align: right">No</td><td style="text-align: right">Yes (single file)</td><td style="text-align: right">No</td><td style="text-align: right">No (SQLite only)</td></tr>
<tr><td>libsqlfs</td><td>FUSE filesystem</td><td style="text-align: right">Varies (via mount)</td><td style="text-align: right">Yes (single file)</td><td style="text-align: right">No</td><td style="text-align: right">No (SQLite only)</td></tr>
<tr><td>AgentFS</td><td>Agent sandbox</td><td style="text-align: right">Yes (namespaces)</td><td style="text-align: right">Yes (SQLite)</td><td style="text-align: right">Partial</td><td style="text-align: right">No (SQLite only)</td></tr>
<tr><td><code>vfs</code> crate</td><td>Abstraction</td><td style="text-align: right">Backend-dependent</td><td style="text-align: right">Backend-dependent</td><td style="text-align: right">No</td><td style="text-align: right">Yes (trait-based)</td></tr>
<tr><td>Docker/containers</td><td>Runtime</td><td style="text-align: right">Yes</td><td style="text-align: right">Complex</td><td style="text-align: right">Yes</td><td style="text-align: right">N/A</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="detailed-comparisons"><a class="header" href="#detailed-comparisons">Detailed Comparisons</a></h2>
<h3 id="vs-sqlar-sqlite-archive"><a class="header" href="#vs-sqlar-sqlite-archive">vs. SQLAR (SQLite archive)</a></h3>
<p><strong>What it is:</strong> SQLite’s official archive format. It’s great for import/export and backups, but it’s not a VFS API.</p>
<p><strong>Schema (representative):</strong></p>
<pre><code class="language-sql">CREATE TABLE sqlar(
  name TEXT PRIMARY KEY,
  mode INT,
  mtime INT,
  sz INT,
  data BLOB
);
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>SQLAR</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>API</td><td>SQL statements</td><td><code>FilesContainer</code> methods (<code>read</code>, <code>write</code>, <code>read_dir</code>, …)</td></tr>
<tr><td>Quotas</td><td>No</td><td>Yes (container-enforced)</td></tr>
<tr><td>Isolation</td><td>No</td><td>Yes (validated virtual paths, no host escape)</td></tr>
<tr><td>Transactions (public API)</td><td>Manual</td><td>No (SQLite backend uses transactions internally)</td></tr>
<tr><td>Link semantics</td><td>Not the focus</td><td>Supported (opt-in: symlink + hard link + permissions)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use SQLAR when:</strong> you want a simple archive/restore format.</p>
<p><strong>Use AnyFS Container when:</strong> your application needs filesystem-like operations + isolation + quotas.</p>
<hr>
<h3 id="vs-libsqlfs-guardian-project"><a class="header" href="#vs-libsqlfs-guardian-project">vs. libsqlfs (Guardian Project)</a></h3>
<p><strong>What it is:</strong> A FUSE filesystem backed by SQLite, aimed at secure mobile storage.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>libsqlfs</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>Interface</td><td>Mounted filesystem</td><td>Library API</td></tr>
<tr><td>Deployment</td><td>Requires FUSE + OS integration</td><td>No mount, no host path access</td></tr>
<tr><td>Scope</td><td>POSIX filesystem</td><td><code>std::fs</code>-aligned trait (not full POSIX)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use libsqlfs when:</strong> you need a real mounted filesystem.</p>
<p><strong>Use AnyFS Container when:</strong> you want embedded application storage without mounting.</p>
<hr>
<h3 id="vs-agentfs-turso"><a class="header" href="#vs-agentfs-turso">vs. AgentFS (Turso)</a></h3>
<p><strong>What it is:</strong> A SQLite-backed virtual filesystem aimed at sandboxing AI agents.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>AgentFS</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>Focus</td><td>Agent sandboxing + audit</td><td>General-purpose embedded storage</td></tr>
<tr><td>Isolation</td><td>OS namespaces</td><td>Structural (validated virtual paths)</td></tr>
<tr><td>Backend</td><td>SQLite only</td><td>Pluggable (SQLite is one option)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use AgentFS when:</strong> you want OS-level sandboxing + auditing.</p>
<p><strong>Use AnyFS Container when:</strong> you want a small, embeddable library with backend choice and quotas.</p>
<hr>
<h3 id="vs-vfs-crate-rust"><a class="header" href="#vs-vfs-crate-rust">vs. <code>vfs</code> crate (Rust)</a></h3>
<p><strong>What it is:</strong> A general Rust VFS trait + backends.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th><code>vfs</code> crate</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>Trait design</td><td>Path-based operations</td><td>Path-based <code>VfsBackend</code> (<code>std::fs</code>-aligned)</td></tr>
<tr><td>Path safety</td><td>Backend-dependent</td><td>Centralized validation into <code>VirtualPath</code></td></tr>
<tr><td>SQLite backend</td><td>Not included</td><td>Built-in backend (feature-gated)</td></tr>
<tr><td>Quotas</td><td>No</td><td>Yes (<code>anyfs-container</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use <code>vfs</code> when:</strong> you want a drop-in abstraction close to <code>std::fs</code>.</p>
<p><strong>Use AnyFS Container when:</strong> you need portable storage + quotas + containment guarantees.</p>
<hr>
<h3 id="vs-dockercontainers"><a class="header" href="#vs-dockercontainers">vs. Docker/containers</a></h3>
<p><strong>What it is:</strong> OS-level virtualization with isolated filesystem namespaces.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Containers</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>Isolation level</td><td>OS process</td><td>Library</td></tr>
<tr><td>Overhead</td><td>High</td><td>Low</td></tr>
<tr><td>Primary use</td><td>Execute code</td><td>Store data</td></tr>
</tbody>
</table>
</div>
<p><strong>Use containers when:</strong> you need to run untrusted code.</p>
<p><strong>Use AnyFS Container when:</strong> you just need isolated application data storage.</p>
<hr>
<h2 id="feature-matrix"><a class="header" href="#feature-matrix">Feature Matrix</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>AnyFS Container</th><th>SQLAR</th><th>libsqlfs</th><th>AgentFS</th><th><code>vfs</code> crate</th></tr>
</thead>
<tbody>
<tr><td>Directories</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Files</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Symlinks</td><td>Yes</td><td>Limited/unstandardized</td><td>Yes</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Hard links</td><td>Yes</td><td>No</td><td>Yes</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Permissions</td><td>Yes (simple)</td><td>Limited (mode only)</td><td>Yes</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Extended attrs</td><td>No (future)</td><td>No</td><td>Varies</td><td>Varies</td><td>No</td></tr>
<tr><td>Transactions (public API)</td><td>No</td><td>Manual</td><td>Yes</td><td>Varies</td><td>No</td></tr>
<tr><td>Capacity limits</td><td>Yes (built-in)</td><td>No</td><td>No</td><td>Varies</td><td>No</td></tr>
<tr><td>Streaming I/O</td><td>No (future)</td><td>No</td><td>Yes</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Async API</td><td>No (future)</td><td>N/A</td><td>No</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>FUSE mount</td><td>No (by design)</td><td>No</td><td>Yes</td><td>Yes</td><td>Backend-dependent</td></tr>
<tr><td>Compression</td><td>Backend</td><td>Yes (deflate)</td><td>Varies</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Encryption</td><td>Backend</td><td>No</td><td>Yes (SQLCipher)</td><td>Varies</td><td>Backend-dependent</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="when-to-use-anyfs-container"><a class="header" href="#when-to-use-anyfs-container">When to Use AnyFS Container</a></h2>
<p><strong>Good fit:</strong></p>
<ul>
<li>Multi-tenant SaaS that needs per-tenant quotas</li>
<li>Desktop apps that want portable user data</li>
<li>Testing that needs deterministic isolated storage</li>
<li>Plugin systems that need per-plugin isolation</li>
</ul>
<p><strong>Not a good fit:</strong></p>
<ul>
<li>You must mount a filesystem into the host OS (use a FUSE solution)</li>
<li>You need full POSIX behavior (xattrs/ACLs/etc.)</li>
<li>You need maximum throughput over safety/portability</li>
</ul>
<hr>
<h2 id="migration-paths"><a class="header" href="#migration-paths">Migration Paths</a></h2>
<h3 id="from-raw-sqlitesqlar"><a class="header" href="#from-raw-sqlitesqlar">From raw SQLite/SQLAR</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Old: raw SQL
conn.execute("INSERT INTO sqlar(name, data) VALUES (?, ?)", [path, data])?;

// New: AnyFS Container
container.write(path, data)?;
<span class="boring">}</span></code></pre>
<h3 id="from-stdfs"><a class="header" href="#from-stdfs">From <code>std::fs</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Old: host filesystem
std::fs::write("/data/file.txt", content)?;

// New: AnyFS Container
container.write("/data/file.txt", content)?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>AnyFS Container occupies a niche between archives (SQLAR) and mounted filesystems (FUSE): it is an <strong>application-level</strong> filesystem API with <strong>quotas</strong> and <strong>containment guarantees</strong>, with <strong>backend choice</strong> (including a portable SQLite option).</p>
<p><em>For technical details, see the <a href="#anyfs---design-overview">Design Overview</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h1>
<p><strong>Security model, threat analysis, and containment guarantees</strong></p>
<hr>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The AnyFS ecosystem is designed with security as a primary concern. This document outlines the security model, potential threats, and the guarantees provided by the architecture.</p>
<hr>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<h3 id="in-scope"><a class="header" href="#in-scope">In Scope</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Description</th><th>Mitigation</th></tr>
</thead>
<tbody>
<tr><td><strong>Path traversal</strong></td><td>Attacker attempts to access files outside the container via <code>../</code></td><td>Lexical path resolution in <code>VirtualPath</code></td></tr>
<tr><td><strong>Symlink attacks</strong></td><td>Attacker uses symlinks to bypass controls</td><td>Symlinks are disabled by default; when enabled, targets validated and resolution is bounded</td></tr>
<tr><td><strong>Resource exhaustion</strong></td><td>Attacker fills storage or creates excessive files</td><td>Capacity limits enforced by <code>FilesContainer</code></td></tr>
<tr><td><strong>Tenant data leakage</strong></td><td>One tenant accesses another’s data</td><td>Complete isolation via separate containers</td></tr>
</tbody>
</table>
</div>
<h3 id="out-of-scope"><a class="header" href="#out-of-scope">Out of Scope</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><strong>Side-channel attacks</strong></td><td>Timing attacks, cache analysis — requires OS-level mitigations</td></tr>
<tr><td><strong>Physical access</strong></td><td>Disk encryption is application’s responsibility</td></tr>
<tr><td><strong>SQLite vulnerabilities</strong></td><td>Upstream dependency; update regularly</td></tr>
<tr><td><strong>Denial of service</strong></td><td>Rate limiting is application’s responsibility</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h2>
<h3 id="1-path-normalization"><a class="header" href="#1-path-normalization">1. Path Normalization</a></h3>
<p>All user paths are normalized by <code>FilesContainer</code> before reaching the backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User input is normalized immediately
// These attacks are structurally prevented:
"/../../../etc/passwd"  // → "/etc/passwd" (clamped to root)
"/data/../../../../tmp" // → "/tmp" (clamped to root)
<span class="boring">}</span></code></pre>
<p><strong>Guarantee</strong>: No path can escape the virtual root, regardless of <code>..</code> sequences.</p>
<h3 id="2-lexical-path-resolution"><a class="header" href="#2-lexical-path-resolution">2. Lexical Path Resolution</a></h3>
<p>Unlike POSIX filesystems, paths are resolved <strong>lexically</strong> without consulting the filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// POSIX behavior (dangerous):
// /foo/bar/.. where bar → /etc would resolve to /etc/../ → /

// AnyFS behavior (safe):
// /foo/bar/.. always resolves to /foo (pure string manipulation)
<span class="boring">}</span></code></pre>
<p><strong>Guarantee</strong>: Lexical normalization is deterministic. If symlinks are disabled (default), resolution cannot be influenced by filesystem state; if enabled, symlink traversal is contained and bounded.</p>
<h3 id="path-containment-by-backend-type"><a class="header" href="#path-containment-by-backend-type">Path Containment by Backend Type</a></h3>
<p>Different backends achieve containment differently:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Containment Mechanism</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Isolated by OS process memory—no host filesystem access</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Each container is a separate <code>.db</code> file—no path traversal possible</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Uses <code>strict-path::VirtualRoot</code> to clamp all paths to a root directory</td></tr>
</tbody>
</table>
</div>
<h3 id="3-symlink-safety-opt-in"><a class="header" href="#3-symlink-safety-opt-in">3. Symlink Safety (Opt-In)</a></h3>
<p>Symlink safety:</p>
<ul>
<li>Symlinks are <strong>disabled by default</strong> (least privilege / whitelist)</li>
<li>If enabled, symlink targets are validated</li>
<li>Resolution is bounded by a configurable hop limit (default: 40)</li>
<li>Symlinks cannot point outside the container</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let mut container = FilesContainer::new(MemoryBackend::new())
    .with_symlinks()
    .with_max_symlink_resolution(40);

// Symlink creation validates the target (when enabled)
container.symlink("/deeply/nested/path", "/shortcut")?;

// Following symlinks respects the depth limit
container.read("/shortcut")?;  // Max 40 hops
<span class="boring">}</span></code></pre>
<p><strong>Guarantee</strong>: Symlink loops are detected; symlinks cannot escape containment (when enabled).</p>
<h3 id="4-capacity-limits"><a class="header" href="#4-capacity-limits">4. Capacity Limits</a></h3>
<p><code>FilesContainer</code> enforces configurable limits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let container = FilesContainer::new(MemoryBackend::new())
    .with_max_total_size(100 * 1024 * 1024)  // 100 MB total
    .with_max_file_size(10 * 1024 * 1024)    // 10 MB per file
    .with_max_node_count(10_000)              // 10K files/directories
    .with_max_dir_entries(1_000)              // 1K entries per directory
    .with_max_path_depth(64);                 // Max directory depth
<span class="boring">}</span></code></pre>
<p><strong>Guarantee</strong>: Resource exhaustion attacks are mitigated.</p>
<hr>
<h2 id="secure-usage-patterns"><a class="header" href="#secure-usage-patterns">Secure Usage Patterns</a></h2>
<h3 id="multi-tenant-isolation"><a class="header" href="#multi-tenant-isolation">Multi-Tenant Isolation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::FilesContainer;

// Each tenant gets a completely separate container
fn create_tenant_storage(tenant_id: &amp;str) -&gt; FilesContainer&lt;SqliteBackend&gt; {
    let db_path = format!("tenants/{}.db", tenant_id);
    let backend = SqliteBackend::create(&amp;db_path).unwrap();

    FilesContainer::new(backend)
        .with_max_total_size(tenant_quota(tenant_id))
}

// No path can cross tenant boundaries — they're different files entirely
<span class="boring">}</span></code></pre>
<h3 id="untrusted-input-handling"><a class="header" href="#untrusted-input-handling">Untrusted Input Handling</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::VfsBackend;
use anyfs_container::{FilesContainer, ContainerError};

fn handle_user_upload(
    container: &amp;mut FilesContainer&lt;impl VfsBackend&gt;,
    user_filename: &amp;str,  // Untrusted input
    data: &amp;[u8],
) -&gt; Result&lt;(), ContainerError&gt; {
    // FilesContainer normalizes the path internally:
    // - Rejects invalid UTF-8
    // - Normalizes path (removes .., .)
    // - Ensures absolute path
    let path = format!("/uploads/{}", user_filename);

    // Safe to use - container validates before reaching backend
    container.write(&amp;path, data)?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="sandboxed-execution"><a class="header" href="#sandboxed-execution">Sandboxed Execution</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

// Create an isolated sandbox for untrusted code
let sandbox = FilesContainer::new(MemoryBackend::new())
    .with_max_total_size(10 * 1024 * 1024)  // 10 MB limit
    .with_max_file_size(1024 * 1024)         // 1 MB per file
    .with_max_node_count(100);               // Max 100 files

// Untrusted code can only access this sandbox
// Cannot escape, cannot exhaust resources
<span class="boring">}</span></code></pre>
<hr>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security Checklist</a></h2>
<h3 id="for-application-developers"><a class="header" href="#for-application-developers">For Application Developers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Set appropriate capacity limits for your use case</li>
<li><input disabled="" type="checkbox"> Use separate containers for separate tenants/users</li>
<li><input disabled="" type="checkbox"> Let <code>FilesContainer</code> handle path normalization—don’t bypass it</li>
<li><input disabled="" type="checkbox"> Consider restricting link operations if not needed (they’re off by default)</li>
<li><input disabled="" type="checkbox"> Keep dependencies updated (especially <code>rusqlite</code> for SQLite backend)</li>
</ul>
<h3 id="for-backend-implementers"><a class="header" href="#for-backend-implementers">For Backend Implementers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Ensure paths cannot escape the backend’s intended scope</li>
<li><input disabled="" type="checkbox"> For filesystem backends: use <code>strict-path</code> for path containment</li>
<li><input disabled="" type="checkbox"> Handle concurrent access safely (if supporting <code>Sync</code>)</li>
<li><input disabled="" type="checkbox"> Report errors without leaking internal/host paths</li>
</ul>
<hr>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<ol>
<li><strong>No encryption at rest</strong>: Use OS-level encryption (LUKS, FileVault) or encrypted SQLite extensions</li>
<li><strong>No access control lists</strong>: Permissions are opt-in and simple (Unix mode bits only)</li>
<li><strong>No audit logging</strong>: Application must implement its own logging</li>
<li><strong>Time-of-check-time-of-use (TOCTOU)</strong>: Like all filesystems, check-then-act patterns may race</li>
</ol>
<hr>
<h2 id="reporting-security-issues"><a class="header" href="#reporting-security-issues">Reporting Security Issues</a></h2>
<p>If you discover a security vulnerability, please report it responsibly:</p>
<ol>
<li>Do not open a public issue</li>
<li>Email security concerns to the maintainers</li>
<li>Allow time for a fix before public disclosure</li>
</ol>
<hr>
<p><em>For implementation details, see <a href="#anyfs---architecture-decision-records">Architecture Decision Records</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs-container---technical-comparison-with-alternatives"><a class="header" href="#anyfs-container---technical-comparison-with-alternatives">AnyFS Container - Technical Comparison with Alternatives</a></h1>
<p>This document compares AnyFS (especially <code>anyfs-container</code>) with existing Rust filesystem abstractions.</p>
<hr>
<h2 id="executive-summary"><a class="header" href="#executive-summary">Executive summary</a></h2>
<p>AnyFS is opinionated around three goals:</p>
<ul>
<li><strong>Safety by construction</strong>: container APIs accept <code>impl AsRef&lt;Path&gt;</code>, but backends only see validated <code>&amp;VirtualPath</code> (from <code>strict-path</code>).</li>
<li><strong>Least privilege by default</strong>: advanced behaviors (symlinks, hard links, permission mutation) are denied unless explicitly enabled per container.</li>
<li><strong>Portable storage</strong>: the SQLite backend turns a tenant filesystem into a single portable <code>.db</code> file.</li>
</ul>
<hr>
<h2 id="compared-solutions"><a class="header" href="#compared-solutions">Compared solutions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Solution</th><th>What it is</th><th>Where it fits</th></tr>
</thead>
<tbody>
<tr><td><code>vfs</code></td><td>General-purpose VFS trait + backends</td><td>Simple path-based abstraction, streaming handles</td></tr>
<tr><td><code>virtual-filesystem</code></td><td>std::fs-like interface with sandbox option</td><td>Small abstraction for in-process sandboxing</td></tr>
<tr><td>OpenDAL</td><td>Object storage access layer</td><td>Cloud/object storage (async-first)</td></tr>
<tr><td>AgentFS</td><td>SQLite-backed agent sandbox</td><td>OS-level sandboxing + auditing (product-focused)</td></tr>
<tr><td>AnyFS</td><td>VFS backends + policy layer</td><td>Embedded storage, multi-tenant quotas, portability</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-trait--api-design"><a class="header" href="#1-trait--api-design">1. Trait / API design</a></h2>
<h3 id="vfs-crate-typical-shape"><a class="header" href="#vfs-crate-typical-shape"><code>vfs</code> crate (typical shape)</a></h3>
<p><code>vfs</code> exposes a path-based trait taking raw strings and often returns streaming handles:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FileSystem: Send + Sync {
    fn read_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn Iterator&lt;Item = String&gt; + Send&gt;&gt;;
    fn create_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn open_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndRead + Send&gt;&gt;;
    fn create_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndWrite + Send&gt;&gt;;
    fn metadata(&amp;self, path: &amp;str) -&gt; VfsResult&lt;VfsMetadata&gt;;
    fn exists(&amp;self, path: &amp;str) -&gt; VfsResult&lt;bool&gt;;
    fn remove_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn remove_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Implications:</strong></p>
<ul>
<li>Backends must validate/normalize paths themselves.</li>
<li>The API surface is typically “filesystem flavored”, but not standardized on <code>std::fs</code> naming.</li>
</ul>
<h3 id="anyfs-two-layer-path-handling--policy-layer"><a class="header" href="#anyfs-two-layer-path-handling--policy-layer">AnyFS: two-layer path handling + policy layer</a></h3>
<p>AnyFS splits responsibilities across three crates:</p>
<ul>
<li><code>anyfs-traits</code>: minimal <code>VfsBackend</code> + core types (backend implementers depend only on this)</li>
<li><code>anyfs</code>: re-exports <code>anyfs-traits</code> and provides built-in backends (feature-gated)</li>
<li><code>anyfs-container</code>: <code>FilesContainer&lt;B: VfsBackend&gt;</code> plus limits and feature whitelist</li>
</ul>
<p><strong>Backend trait (<code>anyfs-traits</code>):</strong> validated paths only.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

pub trait VfsBackend: Send {
    fn read(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn write(&amp;mut self, path: &amp;VirtualPath, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn read_dir(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;DirEntry&gt;, VfsError&gt;;
    fn symlink(&amp;mut self, original: &amp;VirtualPath, link: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    fn hard_link(&amp;mut self, original: &amp;VirtualPath, link: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    fn set_permissions(&amp;mut self, path: &amp;VirtualPath, perm: Permissions) -&gt; Result&lt;(), VfsError&gt;;
    // ... (20 std::fs-aligned methods total)
}
<span class="boring">}</span></code></pre>
<p><strong>User-facing API (<code>anyfs-container</code>):</strong> ergonomic paths, plus enforcement.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;

impl&lt;B: VfsBackend&gt; FilesContainer&lt;B&gt; {
    pub fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, ContainerError&gt;;
    pub fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), ContainerError&gt;;
    // ... names aligned with std::fs
}
<span class="boring">}</span></code></pre>
<p><strong>Implications:</strong></p>
<ul>
<li>Path validation happens once, centrally, before any backend sees the path.</li>
<li>Limits and default-deny features are consistent across all backends.</li>
</ul>
<hr>
<h2 id="2-what-makes-anyfs-container-better"><a class="header" href="#2-what-makes-anyfs-container-better">2. What makes AnyFS Container better</a></h2>
<h3 id="21-centralized-path-safety"><a class="header" href="#21-centralized-path-safety">2.1 Centralized path safety</a></h3>
<ul>
<li><code>VirtualPath</code> normalizes <code>.</code> / <code>..</code> lexically and prevents escaping the virtual root.</li>
<li>Backends do not accept raw strings, reducing the attack surface.</li>
</ul>
<h3 id="22-least-privilege-feature-whitelist"><a class="header" href="#22-least-privilege-feature-whitelist">2.2 Least privilege (feature whitelist)</a></h3>
<p>Advanced behavior is disabled by default and enabled explicitly per container instance:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_container::ContainerBuilder;

let container = ContainerBuilder::new(backend)
    .symlinks()
    .max_symlink_resolution(40)
    .hard_links()
    .permissions()
    .build()?;
<span class="boring">}</span></code></pre>
<p>This supports a default-deny posture for apps handling untrusted input.</p>
<h3 id="23-built-in-quotas-and-limits"><a class="header" href="#23-built-in-quotas-and-limits">2.3 Built-in quotas and limits</a></h3>
<p><code>FilesContainer</code> can enforce limits like:</p>
<ul>
<li>max total bytes</li>
<li>max file size</li>
<li>max node count</li>
<li>max directory entries</li>
<li>max path depth</li>
</ul>
<p>Backends remain focused on storage, while enforcement stays consistent.</p>
<h3 id="24-portable-single-file-storage-sqlite-backend"><a class="header" href="#24-portable-single-file-storage-sqlite-backend">2.4 Portable “single file” storage (SQLite backend)</a></h3>
<p>With the <code>sqlite</code> backend, an entire tenant filesystem is a single <code>.db</code> file that can be copied/moved as a unit.</p>
<h3 id="25-dependency-control"><a class="header" href="#25-dependency-control">2.5 Dependency control</a></h3>
<ul>
<li><code>anyfs</code> uses Cargo features (<code>memory</code> default, <code>sqlite</code>, <code>vrootfs</code>) so users only compile what they use.</li>
<li>Custom backend authors depend only on <code>anyfs-traits</code>.</li>
</ul>
<hr>
<h2 id="3-tradeoffs--downsides"><a class="header" href="#3-tradeoffs--downsides">3. Tradeoffs / downsides</a></h2>
<h3 id="31-fewer-backends-initially"><a class="header" href="#31-fewer-backends-initially">3.1 Fewer backends (initially)</a></h3>
<p>AnyFS intentionally starts small: Memory, SQLite, and a contained host filesystem backend.</p>
<h3 id="32-sync-only-whole-file-io"><a class="header" href="#32-sync-only-whole-file-io">3.2 Sync-only, whole-file I/O</a></h3>
<p>The core API is sync-first and the common read/write APIs are whole-buffer (<code>Vec&lt;u8&gt;</code>).
Streaming handles and async APIs are future work.</p>
<h3 id="33-not-full-posix"><a class="header" href="#33-not-full-posix">3.3 Not full POSIX</a></h3>
<p>AnyFS aims for <code>std::fs</code> alignment, but does not try to exactly emulate OS edge cases.</p>
<h3 id="34-cross-platform-link-semantics"><a class="header" href="#34-cross-platform-link-semantics">3.4 Cross-platform link semantics</a></h3>
<p>Symlink and hard-link behavior differs across OSes and filesystems. AnyFS exposes links as a virtual concept, but real host filesystem behavior (especially on Windows) may vary.</p>
<hr>
<h2 id="4-when-to-use-what"><a class="header" href="#4-when-to-use-what">4. When to use what</a></h2>
<ul>
<li>Use <strong>AnyFS Container</strong> when you need embedded app storage, multi-tenant isolation, quotas, and portability.</li>
<li>Use <strong><code>vfs</code></strong> when you want a general-purpose VFS abstraction with streaming handles and you are comfortable with backend-specific path validation.</li>
<li>Use <strong>OpenDAL</strong> when your “filesystem” is actually object storage (S3/GCS/Azure) and you want async + middleware.</li>
</ul>
<hr>
<h2 id="5-feature-matrix-high-level"><a class="header" href="#5-feature-matrix-high-level">5. Feature matrix (high level)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>AnyFS Container</th><th><code>vfs</code></th><th>OpenDAL</th></tr>
</thead>
<tbody>
<tr><td>Path validation centralized</td><td>Yes (<code>VirtualPath</code>)</td><td>No</td><td>No</td></tr>
<tr><td>Quotas/limits</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td>Least-privilege defaults</td><td>Yes (whitelist)</td><td>No</td><td>N/A</td></tr>
<tr><td>SQLite backend</td><td>Yes (feature <code>sqlite</code>)</td><td>No</td><td>No</td></tr>
<tr><td>Host filesystem containment</td><td>Yes (<code>VRootFsBackend</code> + <code>VirtualRoot</code>)</td><td>Backend-dependent</td><td>N/A</td></tr>
<tr><td>Streaming I/O</td><td>Not yet</td><td>Often yes</td><td>Yes</td></tr>
<tr><td>Async API</td><td>Not yet</td><td>Backend-dependent</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<hr>
<p>If you spot an inconsistency between this document and <code>book/src/architecture/design-overview.md</code> or <code>AGENTS.md</code>, treat those as authoritative.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs-container---build-vs-reuse-analysis"><a class="header" href="#anyfs-container---build-vs-reuse-analysis">AnyFS Container - Build vs. Reuse Analysis</a></h1>
<p><strong>Can your goals be achieved with existing crates, or does this project need to exist?</strong></p>
<hr>
<h2 id="core-requirements"><a class="header" href="#core-requirements">Core Requirements</a></h2>
<ol>
<li><strong>Tenant isolation</strong> - each tenant gets an isolated namespace</li>
<li><strong>Capacity limits</strong> - per-tenant quotas and safe failure modes</li>
<li><strong>Portable storage option</strong> - a single-file backend (SQLite) for easy move/copy/backup</li>
<li><strong>Filesystem semantics</strong> - <code>std::fs</code>-aligned operations including opt-in symlinks and hard links</li>
<li><strong>Containment by construction</strong> - prevent path traversal and symlink escapes</li>
</ol>
<hr>
<h2 id="what-already-exists"><a class="header" href="#what-already-exists">What Already Exists</a></h2>
<h3 id="vfs-crate-rust"><a class="header" href="#vfs-crate-rust"><code>vfs</code> crate (Rust)</a></h3>
<p><strong>What it is:</strong> A general virtual filesystem abstraction with multiple backends.</p>
<p><strong>What it does well:</strong></p>
<ul>
<li>Provides an abstraction layer similar to <code>std::fs</code></li>
<li>Has multiple existing backends</li>
</ul>
<p><strong>What it does not provide (out of the box):</strong></p>
<ul>
<li>SQLite-backed portable storage</li>
<li>Capacity limits / quota enforcement</li>
<li>Built-in tenant isolation patterns</li>
<li>Two-layer path handling (ergonomic user paths + validated internal paths)</li>
</ul>
<p>You <em>can</em> implement a SQLite backend for <code>vfs</code>, but you still need to design quotas + isolation yourself.</p>
<h3 id="rusqlite"><a class="header" href="#rusqlite"><code>rusqlite</code></a></h3>
<p><strong>What it is:</strong> SQLite bindings.</p>
<p><strong>What it provides:</strong> DB access, transactions, blobs (with features), migrations.</p>
<p><strong>What it does not provide:</strong> Filesystem semantics or path safety.</p>
<h3 id="strict-path"><a class="header" href="#strict-path"><code>strict-path</code></a></h3>
<p><strong>What it is:</strong> Path validation + containment primitives (<code>VirtualRoot</code>, <code>VirtualPath</code>).</p>
<p><strong>What it provides:</strong> The “can’t escape the root” guarantee that the whole design depends on.</p>
<p><strong>What it does not provide:</strong> Storage backends (SQLite, memory, etc.) or a filesystem API.</p>
<h3 id="sqlar-sqlite-archive-format"><a class="header" href="#sqlar-sqlite-archive-format">SQLAR (SQLite archive format)</a></h3>
<p><strong>What it is:</strong> A standardized “files in a SQLite table” archive format.</p>
<p><strong>Why it’s not enough:</strong> It’s an archive format, not a filesystem API with quotas, isolation, and link semantics.</p>
<hr>
<h2 id="gap-analysis"><a class="header" href="#gap-analysis">Gap Analysis</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Requirement</th><th style="text-align: right"><code>vfs</code> crate</th><th style="text-align: right">SQLAR</th><th style="text-align: right"><code>rusqlite</code></th><th style="text-align: right"><code>strict-path</code></th></tr>
</thead>
<tbody>
<tr><td>Filesystem API</td><td style="text-align: right">Yes</td><td style="text-align: right">No</td><td style="text-align: right">No</td><td style="text-align: right">No</td></tr>
<tr><td>SQLite-backed portable storage</td><td style="text-align: right">No</td><td style="text-align: right">Yes (format)</td><td style="text-align: right">Yes (raw)</td><td style="text-align: right">No</td></tr>
<tr><td>Tenant isolation model</td><td style="text-align: right">No</td><td style="text-align: right">No</td><td style="text-align: right">Manual</td><td style="text-align: right">No</td></tr>
<tr><td>Capacity limits / quotas</td><td style="text-align: right">No</td><td style="text-align: right">No</td><td style="text-align: right">Manual</td><td style="text-align: right">No</td></tr>
<tr><td>Path traversal safety</td><td style="text-align: right">Backend-dependent</td><td style="text-align: right">Manual</td><td style="text-align: right">Manual</td><td style="text-align: right">Yes</td></tr>
<tr><td>Link semantics (symlink + hard link)</td><td style="text-align: right">Backend-dependent</td><td style="text-align: right">Not the focus</td><td style="text-align: right">Manual</td><td style="text-align: right">N/A</td></tr>
</tbody>
</table>
</div>
<p><strong>Conclusion:</strong> You can reuse key building blocks, but no existing crate composes into:</p>
<blockquote>
<p>“A tenant-isolated filesystem API with quotas, backed by SQLite, with containment guarantees.”</p>
</blockquote>
<hr>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<h3 id="option-a-implement-a-sqlite-backend-for-the-vfs-crate"><a class="header" href="#option-a-implement-a-sqlite-backend-for-the-vfs-crate">Option A: Implement a SQLite backend for the <code>vfs</code> crate</a></h3>
<p><strong>Pros</strong></p>
<ul>
<li>Immediate ecosystem compatibility</li>
<li>Familiar trait surface area</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Still need to build tenant isolation + quotas outside the trait</li>
<li>Path containment becomes backend/adapter responsibility</li>
<li>Streaming handle APIs can increase SQLite complexity</li>
</ul>
<h3 id="option-b-current-anyfs-architecture-recommended"><a class="header" href="#option-b-current-anyfs-architecture-recommended">Option B: Current AnyFS architecture (recommended)</a></h3>
<p><strong>Approach:</strong> Keep responsibilities separated into three crates:</p>
<ul>
<li><code>anyfs-traits</code>: <code>VfsBackend</code> + types, uses <code>&amp;VirtualPath</code></li>
<li><code>anyfs</code>: feature-gated built-in backends (<code>MemoryBackend</code>, <code>VRootFsBackend</code>, <code>SqliteBackend</code>)</li>
<li><code>anyfs-container</code>: <code>FilesContainer</code> wrapper (ergonomic <code>impl AsRef&lt;Path&gt;</code> + quotas)</li>
</ul>
<p><strong>Why this exists:</strong> It makes containment a property of the type system and concentrates validation in one place:
<code>FilesContainer</code> validates user paths once, then calls the backend with <code>&amp;VirtualPath</code>.</p>
<h3 id="option-c-stay-on-raw-rusqlite--your-own-helpers"><a class="header" href="#option-c-stay-on-raw-rusqlite--your-own-helpers">Option C: Stay on raw <code>rusqlite</code> (+ your own helpers)</a></h3>
<p>Fastest to prototype, but it becomes an ad-hoc filesystem without a stable contract, and quotas/isolation are easy to get wrong.</p>
<h3 id="option-d-add-a-compatibility-adapter-later-optional"><a class="header" href="#option-d-add-a-compatibility-adapter-later-optional">Option D: Add a compatibility adapter later (optional)</a></h3>
<p>Implement AnyFS as designed, then (optionally) provide an adapter that implements <code>vfs</code> traits on top of <code>FilesContainer</code>.</p>
<hr>
<h2 id="minimal-example-per-tenant-sqlite-file"><a class="header" href="#minimal-example-per-tenant-sqlite-file">Minimal Example (per-tenant SQLite file)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::ContainerBuilder;

let tenant_db = "tenant_123.db";

let mut container = ContainerBuilder::new(SqliteBackend::open_or_create(tenant_db)?)
    .max_total_size(100 * 1024 * 1024) // 100 MiB per tenant
    .build()?;

container.create_dir_all("/documents")?;
container.write("/documents/report.pdf", b"...")?;

// Portability: moving/copying the tenant is just moving/copying the DB file.
std::fs::copy(tenant_db, "tenant_123.backup.db")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Build on existing primitives (<code>strict-path</code>, <code>rusqlite</code>, <code>thiserror</code>), but keep the AnyFS split (traits / backends / container). That combination is what makes the design both ergonomic and hard to misuse.</p>
<p>For a concrete phased rollout, see <code>book/src/implementation/plan.md</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementation-plan"><a class="header" href="#implementation-plan">Implementation Plan</a></h1>
<p>This plan describes a phased rollout of the AnyFS ecosystem:</p>
<ul>
<li><code>anyfs-traits</code>: minimal contract (<code>VfsBackend</code> + core types, re-export <code>VirtualPath</code>)</li>
<li><code>anyfs</code>: built-in backends (feature-gated) + re-exports</li>
<li><code>anyfs-container</code>: <code>FilesContainer&lt;B: VfsBackend&gt;</code> policy layer (limits + feature whitelist)</li>
</ul>
<hr>
<h2 id="phase-1-anyfs-traits-core-contract"><a class="header" href="#phase-1-anyfs-traits-core-contract">Phase 1: <code>anyfs-traits</code> (core contract)</a></h2>
<p><strong>Goal:</strong> Define the stable backend interface and shared types.</p>
<ul>
<li>Re-export <code>strict_path::VirtualPath</code></li>
<li>Define core types (<code>Metadata</code>, <code>Permissions</code>, <code>FileType</code>, <code>DirEntry</code>)</li>
<li>Define <code>VfsError</code> (errors carry <code>VirtualPath</code> where relevant)</li>
<li>Define <code>VfsBackend</code> trait (20 <code>std::fs</code>-aligned, path-based methods)</li>
</ul>
<p><strong>Exit criteria:</strong> <code>anyfs-traits</code> stands alone with minimal dependencies (<code>strict-path</code>, <code>thiserror</code>).</p>
<hr>
<h2 id="phase-2-anyfs-built-in-backends"><a class="header" href="#phase-2-anyfs-built-in-backends">Phase 2: <code>anyfs</code> (built-in backends)</a></h2>
<p><strong>Goal:</strong> Provide a small set of reference/production backends behind Cargo features.</p>
<ul>
<li><code>memory</code> (default): <code>MemoryBackend</code></li>
<li><code>vrootfs</code> (optional): <code>VRootFsBackend</code> using <code>strict_path::VirtualRoot</code> for containment</li>
<li><code>sqlite</code> (optional): <code>SqliteBackend</code> storing an entire filesystem in a single <code>.db</code></li>
</ul>
<p><strong>Exit criteria:</strong> Each backend implements <code>VfsBackend</code> and passes the shared conformance suite.</p>
<hr>
<h2 id="phase-3-anyfs-container-policy--ergonomics"><a class="header" href="#phase-3-anyfs-container-policy--ergonomics">Phase 3: <code>anyfs-container</code> (policy + ergonomics)</a></h2>
<p><strong>Goal:</strong> Provide the user-facing <code>std::fs</code>-aligned API with consistent policy enforcement.</p>
<ul>
<li><code>FilesContainer&lt;B&gt;</code> accepts <code>impl AsRef&lt;Path&gt;</code> for ergonomics</li>
<li>Centralizes path validation: convert once to <code>VirtualPath</code>, then call backend</li>
<li>Enforces limits (quota and structural constraints):
<ul>
<li><code>max_total_size</code></li>
<li><code>max_file_size</code></li>
<li><code>max_node_count</code></li>
<li><code>max_dir_entries</code></li>
<li><code>max_path_depth</code></li>
</ul>
</li>
<li>Implements a least-privilege feature whitelist (default deny):
<ul>
<li><code>symlinks()</code> (+ <code>max_symlink_resolution</code>, default 40)</li>
<li><code>hard_links()</code></li>
<li><code>permissions()</code></li>
</ul>
</li>
</ul>
<p><strong>Exit criteria:</strong> An application can use <code>FilesContainer</code> as a drop-in for common <code>std::fs</code> patterns while gaining quotas + default-deny policy.</p>
<hr>
<h2 id="phase-4-conformance-test-suite"><a class="header" href="#phase-4-conformance-test-suite">Phase 4: Conformance test suite</a></h2>
<p><strong>Goal:</strong> Prevent backend divergence and make semantics explicit.</p>
<p>Recommended structure:</p>
<ul>
<li>Backend conformance tests (run against every <code>VfsBackend</code> implementation)
<ul>
<li><code>read</code>/<code>write</code>/<code>append</code> semantics</li>
<li>directory operations (<code>create_dir*</code>, <code>read_dir</code>, <code>remove_dir*</code>)</li>
<li><code>rename</code> and <code>copy</code> semantics</li>
<li>link behavior (<code>symlink</code>, <code>read_link</code>, <code>hard_link</code>, <code>nlink</code>)</li>
<li>permissions (<code>set_permissions</code>) where meaningful</li>
</ul>
</li>
<li>Container policy tests
<ul>
<li>limit enforcement and usage accounting</li>
<li>whitelist behavior (<code>FeatureNotEnabled</code>)</li>
<li>symlink resolution depth limit (when enabled)</li>
</ul>
</li>
</ul>
<p><strong>Exit criteria:</strong> All built-in backends pass the same suite; container policy tests are backend-agnostic.</p>
<hr>
<h2 id="phase-5-documentation--examples"><a class="header" href="#phase-5-documentation--examples">Phase 5: Documentation + examples</a></h2>
<ul>
<li>Keep <code>book/src/architecture/design-overview.md</code> + <code>book/src/architecture/adrs.md</code> authoritative</li>
<li>Provide at least one complete example per backend</li>
<li>Provide a backend implementer guide for <code>anyfs-traits</code></li>
</ul>
<hr>
<h2 id="future-work-out-of-scope-for-mvp"><a class="header" href="#future-work-out-of-scope-for-mvp">Future work (out of scope for MVP)</a></h2>
<ul>
<li>Streaming I/O (file handles)</li>
<li>Async API</li>
<li>Import/export helpers (host path &lt;-&gt; container path)</li>
<li>Extended attributes</li>
<li>Encryption-at-rest helpers (backend-specific)</li>
<li>Capability negotiation (optional): detect when a backend cannot support certain operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="backend-implementers-guide"><a class="header" href="#backend-implementers-guide">Backend Implementer’s Guide</a></h1>
<p>This guide walks you through implementing a custom AnyFS backend.</p>
<hr>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>A backend implements <code>VfsBackend</code>: a path-based trait aligned with <code>std::fs</code>.</p>
<p>Key properties:</p>
<ul>
<li>Backends accept <code>impl AsRef&lt;Path&gt;</code> for all path parameters</li>
<li>Backends handle <strong>storage + filesystem semantics only</strong></li>
<li>Policy (limits, feature gates) is handled by middleware, not backends</li>
</ul>
<hr>
<h2 id="dependency"><a class="header" href="#dependency">Dependency</a></h2>
<p>Depend only on <code>anyfs-backend</code>:</p>
<pre><code class="language-toml">[dependencies]
anyfs-backend = "0.1"
</code></pre>
<hr>
<h2 id="trait-to-implement"><a class="header" href="#trait-to-implement">Trait to Implement</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{VfsBackend, VfsError, Metadata, DirEntry, Permissions, StatFs};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

pub struct MyBackend {
    // Your storage fields
}

impl VfsBackend for MyBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, VfsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    fn open_write(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, VfsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    // ... implement all methods
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h2>
<h3 id="step-1-pick-a-data-model"><a class="header" href="#step-1-pick-a-data-model">Step 1: Pick a Data Model</a></h3>
<p>Your backend needs internal storage. Options:</p>
<ul>
<li><strong>HashMap-based</strong>: <code>HashMap&lt;PathBuf, Entry&gt;</code> for simple cases</li>
<li><strong>Tree-based</strong>: Explicit directory tree structure</li>
<li><strong>Database-backed</strong>: SQLite, key-value store, etc.</li>
</ul>
<p>Minimum metadata per entry:</p>
<ul>
<li>File type (file/directory/symlink)</li>
<li>Size (for files)</li>
<li>Content (for files)</li>
<li>Timestamps (optional)</li>
<li>Permissions (optional)</li>
</ul>
<h3 id="step-2-implement-read-operations"><a class="header" href="#step-2-implement-read-operations">Step 2: Implement Read Operations</a></h3>
<p>Start with these (easiest):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt;;
fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, VfsError&gt;;
fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, VfsError&gt;;
fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, VfsError&gt;;
<span class="boring">}</span></code></pre>
<h3 id="step-3-implement-write-operations"><a class="header" href="#step-3-implement-write-operations">Step 3: Implement Write Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
fn append(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
fn create_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
fn create_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
fn remove_file(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
fn remove_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
fn remove_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
fn rename(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
fn copy(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
<span class="boring">}</span></code></pre>
<h3 id="step-4-implement-links"><a class="header" href="#step-4-implement-links">Step 4: Implement Links</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn symlink(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
fn hard_link(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
<span class="boring">}</span></code></pre>
<ul>
<li>Symlinks store a target path as a string</li>
<li>Hard links share content with the original (update link count)</li>
</ul>
<h3 id="step-5-implement-permissions-and-streaming"><a class="header" href="#step-5-implement-permissions-and-streaming">Step 5: Implement Permissions and Streaming</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_permissions(&amp;mut self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), VfsError&gt;;
fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, VfsError&gt;;
fn open_write(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, VfsError&gt;;
<span class="boring">}</span></code></pre>
<h3 id="step-6-implement-truncate"><a class="header" href="#step-6-implement-truncate">Step 6: Implement truncate</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn truncate(&amp;mut self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), VfsError&gt;;
<span class="boring">}</span></code></pre>
<ul>
<li>If <code>size &lt; current</code>: discard trailing bytes</li>
<li>If <code>size &gt; current</code>: extend with zero bytes</li>
<li>Required for FUSE support and editor save operations</li>
</ul>
<h3 id="step-7-implement-syncfsync"><a class="header" href="#step-7-implement-syncfsync">Step 7: Implement sync/fsync</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sync(&amp;mut self) -&gt; Result&lt;(), VfsError&gt;;
fn fsync(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
<span class="boring">}</span></code></pre>
<ul>
<li><code>sync()</code>: Flush all pending writes to durable storage</li>
<li><code>fsync(path)</code>: Flush pending writes for a specific file</li>
<li><code>MemoryBackend</code> can no-op these (volatile by design)</li>
<li><code>SqliteBackend</code>: <code>PRAGMA wal_checkpoint</code> or connection flush</li>
<li><code>VRootFsBackend</code>: <code>std::fs::File::sync_all()</code></li>
</ul>
<h3 id="step-8-implement-statfs"><a class="header" href="#step-8-implement-statfs">Step 8: Implement statfs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn statfs(&amp;self) -&gt; Result&lt;StatFs, VfsError&gt;;
<span class="boring">}</span></code></pre>
<p>Return filesystem capacity information:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatFs {
    total_bytes: 0,      // 0 = unlimited
    used_bytes: ...,
    available_bytes: ...,
    total_inodes: 0,
    used_inodes: ...,
    available_inodes: ...,
    block_size: 4096,
    max_name_len: 255,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>Return appropriate <code>VfsError</code> variants:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Situation</th><th>Error</th></tr>
</thead>
<tbody>
<tr><td>Path doesn’t exist</td><td><code>VfsError::NotFound(path)</code></td></tr>
<tr><td>Path already exists</td><td><code>VfsError::AlreadyExists(path)</code></td></tr>
<tr><td>Expected file, got dir</td><td><code>VfsError::NotAFile(path)</code></td></tr>
<tr><td>Expected dir, got file</td><td><code>VfsError::NotADirectory(path)</code></td></tr>
<tr><td>Remove non-empty dir</td><td><code>VfsError::DirectoryNotEmpty(path)</code></td></tr>
<tr><td>Internal error</td><td><code>VfsError::Backend(message)</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="what-backends-do-not-do"><a class="header" href="#what-backends-do-not-do">What Backends Do NOT Do</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Where It Lives</th></tr>
</thead>
<tbody>
<tr><td>Quota enforcement</td><td><code>LimitedBackend&lt;B&gt;</code> middleware</td></tr>
<tr><td>Feature gating</td><td><code>FeatureGatedBackend&lt;B&gt;</code> middleware</td></tr>
<tr><td>Logging</td><td><code>LoggingBackend&lt;B&gt;</code> middleware</td></tr>
<tr><td>Ergonomic API</td><td><code>FilesContainer&lt;B&gt;</code> wrapper</td></tr>
</tbody>
</table>
</div>
<p><strong>Backends focus on storage.</strong> Keep them simple.</p>
<hr>
<h2 id="testing-your-backend"><a class="header" href="#testing-your-backend">Testing Your Backend</a></h2>
<p>Use the conformance test suite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::MyBackend;
    use anyfs_backend::VfsBackend;

    fn create_backend() -&gt; MyBackend {
        MyBackend::new()
    }

    #[test]
    fn test_write_read() {
        let mut backend = create_backend();
        backend.write("/test.txt", b"hello").unwrap();
        let content = backend.read("/test.txt").unwrap();
        assert_eq!(content, b"hello");
    }

    #[test]
    fn test_create_dir() {
        let mut backend = create_backend();
        backend.create_dir("/foo").unwrap();
        assert!(backend.exists("/foo").unwrap());
    }

    // ... more tests
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="note-on-vrootfsbackend"><a class="header" href="#note-on-vrootfsbackend">Note on VRootFsBackend</a></h2>
<p>If you are implementing a backend that wraps a <strong>real host filesystem directory</strong>, consider using <code>strict-path::VirtualPath</code> and <code>strict-path::VirtualRoot</code> internally for path containment. This ensures paths cannot escape the designated root directory.</p>
<p>This is an implementation choice for filesystem-based backends, not a requirement of the <code>VfsBackend</code> trait.</p>
<hr>
<h2 id="checklist"><a class="header" href="#checklist">Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Depends only on <code>anyfs-backend</code></li>
<li><input disabled="" type="checkbox"> Implements all <code>VfsBackend</code> methods (25 methods)</li>
<li><input disabled="" type="checkbox"> Accepts <code>impl AsRef&lt;Path&gt;</code> for all paths</li>
<li><input disabled="" type="checkbox"> Returns correct <code>VfsError</code> variants</li>
<li><input disabled="" type="checkbox"> Handles symlinks correctly (stores target path)</li>
<li><input disabled="" type="checkbox"> Handles hard links correctly (shares content)</li>
<li><input disabled="" type="checkbox"> Implements <code>truncate</code> (shrink/extend files)</li>
<li><input disabled="" type="checkbox"> Implements <code>sync</code>/<code>fsync</code> (durability)</li>
<li><input disabled="" type="checkbox"> Passes conformance tests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="open-questions--future-considerations"><a class="header" href="#open-questions--future-considerations">Open Questions &amp; Future Considerations</a></h1>
<p><strong>Status:</strong> Under Discussion
<strong>Last Updated:</strong> 2025-12-23</p>
<hr>
<p>This document captures open questions and design considerations that may influence future development of AnyFS.</p>
<hr>
<h2 id="symlink-handling-with-vrootfsbackend"><a class="header" href="#symlink-handling-with-vrootfsbackend">Symlink Handling with VRootFsBackend</a></h2>
<p><strong>Question:</strong> If VRootFsBackend wraps a real filesystem directory, and the user has symlinks disabled at the FilesContainer level, what happens to symlinks that exist in the underlying host filesystem?</p>
<p><strong>Considerations:</strong></p>
<ol>
<li>
<p><strong>VRootFsBackend inherits real FS behavior</strong>: The underlying filesystem still has symlinks. Even if we don’t expose symlink <em>creation</em> APIs, operations like <code>read</code> or <code>metadata</code> might still follow symlinks on the host.</p>
</li>
<li>
<p><strong>Options:</strong></p>
<ul>
<li><strong>Transparent following</strong>: VRootFsBackend always follows symlinks on the host (simplest, matches host behavior)</li>
<li><strong>Refuse symlinks</strong>: VRootFsBackend returns an error if it encounters a symlink</li>
<li><strong>Configurable per-backend</strong>: Let VRootFsBackend accept a <code>follow_symlinks: bool</code> option</li>
</ul>
</li>
<li>
<p><strong>Recommendation:</strong> VRootFsBackend should transparently follow symlinks on the host filesystem. The “symlinks disabled” policy at the container level means <em>creating</em> symlinks is disabled, not that the backend must refuse to traverse existing ones.</p>
</li>
</ol>
<hr>
<h2 id="virtual-vs-real-backends-path-resolution"><a class="header" href="#virtual-vs-real-backends-path-resolution">Virtual vs Real Backends: Path Resolution</a></h2>
<p><strong>Question:</strong> Should path resolution logic be different for virtual backends (memory, SQLite) vs filesystem-based backends (VRootFsBackend)?</p>
<p><strong>Analysis:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Type</th><th>Path Resolution</th><th>Symlink Handling</th></tr>
</thead>
<tbody>
<tr><td>MemoryBackend</td><td>Pure lexical (in our code)</td><td>We control everything</td></tr>
<tr><td>SqliteBackend</td><td>Pure lexical (in our code)</td><td>We control everything</td></tr>
<tr><td>VRootFsBackend</td><td>OS handles it</td><td>OS follows symlinks on host</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> For virtual backends, we perform lexical path resolution ourselves. For VRootFsBackend, we delegate to the OS via <code>std::fs</code>. The <code>strict-path::VirtualRoot</code> ensures we can’t escape the root directory, but symlink resolution within that root is handled by the OS.</p>
<hr>
<h2 id="compression-and-encryption"><a class="header" href="#compression-and-encryption">Compression and Encryption</a></h2>
<p><strong>Question:</strong> Does the current design allow backends to compress/decompress or encrypt/decrypt files transparently?</p>
<p><strong>Answer:</strong> Yes. The backend receives the data and stores it however it wants. A backend could:</p>
<ul>
<li>Compress data before writing to SQLite</li>
<li>Encrypt blobs with a user-provided key</li>
<li>Use a remote object store with encryption at rest</li>
</ul>
<p>This is an implementation detail of the backend, not visible to the <code>FilesContainer</code> API.</p>
<hr>
<h2 id="hooks-and-callbacks"><a class="header" href="#hooks-and-callbacks">Hooks and Callbacks</a></h2>
<p><strong>Question:</strong> Should AnyFS support hooks or callbacks for file operations (e.g., audit logging, validation)?</p>
<p><strong>Considerations:</strong></p>
<ul>
<li>AgentFS (see comparison below) provides audit logging as a core feature</li>
<li>Hooks add complexity but enable powerful use cases</li>
<li>Could be implemented as a middleware pattern around FilesContainer</li>
</ul>
<p><strong>Options:</strong></p>
<ol>
<li><strong>No hooks in v1</strong>: Keep it simple. Users can wrap FilesContainer in their own type.</li>
<li><strong>Event emitter</strong>: FilesContainer emits events that users can subscribe to</li>
<li><strong>Middleware trait</strong>: Allow wrapping backends with cross-cutting concerns</li>
</ol>
<p><strong>Recommendation:</strong> Defer to v2. Users can wrap <code>FilesContainer</code> or backends for now.</p>
<hr>
<h2 id="agentfs-comparison"><a class="header" href="#agentfs-comparison">AgentFS Comparison</a></h2>
<p><a href="https://github.com/tursodatabase/agentfs">AgentFS</a> is a filesystem designed for AI agents with:</p>
<ul>
<li><strong>Auditability</strong>: Every operation recorded in SQLite</li>
<li><strong>Reproducibility</strong>: Snapshot and restore agent state</li>
<li><strong>Portability</strong>: Everything in a single SQLite file</li>
</ul>
<p><strong>Similarities with AnyFS:</strong></p>
<ul>
<li>SQLite as portable storage</li>
<li>Single-file deployment</li>
<li>Agent/tenant isolation</li>
</ul>
<p><strong>Differences:</strong></p>
<ul>
<li>AgentFS is specialized for AI agent workflows (includes key-value store, tool call logging)</li>
<li>AnyFS is a general-purpose virtual filesystem abstraction</li>
<li>AgentFS has more features; AnyFS has more flexibility</li>
</ul>
<p><strong>Could AnyFS use AgentFS?</strong> Possibly as a backend, but AgentFS’s API is different from <code>VfsBackend</code>. Integration would require an adapter.</p>
<p><strong>Takeaway:</strong> AgentFS validates the SQLite-based portable filesystem approach. We could learn from their audit logging if we add hooks in the future.</p>
<hr>
<h2 id="vfs-crate-comparison"><a class="header" href="#vfs-crate-comparison">VFS Crate Comparison</a></h2>
<p>The <a href="https://docs.rs/vfs/">vfs crate</a> provides virtual filesystem abstractions with:</p>
<ul>
<li><strong>PhysicalFS</strong>: Host filesystem access</li>
<li><strong>MemoryFS</strong>: In-memory storage</li>
<li><strong>AltrootFS</strong>: Rooted filesystem (similar to our VRootFsBackend)</li>
<li><strong>OverlayFS</strong>: Layered filesystem</li>
<li><strong>EmbeddedFS</strong>: Compile resources into binary</li>
</ul>
<p><strong>Similarities with AnyFS:</strong></p>
<ul>
<li>Trait-based abstraction over storage</li>
<li>Memory and physical filesystem backends</li>
</ul>
<p><strong>Differences:</strong></p>
<ul>
<li>VFS doesn’t have SQLite backend</li>
<li>VFS doesn’t have policy/quota layer</li>
<li>AnyFS focuses on isolation and limits</li>
</ul>
<p><strong>Why not use VFS?</strong> VFS is a good library, but AnyFS’s design goals differ:</p>
<ol>
<li>We want SQLite as a first-class backend</li>
<li>We need quota/limit enforcement</li>
<li>We want feature whitelisting (least privilege)</li>
</ol>
<hr>
<h2 id="fuse-mount-support"><a class="header" href="#fuse-mount-support">FUSE Mount Support</a></h2>
<p><strong>Question:</strong> Should AnyFS support mounting as a FUSE filesystem?</p>
<p><strong>What is FUSE?</strong>
<a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE (Filesystem in Userspace)</a> allows implementing filesystems in userspace rather than kernel code. It enables:</p>
<ul>
<li>Mounting any backend as a real filesystem</li>
<li>Using standard Unix tools (ls, cat, etc.) on AnyFS containers</li>
<li>Integration with existing workflows</li>
</ul>
<p><strong>Considerations:</strong></p>
<ul>
<li>FUSE requires platform-specific code (Linux, macOS via macFUSE)</li>
<li>Adds significant complexity</li>
<li>Performance overhead vs direct API access</li>
<li>Security implications of exposing to OS</li>
</ul>
<p><strong>Recommendation:</strong> Not in v1. If there’s demand, we could add a <code>anyfs-fuse</code> crate that mounts a FilesContainer as a FUSE filesystem. This would be a separate, optional layer.</p>
<hr>
<h2 id="type-system-protection-for-cross-container-operations"><a class="header" href="#type-system-protection-for-cross-container-operations">Type-System Protection for Cross-Container Operations</a></h2>
<p><strong>Question:</strong> Should we use the type system to prevent accidentally mixing data between containers?</p>
<p><strong>Example concern:</strong> Reading from Container A and writing to Container B without explicit acknowledgment.</p>
<p><strong>Options:</strong></p>
<ol>
<li><strong>Marker generics</strong>: <code>FilesContainer&lt;B, Marker&gt;</code> where Marker distinguishes instances</li>
<li><strong>Opaque handles</strong>: File content wrapped in typed handles tied to origin container</li>
<li><strong>No protection</strong>: Trust the user to wire things correctly</li>
</ol>
<p><strong>Recommendation:</strong> Defer. The complexity may not be worth it for most use cases. Users who need this can implement their own type wrappers.</p>
<hr>
<h2 id="naming-considerations"><a class="header" href="#naming-considerations">Naming Considerations</a></h2>
<p>Based on review feedback, the following naming concerns were raised:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Current Name</th><th>Concern</th><th>Alternatives Considered</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-traits</code></td><td>“traits” is vague</td><td><code>anyfs-backend</code> (adopted)</td></tr>
<tr><td><code>anyfs-container</code></td><td>Could imply Docker</td><td><code>anyfs-storage</code>, <code>anyfs-fs</code>, <code>fsContainer</code></td></tr>
<tr><td><code>anyfs</code></td><td>Sounds like Hebrew “ani efes” (I am zero)</td><td><code>anyfs</code> retained for simplicity</td></tr>
</tbody>
</table>
</div>
<p><strong>Decision:</strong> Renamed <code>anyfs-traits</code> to <code>anyfs-backend</code>. Other names retained.</p>
<hr>
<h2 id="posix-behavior"><a class="header" href="#posix-behavior">POSIX Behavior</a></h2>
<p><strong>Question:</strong> How POSIX-compatible should AnyFS be?</p>
<p><strong>Answer:</strong> AnyFS is <strong>not</strong> a POSIX emulator. We use <code>std::fs</code>-like naming and semantics for familiarity, but we don’t aim for full POSIX compliance. Specific differences:</p>
<ul>
<li>Lexical path resolution (not runtime symlink following during normalization)</li>
<li>No file descriptors or open file handles in the basic API</li>
<li>Simplified permissions model</li>
<li>No device files, FIFOs, or sockets</li>
</ul>
<hr>
<h2 id="async-support"><a class="header" href="#async-support">Async Support</a></h2>
<p><strong>Question:</strong> Should VfsBackend be async?</p>
<p><strong>Decision:</strong> Sync-first, async-ready (see ADR-010).</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>All built-in backends are naturally synchronous (rusqlite, std::fs, memory)</li>
<li>No runtime dependency (tokio/async-std) required</li>
<li>Rust 1.75+ has native async traits, so adding later is low-cost</li>
</ul>
<p><strong>Async-ready design:</strong></p>
<ul>
<li>Trait requires <code>Send</code> - compatible with async executors</li>
<li>Return types are <code>Result&lt;T, VfsError&gt;</code> - works with async</li>
<li>No hidden blocking state</li>
<li>Methods are stateless per-call</li>
</ul>
<p><strong>Future path:</strong> When needed (e.g., S3/network backends), add parallel <code>AsyncVfsBackend</code> trait:</p>
<ul>
<li>Separate trait, not replacing <code>VfsBackend</code></li>
<li>Blanket impl possible via <code>spawn_blocking</code></li>
<li>No breaking changes to existing sync API</li>
</ul>
<hr>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>These questions inform future development but don’t block v1:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Topic</th><th>v1 Decision</th></tr>
</thead>
<tbody>
<tr><td>Symlinks with VRootFsBackend</td><td>Transparent following on host</td></tr>
<tr><td>Path resolution</td><td>Virtual = lexical; VRootFs = OS</td></tr>
<tr><td>Compression/encryption</td><td>Backend responsibility</td></tr>
<tr><td>Hooks/callbacks</td><td>Defer to v2</td></tr>
<tr><td>FUSE mount</td><td>Possible with current trait (has truncate, fsync, statfs)</td></tr>
<tr><td>Type-system protection</td><td>Defer</td></tr>
<tr><td>POSIX compatibility</td><td>Not a goal</td></tr>
<tr><td><code>truncate</code></td><td>✅ Added to VfsBackend</td></tr>
<tr><td><code>sync</code> / <code>fsync</code></td><td>✅ Added to VfsBackend</td></tr>
<tr><td>Async support</td><td>✅ Sync-first, async-ready (ADR-010)</td></tr>
<tr><td>Layer trait</td><td>✅ Tower-style composition (ADR-011)</td></tr>
<tr><td>Logging</td><td>✅ TracingBackend with tracing ecosystem (ADR-012)</td></tr>
<tr><td>Extension methods</td><td>✅ VfsBackendExt (ADR-013)</td></tr>
<tr><td>Zero-copy bytes</td><td>✅ Optional <code>bytes</code> feature (ADR-014)</td></tr>
<tr><td>Error context</td><td>✅ Contextual VfsError (ADR-015)</td></tr>
<tr><td>BackendStack builder</td><td>✅ Fluent API in anyfs-container</td></tr>
</tbody>
</table>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
