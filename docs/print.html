<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AnyFS Ecosystem Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for AnyFS: pluggable virtual filesystem backends + container layer for Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-48c63341.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-b60f0e7e.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">AnyFS Ecosystem Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/vfs-design-manual" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="anyfs-ecosystem"><a class="header" href="#anyfs-ecosystem">AnyFS Ecosystem</a></h1>
<p><strong>An open standard for pluggable virtual filesystem backends in Rust.</strong></p>
<hr>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>AnyFS is an <strong>open standard</strong> for virtual filesystem backends using a <strong>Tower-style middleware pattern</strong> for composable functionality.</p>
<p>You get:</p>
<ul>
<li>A familiar <code>std::fs</code>-aligned API</li>
<li>Composable middleware (limits, logging, security)</li>
<li>Choice of storage: memory, SQLite, host filesystem, or custom</li>
</ul>
<hr>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FileStorage&lt;M&gt;                         │  ← Ergonomics + type-safe marker
├─────────────────────────────────────────┤
│  Middleware (composable):               │
│    Quota&lt;B&gt;                             │  ← Quotas
│    Restrictions&lt;B&gt;                      │  ← Security
│    Tracing&lt;B&gt;                           │  ← Audit
├─────────────────────────────────────────┤
│  Fs                             │  ← Storage
│  (Memory, SQLite, VRootFs, custom...)   │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>Each layer has one job.</strong> Compose only what you need.</p>
<hr>
<h2 id="two-crate-structure"><a class="header" href="#two-crate-structure">Two-Crate Structure</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract: <code>Fs</code> trait + types</td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware + ergonomic <code>FileStorage&lt;M&gt;</code> wrapper</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, FileStorage};

// Layer-based composition
let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_hard_links()
        .deny_permissions()
        .build());

let fs = FileStorage::new(backend);

fs.create_dir_all("/data")?;
fs.write("/data/file.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="how-to-use-this-manual"><a class="header" href="#how-to-use-this-manual">How to Use This Manual</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Section</th><th>Audience</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Overview</td><td>Stakeholders</td><td>One-page understanding</td></tr>
<tr><td>Getting Started</td><td>Developers</td><td>Practical examples</td></tr>
<tr><td>Design &amp; Architecture</td><td>Contributors</td><td>Detailed design</td></tr>
<tr><td>Traits &amp; APIs</td><td>Backend authors</td><td>Contract and types</td></tr>
<tr><td>Implementation</td><td>Implementers</td><td>Plan + backend guide</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Design</td><td>Complete</td></tr>
<tr><td>Implementation</td><td>Not started</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="authoritative-documents"><a class="header" href="#authoritative-documents">Authoritative Documents</a></h2>
<ol>
<li><code>AGENTS.md</code> (for AI assistants)</li>
<li><code>book/src/architecture/design-overview.md</code></li>
<li><code>book/src/architecture/adrs.md</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---executive-summary"><a class="header" href="#anyfs---executive-summary">AnyFS - Executive Summary</a></h1>
<p>One-page overview for stakeholders and decision-makers.</p>
<hr>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>AnyFS is an <strong>open standard</strong> for pluggable virtual filesystem backends in Rust, using a <strong>Tower-style middleware pattern</strong> for composable functionality.</p>
<p>You get:</p>
<ul>
<li>A familiar <code>std::fs</code>-aligned API</li>
<li>Composable middleware for limits, logging, and security</li>
<li>Choice of storage: memory, SQLite, host filesystem, or custom</li>
</ul>
<hr>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FileStorage&lt;B&gt;                      │  ← Ergonomics (std::fs API)
├─────────────────────────────────────────┤
│  Middleware (composable):               │
│    Quota&lt;B&gt;                    │  ← Quotas
│    Restrictions&lt;B&gt;               │  ← Security
│    Tracing&lt;B&gt;                    │  ← Audit
├─────────────────────────────────────────┤
│  Fs                             │  ← Storage
└─────────────────────────────────────────┘
</code></pre>
<hr>
<h2 id="why-does-it-matter"><a class="header" href="#why-does-it-matter">Why does it matter?</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Problem</th><th>How AnyFS helps</th></tr>
</thead>
<tbody>
<tr><td>Multi-tenant isolation</td><td>Separate backend instances per tenant</td></tr>
<tr><td>Portability</td><td>SQLite backend: tenant data = single <code>.db</code> file</td></tr>
<tr><td>Security</td><td>Restrictions disables dangerous features by default</td></tr>
<tr><td>Resource control</td><td>Quota enforces quotas</td></tr>
<tr><td>Audit compliance</td><td>Tracing records all operations</td></tr>
<tr><td>Custom storage</td><td>Implement Fs for any medium</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="key-design-points"><a class="header" href="#key-design-points">Key design points</a></h2>
<ul>
<li>
<p><strong>Two-crate structure</strong></p>
<ul>
<li><code>anyfs-backend</code>: trait contract</li>
<li><code>anyfs</code>: backends + middleware + ergonomic wrapper</li>
</ul>
</li>
<li>
<p><strong>Middleware pattern</strong> (like Axum/Tower)</p>
<ul>
<li>Each middleware has one job</li>
<li>Compose only what you need</li>
<li>Complete separation of concerns</li>
</ul>
</li>
<li>
<p><strong>std::fs alignment</strong></p>
<ul>
<li>Familiar method names</li>
<li><code>impl AsRef&lt;Path&gt;</code> everywhere</li>
</ul>
</li>
</ul>
<hr>
<h2 id="quick-example-1"><a class="header" href="#quick-example-1">Quick example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, FileStorage};

// Layer-based composition
let backend = SqliteBackend::open("tenant.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_hard_links()
        .deny_permissions()
        .build());

let fs = FileStorage::new(backend);

fs.create_dir_all("/documents")?;
fs.write("/documents/hello.txt", b"Hello!")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Design</td><td>Complete</td></tr>
<tr><td>Implementation</td><td>Not started</td></tr>
</tbody>
</table>
</div>
<hr>
<p>For details, see <code>book/src/architecture/design-overview.md</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---project-structure"><a class="header" href="#anyfs---project-structure">AnyFS - Project Structure</a></h1>
<p><strong>Status:</strong> Current
<strong>Last updated:</strong> 2025-12-24</p>
<hr>
<h2 id="repository-layout"><a class="header" href="#repository-layout">Repository Layout</a></h2>
<pre><code>anyfs-backend/              # Crate 1: trait + types
  Cargo.toml
  src/
    lib.rs
    backend.rs              # Fs traits (FsRead, FsWrite, FsDir, etc.)
    types.rs                # Metadata, DirEntry, Permissions, StatFs
    error.rs                # FsError

anyfs/                      # Crate 2: backends + middleware + ergonomics
  Cargo.toml
  src/
    lib.rs
    backends/
      memory.rs             # MemoryBackend [feature: memory, default]
      sqlite.rs             # SqliteBackend [feature: sqlite]
      sqlite_cipher.rs      # SqliteCipherBackend [feature: sqlite-cipher]
      stdfs.rs              # StdFsBackend [feature: stdfs]
      vrootfs.rs            # VRootFsBackend [feature: vrootfs]
    middleware/
      quota.rs              # Quota&lt;B&gt;
      tracing.rs            # Tracing&lt;B&gt;
      restrictions.rs       # Restrictions&lt;B&gt;
    container.rs            # FileStorage&lt;M&gt;
    stack.rs                # BackendStack builder
</code></pre>
<hr>
<h2 id="dependency-model"><a class="header" href="#dependency-model">Dependency Model</a></h2>
<pre><code>anyfs-backend (trait + types)
     ^
     |-- anyfs (backends + middleware + ergonomics)
           ^-- vrootfs feature uses strict-path
</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>Custom backends depend only on <code>anyfs-backend</code></li>
<li><code>anyfs</code> provides built-in backends, middleware, and the ergonomic <code>FileStorage&lt;M&gt;</code> wrapper</li>
</ul>
<hr>
<h2 id="middleware-pattern"><a class="header" href="#middleware-pattern">Middleware Pattern</a></h2>
<pre><code>FileStorage&lt;B&gt;
    wraps -&gt; Tracing&lt;B&gt;
        wraps -&gt; Restrictions&lt;B&gt;
            wraps -&gt; Quota&lt;B&gt;
                wraps -&gt; SqliteBackend (or any Fs)
</code></pre>
<p>Each layer implements <code>Fs</code>, enabling composition.</p>
<hr>
<h2 id="cargo-features"><a class="header" href="#cargo-features">Cargo Features</a></h2>
<p>Features in <code>anyfs</code> select which backends to include:</p>
<ul>
<li><code>memory</code> — In-memory storage (default)</li>
<li><code>sqlite</code> — SQLite-backed persistent storage</li>
<li><code>sqlite-cipher</code> — Encrypted SQLite via SQLCipher (AES-256, mutually exclusive with <code>sqlite</code>)</li>
<li><code>stdfs</code> — Direct <code>std::fs</code> delegation (no containment)</li>
<li><code>vrootfs</code> — Host filesystem backend with path containment (uses <code>strict-path</code>)</li>
</ul>
<p>Middleware is always available (no feature flags).</p>
<hr>
<h2 id="where-to-start"><a class="header" href="#where-to-start">Where To Start</a></h2>
<ul>
<li>Application usage: <code>book/src/getting-started/guide.md</code></li>
<li>Trait details: <code>book/src/traits/layered-traits.md</code></li>
<li>Middleware: <code>book/src/architecture/design-overview.md</code></li>
<li>Decisions: <code>book/src/architecture/adrs.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--getting-started-guide"><a class="header" href="#anyfs--getting-started-guide">AnyFS — Getting Started Guide</a></h1>
<p><strong>A practical introduction with examples</strong></p>
<hr>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
anyfs = "0.1"
</code></pre>
<p>For additional backends:</p>
<pre><code class="language-toml">[dependencies]
anyfs = { version = "0.1", features = ["sqlite", "stdfs", "vrootfs"] }
</code></pre>
<p>Available features:</p>
<ul>
<li><code>memory</code> — In-memory storage (default)</li>
<li><code>sqlite</code> — SQLite-backed persistent storage</li>
<li><code>stdfs</code> — Direct <code>std::fs</code> delegation (no containment)</li>
<li><code>vrootfs</code> — Host filesystem backend with path containment</li>
</ul>
<hr>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{MemoryBackend, FileStorage};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/hello.txt", b"Hello, AnyFS!")?;
    let content = fs.read("/hello.txt")?;
    println!("{}", String::from_utf8_lossy(&amp;content));

    Ok(())
}</code></pre>
<h3 id="with-quotas"><a class="header" href="#with-quotas">With Quotas</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{SqliteBackend, Quota, FileStorage};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let backend = QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)  // 100 MB
        .max_file_size(10 * 1024 * 1024)    // 10 MB per file
        .build()
        .layer(SqliteBackend::open_or_create("data.db")?);

    let fs = FileStorage::new(backend);

    fs.create_dir_all("/documents")?;
    fs.write("/documents/notes.txt", b"Meeting notes")?;

    Ok(())
}</code></pre>
<h3 id="with-restrictions"><a class="header" href="#with-restrictions">With Restrictions</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{MemoryBackend, Restrictions, FileStorage};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Block specific operations for untrusted code
    let backend = RestrictionsLayer::builder()
        .deny_hard_links()    // Block hard_link() calls
        .deny_permissions()   // Block set_permissions() calls
        .build()
        .layer(MemoryBackend::new());

    let fs = FileStorage::new(backend);

    // Symlinks work (not blocked)
    fs.write("/original.txt", b"content")?;
    fs.symlink("/original.txt", "/shortcut")?;

    Ok(())
}</code></pre>
<h3 id="full-stack-layer-based"><a class="header" href="#full-stack-layer-based">Full Stack (Layer-based)</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, TracingLayer, FileStorage};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let backend = SqliteBackend::open_or_create("data.db")?
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .max_file_size(10 * 1024 * 1024)
            .build())
        .layer(RestrictionsLayer::builder()
            .deny_hard_links()
            .deny_permissions()
            .build())
        .layer(TracingLayer::new());

    let fs = FileStorage::new(backend);

    fs.create_dir_all("/data")?;
    fs.write("/data/file.txt", b"hello")?;

    Ok(())
}</code></pre>
<hr>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<h3 id="creating-directories"><a class="header" href="#creating-directories">Creating Directories</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.create_dir("/documents")?;              // Single level
fs.create_dir_all("/documents/2024/q1")?;  // Recursive
<span class="boring">}</span></code></pre>
<h3 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and Writing Files</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.write("/data.txt", b"line 1\n")?;       // Create or overwrite
fs.append("/data.txt", b"line 2\n")?;      // Append

let content = fs.read("/data.txt")?;                    // Read all
let partial = fs.read_range("/data.txt", 0, 6)?;        // Read range
let text = fs.read_to_string("/data.txt")?;             // Read as String
<span class="boring">}</span></code></pre>
<h3 id="listing-directories"><a class="header" href="#listing-directories">Listing Directories</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in fs.read_dir("/documents")? {
    println!("{}: {:?}", entry.name, entry.file_type);
}
<span class="boring">}</span></code></pre>
<h3 id="checking-existence-and-metadata"><a class="header" href="#checking-existence-and-metadata">Checking Existence and Metadata</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if fs.exists("/file.txt")? {
    let meta = fs.metadata("/file.txt")?;
    println!("Size: {} bytes", meta.size);
}
<span class="boring">}</span></code></pre>
<h3 id="copying-and-moving"><a class="header" href="#copying-and-moving">Copying and Moving</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.copy("/original.txt", "/copy.txt")?;
fs.rename("/original.txt", "/renamed.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="deleting"><a class="header" href="#deleting">Deleting</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.remove_file("/old-file.txt")?;
fs.remove_dir("/empty-folder")?;
fs.remove_dir_all("/old-folder")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware"><a class="header" href="#middleware">Middleware</a></h2>
<h3 id="quota--resource-limits"><a class="header" href="#quota--resource-limits">Quota — Resource Limits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Quota};

let backend = QuotaLayer::builder()
    .max_total_size(500 * 1024 * 1024)   // 500 MB total
    .max_file_size(50 * 1024 * 1024)     // 50 MB per file
    .max_node_count(100_000)             // 100K files/dirs
    .max_dir_entries(5_000)              // 5K per directory
    .max_path_depth(32)                  // Max nesting
    .build()
    .layer(MemoryBackend::new());

// Check usage
let usage = backend.usage();
println!("Using {} bytes", usage.total_size);

// Check remaining
let remaining = backend.remaining();
if !remaining.can_write {
    println!("Storage full!");
}
<span class="boring">}</span></code></pre>
<h3 id="restrictions--block-operations"><a class="header" href="#restrictions--block-operations">Restrictions — Block Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Restrictions};

// By default, all operations work. Use deny_*() to block specific ones.
let backend = RestrictionsLayer::builder()
    .deny_symlinks()      // Block symlink() calls
    .deny_hard_links()    // Block hard_link() calls
    .deny_permissions()   // Block set_permissions() calls
    .build()
    .layer(MemoryBackend::new());

// Blocked operations return FsError::FeatureNotEnabled
<span class="boring">}</span></code></pre>
<h3 id="tracing--instrumentation"><a class="header" href="#tracing--instrumentation">Tracing — Instrumentation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, TracingLayer};

// TracingLayer uses the global tracing subscriber by default
let backend = MemoryBackend::new().layer(TracingLayer::new());

// Or configure with custom settings
let backend = MemoryBackend::new()
    .layer(TracingLayer::new()
        .with_target("myapp::fs")
        .with_level(tracing::Level::DEBUG));
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsError;

match fs.write("/file.txt", &amp;large_data) {
    Ok(()) =&gt; println!("Written"),

    Err(FsError::NotFound { path, .. }) =&gt; println!("Not found: {}", path.display()),
    Err(FsError::AlreadyExists { path, .. }) =&gt; println!("Exists: {}", path.display()),
    Err(FsError::QuotaExceeded { .. }) =&gt; println!("Quota exceeded"),
    Err(FsError::FeatureNotEnabled { feature }) =&gt; println!("Feature disabled: {}", feature),

    Err(e) =&gt; println!("Error: {}", e),
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FileStorage};

#[test]
fn test_write_and_read() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/test.txt", b"test data").unwrap();
    let content = fs.read("/test.txt").unwrap();

    assert_eq!(content, b"test data");
}
<span class="boring">}</span></code></pre>
<p>With limits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Quota, FileStorage};

#[test]
fn test_quota_exceeded() {
    let backend = QuotaLayer::builder()
        .max_total_size(1024)  // 1 KB
        .build()
        .layer(MemoryBackend::new());
    let fs = FileStorage::new(backend);

    let big_data = vec![0u8; 2048];  // 2 KB
    let result = fs.write("/big.bin", &amp;big_data);

    assert!(result.is_err());
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-use-appropriate-backend"><a class="header" href="#1-use-appropriate-backend">1. Use Appropriate Backend</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Backend</th></tr>
</thead>
<tbody>
<tr><td>Testing</td><td><code>MemoryBackend</code></td></tr>
<tr><td>Production (portable)</td><td><code>SqliteBackend</code></td></tr>
<tr><td>Host filesystem (with containment)</td><td><code>VRootFsBackend</code></td></tr>
<tr><td>Host filesystem (direct access)</td><td><code>StdFsBackend</code></td></tr>
</tbody>
</table>
</div>
<h3 id="2-compose-middleware-for-your-needs"><a class="header" href="#2-compose-middleware-for-your-needs">2. Compose Middleware for Your Needs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Minimal: just storage
let fs = FileStorage::new(MemoryBackend::new());

// With limits (layer-based)
let fs = FileStorage::new(
    MemoryBackend::new()
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .build())
);

// Sandboxed (layer-based)
let fs = FileStorage::new(
    SqliteBackend::open("data.db")?
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .build())
        .layer(RestrictionsLayer::builder()
            .deny_hard_links()
            .deny_permissions()
            .build())
);
<span class="boring">}</span></code></pre>
<h3 id="3-handle-errors-gracefully"><a class="header" href="#3-handle-errors-gracefully">3. Handle Errors Gracefully</a></h3>
<p>Always check for quota exceeded, feature not enabled, and other errors.</p>
<hr>
<h2 id="advanced-use-cases-future"><a class="header" href="#advanced-use-cases-future">Advanced Use Cases (Future)</a></h2>
<p>These use cases require <code>anyfs-mount</code> (future crate).</p>
<h3 id="database-backed-drive-with-live-monitoring"><a class="header" href="#database-backed-drive-with-live-monitoring">Database-Backed Drive with Live Monitoring</a></h3>
<p>Mount a database-backed filesystem and query it directly for real-time analytics:</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  Database (SQLite, PostgreSQL, etc.)                        │
├─────────────────────────────────────────────────────────────┤
│                         │                                   │
│    anyfs-mount          │         Stats Dashboard           │
│    (write + read)       │         (direct DB queries)       │
│         │               │               │                   │
│         ▼               │               ▼                   │
│  /mnt/workspace         │    SELECT SUM(size) FROM nodes    │
│  $ cp file.txt ./       │    SELECT COUNT(*) FROM nodes     │
│  $ mkdir projects/      │    SELECT * FROM operations_log   │
│                         │               │                   │
│                         │               ▼                   │
│                         │        ┌──────────────┐           │
│                         │        │ Live Graphs  │           │
│                         │        │ - Disk usage │           │
│                         │        │ - File count │           │
│                         │        │ - Recent ops │           │
│                         │        └──────────────┘           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>SQLite Example:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, TracingLayer};
use anyfs_fuse::FuseMount;

// Mount the drive
let backend = SqliteBackend::open("tenant.db")?
    .layer(TracingLayer::new())  // Logs operations to tracing subscriber
    .layer(QuotaLayer::builder()
        .max_total_size(1_000_000_000)
        .build());

let mount = FuseMount::mount(backend, "/mnt/workspace")?;
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Meanwhile, in a monitoring dashboard...
use rusqlite::{Connection, OpenFlags};

let conn = Connection::open_with_flags(
    "tenant.db",
    OpenFlags::SQLITE_OPEN_READ_ONLY,  // Safe concurrent reads
)?;

loop {
    let (file_count, total_bytes): (i64, i64) = conn.query_row(
        "SELECT COUNT(*), COALESCE(SUM(size), 0) FROM nodes WHERE type = 'file'",
        [],
        |row| Ok((row.get(0)?, row.get(1)?)),
    )?;

    let recent_ops: Vec&lt;String&gt; = conn
        .prepare("SELECT operation, path, timestamp FROM audit_log ORDER BY timestamp DESC LIMIT 10")?
        .query_map([], |row| Ok(format!("{}: {}", row.get::&lt;_, String&gt;(0)?, row.get::&lt;_, String&gt;(1)?)))?
        .collect::&lt;Result&lt;_, _&gt;&gt;()?;

    render_dashboard(file_count, total_bytes, &amp;recent_ops);
    std::thread::sleep(Duration::from_secs(1));
}
<span class="boring">}</span></code></pre>
<p><strong>Works with any database backend:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Direct Query Method</th></tr>
</thead>
<tbody>
<tr><td><code>SqliteBackend</code></td><td><code>rusqlite</code> with <code>SQLITE_OPEN_READ_ONLY</code></td></tr>
<tr><td><code>PostgresBackend</code> (future)</td><td>Standard <code>postgres</code> crate connection</td></tr>
<tr><td><code>MySqlBackend</code> (future)</td><td>Standard <code>mysql</code> crate connection</td></tr>
</tbody>
</table>
</div>
<p><strong>What you can visualize:</strong></p>
<ul>
<li>Real-time storage usage (gauges, bar charts)</li>
<li>File count over time (line graphs)</li>
<li>Operations log (live feed)</li>
<li>Most accessed files (heatmaps)</li>
<li>Directory tree maps (size visualization)</li>
<li>Per-tenant usage (multi-tenant dashboards)</li>
</ul>
<p>This pattern is powerful because the database is the source of truth — you get filesystem semantics via FUSE and SQL analytics via direct queries, from the same data.</p>
<h3 id="ram-drive"><a class="header" href="#ram-drive">RAM Drive</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer};
use anyfs_fuse::FuseMount;

// 4GB RAM drive
let mount = FuseMount::mount(
    MemoryBackend::new()
        .layer(QuotaLayer::builder()
            .max_total_size(4 * 1024 * 1024 * 1024)
            .build()),
    "/mnt/ramdisk"
)?;

// Use for fast compilation, temp files, etc.
// $ TMPDIR=/mnt/ramdisk cargo build
<span class="boring">}</span></code></pre>
<h3 id="sandboxed-ai-agent-workspace"><a class="header" href="#sandboxed-ai-agent-workspace">Sandboxed AI Agent Workspace</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, PathFilterLayer, RestrictionsLayer, TracingLayer};
use anyfs_fuse::FuseMount;

let mount = FuseMount::mount(
    MemoryBackend::new()
        .layer(PathFilterLayer::builder()
            .allow("/workspace/**")
            .deny("**/..*")           // No hidden files
            .deny("**/.*")            // No dotfiles
            .build())
        .layer(RestrictionsLayer::builder()
            .deny_symlinks()          // Prevent symlink attacks
            .deny_hard_links()
            .build())
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .max_file_size(10 * 1024 * 1024)
            .build())
        .layer(TracingLayer::new()),  // Full audit trail
    "/mnt/agent"
)?;

// Agent uses standard filesystem APIs
// All operations are sandboxed, quota-limited, and logged
<span class="boring">}</span></code></pre>
<hr>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#anyfs--api-quick-reference">API Quick Reference</a></li>
<li><a href="#anyfs---design-overview">Design Overview</a></li>
<li><a href="#backend-implementers-guide">Backend Implementer’s Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--api-quick-reference"><a class="header" href="#anyfs--api-quick-reference">AnyFS — API Quick Reference</a></h1>
<p><strong>Condensed reference for developers</strong></p>
<hr>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
anyfs = "0.1"
</code></pre>
<p>With backends and optional features:</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["sqlite", "vrootfs", "bytes"] }
</code></pre>
<hr>
<h2 id="creating-a-backend-stack"><a class="header" href="#creating-a-backend-stack">Creating a Backend Stack</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, QuotaLayer, RestrictionsLayer, TracingLayer, FileStorage};

// Simple
let fs = FileStorage::new(MemoryBackend::new());

// With limits
let fs = FileStorage::new(
    SqliteBackend::open("data.db")?
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .max_file_size(10 * 1024 * 1024)
            .build())
);

// Full stack (fluent composition)
let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_permissions()
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(backend);

// BackendStack builder (fluent API)
use anyfs::BackendStack;

let fs = BackendStack::new(SqliteBackend::open("data.db")?)
    .limited(|l| l.max_total_size(100 * 1024 * 1024))
    .restricted(|g| g.deny_hard_links().deny_permissions())
    .traced()
    .into_container();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="quota-methods"><a class="header" href="#quota-methods">Quota Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - at least one limit must be set)
QuotaLayer::builder()
    .max_total_size(bytes)      // Total storage limit
    .max_file_size(bytes)       // Per-file limit
    .max_node_count(count)      // Max files/dirs
    .max_dir_entries(count)     // Max entries per dir
    .max_path_depth(depth)      // Max nesting
    .build()
    .layer(backend)

// Query
backend.usage()        // -&gt; Usage { total_size, file_count, ... }
backend.limits()       // -&gt; Limits { max_total_size, ... }
backend.remaining()    // -&gt; Remaining { bytes, can_write, ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="restrictions-methods"><a class="header" href="#restrictions-methods">Restrictions Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - at least one restriction must be set)
// By default, all operations work. Use deny_*() to block specific ones.
RestrictionsLayer::builder()
    .deny_symlinks()       // Block symlink() calls
    .deny_hard_links()     // Block hard_link() calls
    .deny_permissions()    // Block set_permissions() calls
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="tracinglayer-methods"><a class="header" href="#tracinglayer-methods">TracingLayer Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TracingLayer configuration (applied via .layer())
TracingLayer::new()
    .with_target("anyfs")              // tracing target
    .with_level(tracing::Level::DEBUG)

// Usage
let backend = inner.layer(TracingLayer::new().with_target("anyfs"));
<span class="boring">}</span></code></pre>
<hr>
<h2 id="pathfilter-methods"><a class="header" href="#pathfilter-methods">PathFilter Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - at least one rule must be set)
PathFilterLayer::builder()
    .allow("/workspace/**")    // Allow glob pattern
    .deny("**/.env")           // Deny glob pattern
    .deny("**/secrets/**")
    .build()
    .layer(backend)

// Rules evaluated in order; first match wins
// No match = denied (deny by default)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="readonly-methods"><a class="header" href="#readonly-methods">ReadOnly Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ReadOnly::new(backend)

// All read operations pass through
// All write operations return FsError::ReadOnly
<span class="boring">}</span></code></pre>
<hr>
<h2 id="ratelimit-methods"><a class="header" href="#ratelimit-methods">RateLimit Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - must set ops and window)
RateLimitLayer::builder()
    .max_ops(1000)           // Operation limit
    .per_second()            // Window: 1 second
    // or
    .per_minute()            // Window: 60 seconds
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="dryrun-methods"><a class="header" href="#dryrun-methods">DryRun Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut dry_run = DryRun::new(backend);

// Read operations execute normally
// Write operations are logged but not executed
dry_run.write("/file.txt", b"data")?;  // Logged, returns Ok

// Inspect logged operations
let ops = dry_run.operations();        // -&gt; &amp;[Operation]
dry_run.clear();                       // Clear the log
<span class="boring">}</span></code></pre>
<hr>
<h2 id="cache-methods"><a class="header" href="#cache-methods">Cache Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - at least max_entries must be set)
CacheLayer::builder()
    .max_entries(1000)                          // LRU cache size
    .max_entry_size(1024 * 1024)               // 1MB max per entry
    .ttl(std::time::Duration::from_secs(60))   // Expiration
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="overlay-methods"><a class="header" href="#overlay-methods">Overlay Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, MemoryBackend, Overlay};

let base = SqliteBackend::open("base.db")?;  // Read-only base
let upper = MemoryBackend::new();             // Writable upper

let overlay = Overlay::new(base, upper);

// Read: check upper first, fall back to base
// Write: always to upper layer
// Delete: whiteout marker in upper
<span class="boring">}</span></code></pre>
<hr>
<h2 id="fsext-methods"><a class="header" href="#fsext-methods">FsExt Methods</a></h2>
<p>Extension methods available on all backends:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsExt;

// JSON support
let config: Config = fs.read_json("/config.json")?;
fs.write_json("/config.json", &amp;config)?;

// Type checks
if fs.is_file("/path")? { ... }
if fs.is_dir("/path")? { ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check existence
fs.exists("/path")?                     // -&gt; bool

// Metadata
let meta = fs.metadata("/path")?;
meta.inode                               // unique identifier
meta.nlink                               // hard link count
meta.file_type                           // File | Directory | Symlink
meta.size                                // file size in bytes
meta.permissions                         // Permissions { mode: u32 }
meta.created                             // Option&lt;SystemTime&gt;
meta.modified                            // Option&lt;SystemTime&gt;
meta.accessed                            // Option&lt;SystemTime&gt;

// Read
let bytes = fs.read("/path")?;           // -&gt; Vec&lt;u8&gt;
let text = fs.read_to_string("/path")?;  // -&gt; String
let chunk = fs.read_range("/path", 0, 1024)?;

// List directory
let entries = fs.read_dir("/path")?;     // -&gt; Vec&lt;DirEntry&gt;
for entry in &amp;entries {
    entry.name                           // OsString
    entry.inode                          // u64 (avoids extra stat)
    entry.file_type                      // File | Directory | Symlink
}

// Write
fs.write("/path", b"content")?;          // Create or overwrite
fs.append("/path", b"more")?;            // Append

// Directories
fs.create_dir("/path")?;
fs.create_dir_all("/path")?;

// Delete
fs.remove_file("/path")?;
fs.remove_dir("/path")?;                 // Empty only
fs.remove_dir_all("/path")?;             // Recursive

// Move/Copy
fs.rename("/from", "/to")?;
fs.copy("/from", "/to")?;

// Links
fs.symlink("/target", "/link")?;
fs.hard_link("/original", "/link")?;
fs.read_link("/link")?;                  // -&gt; PathBuf
fs.symlink_metadata("/link")?;           // Metadata of link itself, not target

// Symlink following (virtual backends only)
backend.set_follow_symlinks(false);      // Don't follow symlinks during resolution
backend.set_follow_symlinks(true);       // Follow symlinks (default)

// Permissions (requires Restrictions)
fs.set_permissions("/path", perms)?;

// File size
fs.truncate("/path", 1024)?;             // Resize to 1024 bytes

// Durability
fs.sync()?;                              // Flush all writes
fs.fsync("/path")?;                      // Flush writes for one file
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-canonicalization"><a class="header" href="#path-canonicalization">Path Canonicalization</a></h2>
<p><code>FileStorage</code> provides path canonicalization that works on the virtual filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Strict canonicalization - path must exist
let canonical = fs.canonicalize("/some/../path/./file.txt")?;
// Returns fully resolved absolute path, follows symlinks

// Soft canonicalization - handles non-existent paths
let resolved = fs.soft_canonicalize("/existing/dir/new_file.txt")?;
// Resolves existing components, appends non-existent remainder lexically

// Anchored canonicalization - sandboxed resolution
let safe = fs.anchored_canonicalize("/workspace/../etc/passwd", "/workspace")?;
// Clamps result within anchor directory (returns error if escape attempted)
<span class="boring">}</span></code></pre>
<p><strong>Standalone utility (no backend needed):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::normalize;

// Lexical path cleanup only
let clean = normalize("//foo///bar//");  // -&gt; "/foo/bar"
// Does NOT resolve . or .. (those require filesystem context)
// Does NOT follow symlinks
<span class="boring">}</span></code></pre>
<p><strong>Comparison:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Path Must Exist?</th><th>Follows Symlinks?</th><th>Resolves <code>..</code>?</th></tr>
</thead>
<tbody>
<tr><td><code>canonicalize</code></td><td>Yes (all components)</td><td>Yes</td><td>Yes (symlink-aware)</td></tr>
<tr><td><code>soft_canonicalize</code></td><td>No (appends non-existent)</td><td>Yes (for existing)</td><td>Yes (symlink-aware)</td></tr>
<tr><td><code>anchored_canonicalize</code></td><td>No</td><td>Yes (for existing)</td><td>Yes (clamped to anchor)</td></tr>
<tr><td><code>normalize</code></td><td>N/A (lexical only)</td><td>No</td><td>No</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="inode-operations-fsinode-trait"><a class="header" href="#inode-operations-fsinode-trait">Inode Operations (<code>FsInode</code> trait)</a></h2>
<p>Backends implementing <code>FsInode</code> track inodes internally for hardlink support and FUSE mounting:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert between paths and inodes
let inode: u64 = backend.path_to_inode("/some/path")?;
let path: PathBuf = backend.inode_to_path(inode)?;

// Lookup child by name within a directory (FUSE-style)
let root_inode = backend.path_to_inode("/")?;
let child_inode = backend.lookup(root_inode, "filename.txt")?;

// Get metadata by inode (avoids path resolution)
let meta = backend.metadata_by_inode(inode)?;

// Hardlinks share the same inode
backend.hard_link("/original", "/link")?;
let ino1 = backend.path_to_inode("/original")?;
let ino2 = backend.path_to_inode("/link")?;
assert_eq!(ino1, ino2);  // Same inode!
<span class="boring">}</span></code></pre>
<p><strong>Inode sources by backend:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Inode Source</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Internal node IDs (incrementing counter)</td></tr>
<tr><td><code>SqliteBackend</code></td><td>SQLite row IDs (<code>INTEGER PRIMARY KEY</code>)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>OS inode numbers (<code>Metadata::ino()</code>)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsError;

match result {
    // Path errors
    Err(FsError::NotFound { path, operation }) =&gt; {
        // e.g., path="/file.txt", operation="read"
    }
    Err(FsError::AlreadyExists { path, operation }) =&gt; ...
    Err(FsError::NotADirectory { path }) =&gt; ...
    Err(FsError::NotAFile { path }) =&gt; ...
    Err(FsError::DirectoryNotEmpty { path }) =&gt; ...

    // Quota middleware errors
    Err(FsError::QuotaExceeded { limit, requested, usage }) =&gt; ...
    Err(FsError::FileSizeExceeded { path, size, limit }) =&gt; ...

    // Restrictions middleware errors
    Err(FsError::FeatureNotEnabled { feature, operation }) =&gt; ...

    // PathFilter middleware errors
    Err(FsError::AccessDenied { path, reason }) =&gt; ...

    // ReadOnly middleware errors
    Err(FsError::ReadOnly { operation }) =&gt; ...

    // RateLimit middleware errors
    Err(FsError::RateLimitExceeded { limit, window_secs }) =&gt; ...

    // FsExt errors
    Err(FsError::Serialization(msg)) =&gt; ...
    Err(FsError::Deserialization(msg)) =&gt; ...

    // Optional feature not supported
    Err(FsError::NotSupported { operation }) =&gt; ...

    Err(e) =&gt; ...
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="built-in-backends"><a class="header" href="#built-in-backends">Built-in Backends</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td><code>memory</code> (default)</td><td>In-memory</td></tr>
<tr><td><code>SqliteBackend</code></td><td><code>sqlite</code></td><td>Persistent single-file database</td></tr>
<tr><td><code>SqliteCipherBackend</code></td><td><code>sqlite-cipher</code></td><td>Encrypted SQLite (AES-256 via SQLCipher)</td></tr>
<tr><td><code>StdFsBackend</code></td><td><code>stdfs</code></td><td>Direct <code>std::fs</code> (no containment)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td><code>vrootfs</code></td><td>Host filesystem (with containment)</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> <code>sqlite</code> and <code>sqlite-cipher</code> are mutually exclusive features.</p>
<hr>
<h2 id="sqlitecipherbackend-methods"><a class="header" href="#sqlitecipherbackend-methods">SqliteCipherBackend Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteCipherBackend;

// Open with password (key derived via PBKDF2)
let backend = SqliteCipherBackend::open("encrypted.db", "password")?;

// Open with raw 256-bit key
let backend = SqliteCipherBackend::open_with_key("encrypted.db", &amp;key)?;

// Create new encrypted database
let backend = SqliteCipherBackend::create("new.db", "password")?;

// Change password on open database
backend.change_password("new-password")?;
<span class="boring">}</span></code></pre>
<p>Without the correct password, the <code>.db</code> file appears as random bytes.</p>
<hr>
<h2 id="middleware-1"><a class="header" href="#middleware-1">Middleware</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Quota&lt;B&gt;</code></td><td>Quota enforcement</td></tr>
<tr><td><code>Restrictions&lt;B&gt;</code></td><td>Least privilege</td></tr>
<tr><td><code>PathFilter&lt;B&gt;</code></td><td>Path-based access control</td></tr>
<tr><td><code>ReadOnly&lt;B&gt;</code></td><td>Prevent write operations</td></tr>
<tr><td><code>RateLimit&lt;B&gt;</code></td><td>Operation throttling</td></tr>
<tr><td><code>Tracing&lt;B&gt;</code></td><td>Instrumentation (tracing ecosystem)</td></tr>
<tr><td><code>DryRun&lt;B&gt;</code></td><td>Log without executing</td></tr>
<tr><td><code>Cache&lt;B&gt;</code></td><td>LRU read caching</td></tr>
<tr><td><code>Overlay&lt;B1,B2&gt;</code></td><td>Union filesystem</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="layers"><a class="header" href="#layers">Layers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Creates</th></tr>
</thead>
<tbody>
<tr><td><code>QuotaLayer</code></td><td><code>Quota&lt;B&gt;</code></td></tr>
<tr><td><code>RestrictionsLayer</code></td><td><code>Restrictions&lt;B&gt;</code></td></tr>
<tr><td><code>PathFilterLayer</code></td><td><code>PathFilter&lt;B&gt;</code></td></tr>
<tr><td><code>ReadOnlyLayer</code></td><td><code>ReadOnly&lt;B&gt;</code></td></tr>
<tr><td><code>RateLimitLayer</code></td><td><code>RateLimit&lt;B&gt;</code></td></tr>
<tr><td><code>TracingLayer</code></td><td><code>Tracing&lt;B&gt;</code></td></tr>
<tr><td><code>DryRunLayer</code></td><td><code>DryRun&lt;B&gt;</code></td></tr>
<tr><td><code>CacheLayer</code></td><td><code>Cache&lt;B&gt;</code></td></tr>
<tr><td><code>OverlayLayer</code></td><td><code>Overlay&lt;B1,B2&gt;</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="type-reference"><a class="header" href="#type-reference">Type Reference</a></h2>
<h3 id="from-anyfs-backend"><a class="header" href="#from-anyfs-backend">From <code>anyfs-backend</code></a></h3>
<p><strong>Core Traits (Layer 1):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FsRead</code></td><td>Read operations: <code>read</code>, <code>exists</code>, <code>metadata</code>, <code>open_read</code></td></tr>
<tr><td><code>FsWrite</code></td><td>Write operations: <code>write</code>, <code>append</code>, <code>remove_file</code>, <code>rename</code>, <code>copy</code>, <code>truncate</code></td></tr>
<tr><td><code>FsDir</code></td><td>Directory operations: <code>read_dir</code>, <code>create_dir*</code>, <code>remove_dir*</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Extended Traits (Layer 2):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FsLink</code></td><td>Link operations: <code>symlink</code>, <code>hard_link</code>, <code>read_link</code></td></tr>
<tr><td><code>FsPermissions</code></td><td>Permission operations: <code>set_permissions</code></td></tr>
<tr><td><code>FsSync</code></td><td>Sync operations: <code>sync</code>, <code>fsync</code></td></tr>
<tr><td><code>FsStats</code></td><td>Stats operations: <code>statfs</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Inode Trait (Layer 3):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FsInode</code></td><td>Inode operations: <code>path_to_inode</code>, <code>inode_to_path</code>, <code>lookup</code>, <code>metadata_by_inode</code></td></tr>
</tbody>
</table>
</div>
<p><strong>POSIX Traits (Layer 4):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FsHandles</code></td><td>Handle operations: <code>open</code>, <code>read_at</code>, <code>write_at</code>, <code>close</code></td></tr>
<tr><td><code>FsLock</code></td><td>Lock operations: <code>lock</code>, <code>try_lock</code>, <code>unlock</code></td></tr>
<tr><td><code>FsXattr</code></td><td>Extended attribute operations: <code>get_xattr</code>, <code>set_xattr</code>, <code>list_xattr</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Convenience Supertraits:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Combines</th></tr>
</thead>
<tbody>
<tr><td><code>Fs</code></td><td><code>FsRead</code> + <code>FsWrite</code> + <code>FsDir</code> (90% of use cases)</td></tr>
<tr><td><code>FsFull</code></td><td><code>Fs</code> + <code>FsLink</code> + <code>FsPermissions</code> + <code>FsSync</code> + <code>FsStats</code></td></tr>
<tr><td><code>FsFuse</code></td><td><code>FsFull</code> + <code>FsInode</code> (FUSE-mountable)</td></tr>
<tr><td><code>FsPosix</code></td><td><code>FsFuse</code> + <code>FsHandles</code> + <code>FsLock</code> + <code>FsXattr</code> (full POSIX)</td></tr>
</tbody>
</table>
</div>
<p><strong>Other Types:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Layer</code></td><td>Middleware composition trait</td></tr>
<tr><td><code>FsExt</code></td><td>Extension methods trait (JSON, type checks)</td></tr>
<tr><td><code>FsError</code></td><td>Error type (with context)</td></tr>
<tr><td><code>ROOT_INODE</code></td><td>Constant: root directory inode (= 1)</td></tr>
<tr><td><code>FileType</code></td><td><code>File</code>, <code>Directory</code>, <code>Symlink</code></td></tr>
<tr><td><code>Metadata</code></td><td>File/dir metadata (inode, nlink, size, times, permissions)</td></tr>
<tr><td><code>DirEntry</code></td><td>Directory entry (name, inode, file_type)</td></tr>
<tr><td><code>Permissions</code></td><td>File permissions (mode: u32)</td></tr>
<tr><td><code>StatFs</code></td><td>Filesystem stats (bytes, inodes, block_size)</td></tr>
</tbody>
</table>
</div>
<h3 id="from-anyfs"><a class="header" href="#from-anyfs">From <code>anyfs</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>In-memory backend</td></tr>
<tr><td><code>SqliteBackend</code></td><td>SQLite backend</td></tr>
<tr><td><code>StdFsBackend</code></td><td>Direct <code>std::fs</code> backend (no containment)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Host FS backend (with containment)</td></tr>
<tr><td><code>Quota&lt;B&gt;</code></td><td>Quota middleware</td></tr>
<tr><td><code>Restrictions&lt;B&gt;</code></td><td>Feature gate middleware</td></tr>
<tr><td><code>PathFilter&lt;B&gt;</code></td><td>Path access control middleware</td></tr>
<tr><td><code>ReadOnly&lt;B&gt;</code></td><td>Read-only middleware</td></tr>
<tr><td><code>RateLimit&lt;B&gt;</code></td><td>Rate limiting middleware</td></tr>
<tr><td><code>Tracing&lt;B&gt;</code></td><td>Tracing middleware</td></tr>
<tr><td><code>DryRun&lt;B&gt;</code></td><td>Dry-run middleware</td></tr>
<tr><td><code>Cache&lt;B&gt;</code></td><td>Caching middleware</td></tr>
<tr><td><code>Overlay&lt;B1,B2&gt;</code></td><td>Union filesystem middleware</td></tr>
<tr><td><code>QuotaLayer</code></td><td>Layer for Quota</td></tr>
<tr><td><code>RestrictionsLayer</code></td><td>Layer for Restrictions</td></tr>
<tr><td><code>PathFilterLayer</code></td><td>Layer for PathFilter</td></tr>
<tr><td><code>ReadOnlyLayer</code></td><td>Layer for ReadOnly</td></tr>
<tr><td><code>RateLimitLayer</code></td><td>Layer for RateLimit</td></tr>
<tr><td><code>TracingLayer</code></td><td>Layer for Tracing</td></tr>
<tr><td><code>DryRunLayer</code></td><td>Layer for DryRun</td></tr>
<tr><td><code>CacheLayer</code></td><td>Layer for Cache</td></tr>
<tr><td><code>OverlayLayer</code></td><td>Layer for Overlay</td></tr>
</tbody>
</table>
</div>
<p><strong>Ergonomic Wrappers (in <code>anyfs</code>):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FileStorage&lt;B, M&gt;</code></td><td>Zero-cost ergonomic wrapper (generic backend, optional marker)</td></tr>
<tr><td><code>BackendStack</code></td><td>Fluent builder for middleware stacks</td></tr>
<tr><td><code>.boxed()</code></td><td>Opt-in type erasure for <code>FileStorage</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---design-overview"><a class="header" href="#anyfs---design-overview">AnyFS - Design Overview</a></h1>
<p><strong>Status:</strong> Current
<strong>Last updated:</strong> 2025-12-24</p>
<hr>
<h2 id="what-this-project-is"><a class="header" href="#what-this-project-is">What This Project Is</a></h2>
<p>AnyFS is an <strong>open standard</strong> for pluggable virtual filesystem backends in Rust. It uses a <strong>middleware/decorator pattern</strong> (like Axum/Tower) for composable functionality with complete separation of concerns.</p>
<p>Anyone can:</p>
<ul>
<li>Implement a custom backend for their storage needs</li>
<li>Compose middleware to add limits, logging, feature gates</li>
<li>Use the ergonomic <code>FileStorage&lt;M&gt;</code> wrapper</li>
</ul>
<hr>
<h2 id="architecture-tower-style-middleware"><a class="header" href="#architecture-tower-style-middleware">Architecture (Tower-style Middleware)</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FileStorage&lt;M&gt;                         │  ← Ergonomics + type-safe marker
├─────────────────────────────────────────┤
│  Middleware (optional, composable):     │
│                                         │
│  Policy:                                │
│    Quota&lt;B&gt;         - Resource limits   │
│    Restrictions&lt;B&gt;  - Least privilege   │
│    PathFilter&lt;B&gt;    - Sandbox paths     │
│    ReadOnly&lt;B&gt;      - Prevent writes    │
│    RateLimit&lt;B&gt;     - Ops/sec limit     │
│                                         │
│  Observability:                         │
│    Tracing&lt;B&gt;       - Instrumentation   │
│    DryRun&lt;B&gt;        - Test mode         │
│                                         │
│  Performance:                           │
│    Cache&lt;B&gt;         - LRU caching       │
│                                         │
│  Composition:                           │
│    Overlay&lt;B1,B2&gt;   - Layered FS        │
│                                         │
├─────────────────────────────────────────┤
│  Backend (implements Fs, FsFull,        │  ← Pure storage + fs semantics
│           FsFuse, or FsPosix)           │
│  (Memory, SQLite, VRootFs, custom...)   │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>Each layer has exactly one responsibility:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Responsibility</th></tr>
</thead>
<tbody>
<tr><td>Backend (<code>Fs</code>+)</td><td>Storage + filesystem semantics</td></tr>
<tr><td><code>Quota&lt;B&gt;</code></td><td>Resource limits (size, count, depth)</td></tr>
<tr><td><code>Restrictions&lt;B&gt;</code></td><td>Opt-in operation restrictions</td></tr>
<tr><td><code>PathFilter&lt;B&gt;</code></td><td>Path-based access control</td></tr>
<tr><td><code>ReadOnly&lt;B&gt;</code></td><td>Prevent all write operations</td></tr>
<tr><td><code>RateLimit&lt;B&gt;</code></td><td>Limit operations per second</td></tr>
<tr><td><code>Tracing&lt;B&gt;</code></td><td>Instrumentation / audit trail</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="design-principle-predictable-defaults-opt-in-security"><a class="header" href="#design-principle-predictable-defaults-opt-in-security">Design Principle: Predictable Defaults, Opt-in Security</a></h2>
<p><strong>The <code>Fs</code> traits mimic <code>std::fs</code> with predictable, permissive defaults.</strong></p>
<p>The traits are low-level interfaces that any backend can implement - memory, SQLite, real filesystem, network storage, etc. To maintain consistent behavior across all backends:</p>
<ul>
<li>All operations work by default (<code>symlink()</code>, <code>hard_link()</code>, <code>set_permissions()</code>)</li>
<li>No security restrictions at the trait level</li>
<li>Behavior matches what you’d expect from a real filesystem</li>
</ul>
<p><strong>Why not secure-by-default at this layer?</strong></p>
<ol>
<li><strong>Predictability</strong>: A backend should behave like a filesystem. Surprising restrictions break expectations.</li>
<li><strong>Backend-agnostic</strong>: The traits don’t know if they’re wrapping a sandboxed memory store or a real filesystem. Restrictions that make sense for one may not for another.</li>
<li><strong>Composition</strong>: Security is achieved by layering middleware, not by baking it into the storage layer.</li>
</ol>
<p><strong>Security is the responsibility of higher-level APIs:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Security Responsibility</th></tr>
</thead>
<tbody>
<tr><td>Backend (<code>Fs</code>+)</td><td>None - pure filesystem semantics</td></tr>
<tr><td>Middleware (<code>Restrictions</code>, <code>PathFilter</code>, etc.)</td><td>Opt-in restrictions</td></tr>
<tr><td><code>FileStorage</code> or application code</td><td>Configure appropriate middleware</td></tr>
</tbody>
</table>
</div>
<p><strong>Example: Secure AI Agent Sandbox</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, RestrictionsLayer, PathFilterLayer, FileStorage};

struct AiSandbox;  // Marker type

// Application composes secure defaults (marker in type annotation)
let sandbox: FileStorage&lt;_, AiSandbox&gt; = FileStorage::new(
    MemoryBackend::new()
        .layer(QuotaLayer::builder()
            .max_total_size(50 * 1024 * 1024)
            .build())
        .layer(RestrictionsLayer::builder()
            .deny_hard_links()
            .deny_permissions()
            .build())
        .layer(PathFilterLayer::builder()
            .allow("/workspace/**")
            .deny("**/.env")
            .build())
);
<span class="boring">}</span></code></pre>
<p>The backend is permissive. The application adds restrictions appropriate for its use case.</p>
<hr>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th><th>Contains</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract</td><td>Layered traits (<code>Fs</code>, <code>FsFull</code>, <code>FsFuse</code>, <code>FsPosix</code>), <code>Layer</code> trait, types, <code>FsExt</code></td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware + ergonomics</td><td>Built-in backends, all middleware layers, <code>FileStorage&lt;M&gt;</code>, <code>BackendStack</code> builder</td></tr>
</tbody>
</table>
</div>
<h3 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency Graph</a></h3>
<pre><code>anyfs-backend (trait + types)
     ^
     |-- anyfs (backends + middleware + ergonomics)
           ^-- vrootfs feature may use strict-path
</code></pre>
<hr>
<h2 id="trait-architecture-in-anyfs-backend"><a class="header" href="#trait-architecture-in-anyfs-backend">Trait Architecture (in <code>anyfs-backend</code>)</a></h2>
<p>AnyFS uses <strong>layered traits</strong> for maximum flexibility with minimal complexity.</p>
<pre><code>                        FsPosix
                           │
            ┌──────────────┼──────────────┐
            │              │              │
       FsHandles      FsLock       FsXattr
            │              │              │
            └──────────────┼──────────────┘
                           │
                        FsFuse
                           │
                       FsInode
                           │
                        FsFull
                           │
            ┌──────┬───────┼───────┬──────┐
            │      │       │       │      │
       FsLink  FsPerm  FsSync FsStats │
            │      │       │       │      │
            └──────┴───────┼───────┴──────┘
                           │
                           Fs  ← Most users only need this
                           │
               ┌───────────┼───────────┐
               │           │           │
            FsRead    FsWrite     FsDir
</code></pre>
<p><strong>Simple rule:</strong> Import <code>Fs</code> for basic use. Add traits as needed for advanced features.</p>
<hr>
<h2 id="core-traits-layer-1"><a class="header" href="#core-traits-layer-1">Core Traits (Layer 1)</a></h2>
<h3 id="fsread---read-operations"><a class="header" href="#fsread---read-operations">FsRead - Read Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, FsError&gt;;
    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;
    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt;;
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fswrite---write-operations"><a class="header" href="#fswrite---write-operations">FsWrite - Write Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsWrite: Send + Sync {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn append(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn rename(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn copy(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn truncate(&amp;self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), FsError&gt;;
    fn open_write(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<blockquote>
<p><strong>Note:</strong> All methods use <code>&amp;self</code> (interior mutability). Backends manage their own synchronization. See ADR-023.</p>
</blockquote>
<h3 id="fsdir---directory-operations"><a class="header" href="#fsdir---directory-operations">FsDir - Directory Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsDir: Send + Sync {
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt;;
    fn create_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn create_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="extended-traits-layer-2---optional"><a class="header" href="#extended-traits-layer-2---optional">Extended Traits (Layer 2 - Optional)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsLink: Send + Sync {
    fn symlink(&amp;self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn hard_link(&amp;self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt;;
}

pub trait FsPermissions: Send + Sync {
    fn set_permissions(&amp;self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), FsError&gt;;
}

pub trait FsSync: Send + Sync {
    fn sync(&amp;self) -&gt; Result&lt;(), FsError&gt;;
    fn fsync(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
}

pub trait FsStats: Send + Sync {
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="inode-traits-layer-3---for-fuse"><a class="header" href="#inode-traits-layer-3---for-fuse">Inode Traits (Layer 3 - For FUSE)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsInode: Send {
    fn path_to_inode(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;u64, FsError&gt;;
    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn lookup(&amp;self, parent_inode: u64, name: &amp;OsStr) -&gt; Result&lt;u64, FsError&gt;;
    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="posix-traits-layer-4---full-posix"><a class="header" href="#posix-traits-layer-4---full-posix">POSIX Traits (Layer 4 - Full POSIX)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsHandles: Send + Sync {
    fn open(&amp;self, path: impl AsRef&lt;Path&gt;, flags: OpenFlags) -&gt; Result&lt;Handle, FsError&gt;;
    fn read_at(&amp;self, handle: Handle, buf: &amp;mut [u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn write_at(&amp;self, handle: Handle, data: &amp;[u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn close(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}

pub trait FsLock: Send + Sync {
    fn lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;(), FsError&gt;;
    fn try_lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;bool, FsError&gt;;
    fn unlock(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}

pub trait FsXattr: Send + Sync {
    fn get_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn set_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str, value: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str) -&gt; Result&lt;(), FsError&gt;;
    fn list_xattr(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;String&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="convenience-supertraits-simple-api"><a class="header" href="#convenience-supertraits-simple-api">Convenience Supertraits (Simple API)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Basic filesystem - covers 90% of use cases
pub trait Fs: FsRead + FsWrite + FsDir {}
impl&lt;T: FsRead + FsWrite + FsDir&gt; Fs for T {}

/// Full filesystem with all std::fs features
pub trait FsFull: Fs + FsLink + FsPermissions + FsSync + FsStats {}
impl&lt;T: Fs + FsLink + FsPermissions + FsSync + FsStats&gt; FsFull for T {}

/// FUSE-mountable filesystem
pub trait FsFuse: FsFull + FsInode {}
impl&lt;T: FsFull + FsInode&gt; FsFuse for T {}

/// Full POSIX filesystem
pub trait FsPosix: FsFuse + FsHandles + FsLock + FsXattr {}
impl&lt;T: FsFuse + FsHandles + FsLock + FsXattr&gt; FsPosix for T {}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="most-users-just-fs"><a class="header" href="#most-users-just-fs">Most Users: Just <code>Fs</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::Fs;

fn process_files(fs: &amp;impl Fs) {
    let data = fs.read("/input.txt")?;
    fs.write("/output.txt", &amp;processed(data))?;
}
<span class="boring">}</span></code></pre>
<h3 id="need-links-add-the-trait"><a class="header" href="#need-links-add-the-trait">Need Links? Add the Trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{Fs, FsLink};

fn with_symlinks(fs: &amp;mut (impl Fs + FsLink)) {
    fs.write("/target.txt", b"content")?;
    fs.symlink("/target.txt", "/link.txt")?;
}
<span class="boring">}</span></code></pre>
<h3 id="fuse-mount"><a class="header" href="#fuse-mount">FUSE Mount</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::FsFuse;
use anyfs_fuse::FuseMount;

fn mount_filesystem(fs: impl FsFuse) {
    FuseMount::mount(fs, "/mnt/myfs")?;
}
<span class="boring">}</span></code></pre>
<h3 id="full-posix-application"><a class="header" href="#full-posix-application">Full POSIX Application</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::FsPosix;

fn database_app(fs: &amp;mut impl FsPosix) {
    let handle = fs.open("/data.db", OpenFlags::READ_WRITE)?;
    fs.lock(handle, LockType::Exclusive)?;
    fs.write_at(handle, data, offset)?;
    fs.unlock(handle)?;
    fs.close(handle)?;
}

---

# Core Types (in `anyfs-backend`)

## Constants

```rust
/// Root directory inode. FUSE convention.
pub const ROOT_INODE: u64 = 1;
<span class="boring">}</span></code></pre>
<h3 id="metadata"><a class="header" href="#metadata">Metadata</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// File or directory metadata.
pub struct Metadata {
    /// Inode number (unique identifier for this file/directory).
    pub inode: u64,

    /// Number of hard links pointing to this inode.
    pub nlink: u64,

    /// Type: File, Directory, or Symlink.
    pub file_type: FileType,

    /// Size in bytes (0 for directories).
    pub size: u64,

    /// Permission bits.
    pub permissions: Permissions,

    /// Creation time (if supported by backend).
    pub created: Option&lt;SystemTime&gt;,

    /// Last modification time.
    pub modified: Option&lt;SystemTime&gt;,

    /// Last access time (if supported by backend).
    pub accessed: Option&lt;SystemTime&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="filetype"><a class="header" href="#filetype">FileType</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FileType {
    File,
    Directory,
    Symlink,
}
<span class="boring">}</span></code></pre>
<h3 id="direntry"><a class="header" href="#direntry">DirEntry</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Entry in a directory listing.
pub struct DirEntry {
    /// File or directory name (not full path).
    pub name: OsString,

    /// Inode number (avoids extra stat calls).
    pub inode: u64,

    /// Type: File, Directory, or Symlink.
    pub file_type: FileType,
}
<span class="boring">}</span></code></pre>
<h3 id="permissions"><a class="header" href="#permissions">Permissions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Unix-style permission bits.
pub struct Permissions {
    /// Permission mode (e.g., 0o755).
    pub mode: u32,
}

impl Permissions {
    pub fn readonly() -&gt; Self { Permissions { mode: 0o444 } }
    pub fn default_file() -&gt; Self { Permissions { mode: 0o644 } }
    pub fn default_dir() -&gt; Self { Permissions { mode: 0o755 } }
}
<span class="boring">}</span></code></pre>
<h3 id="statfs"><a class="header" href="#statfs">StatFs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Filesystem statistics.
pub struct StatFs {
    /// Total size in bytes.
    pub total_bytes: u64,

    /// Available bytes.
    pub available_bytes: u64,

    /// Total number of inodes.
    pub total_inodes: u64,

    /// Available inodes.
    pub available_inodes: u64,

    /// Filesystem block size.
    pub block_size: u64,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware-in-anyfs"><a class="header" href="#middleware-in-anyfs">Middleware (in <code>anyfs</code>)</a></h2>
<p>Each middleware implements the same traits as its inner backend. This enables composition while preserving capabilities.</p>
<h3 id="quota"><a class="header" href="#quota">Quota<b></b></a></h3>
<p>Enforces quota limits. Tracks usage and rejects operations that would exceed limits.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Quota};

let backend = QuotaLayer::builder()
    .max_total_size(100 * 1024 * 1024)   // 100 MB
    .max_file_size(10 * 1024 * 1024)     // 10 MB per file
    .max_node_count(10_000)              // 10K files/dirs
    .max_dir_entries(1_000)              // 1K entries per dir
    .max_path_depth(64)
    .build()
    .layer(SqliteBackend::open("data.db")?);

// Check usage
let usage = backend.usage();
let remaining = backend.remaining();
<span class="boring">}</span></code></pre>
<h3 id="restrictions"><a class="header" href="#restrictions">Restrictions<b></b></a></h3>
<p>Blocks specific operations when needed.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Restrictions};

// By default, all operations work. Use deny_*() to block specific ones.
let backend = RestrictionsLayer::builder()
    .deny_symlinks()       // Block symlink() calls
    .deny_hard_links()     // Block hard_link() calls
    .deny_permissions()    // Block set_permissions() calls
    .build()
    .layer(MemoryBackend::new());
<span class="boring">}</span></code></pre>
<p>When blocked, operations return <code>FsError::FeatureNotEnabled</code>.</p>
<h3 id="tracing"><a class="header" href="#tracing">Tracing<b></b></a></h3>
<p>Integrates with the <a href="https://docs.rs/tracing">tracing</a> ecosystem for structured logging and instrumentation.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, TracingLayer};

let backend = SqliteBackend::open("data.db")?
    .layer(TracingLayer::new()
        .with_target("anyfs")
        .with_level(tracing::Level::DEBUG));

// Users configure tracing subscribers as they prefer
tracing_subscriber::fmt::init();
<span class="boring">}</span></code></pre>
<p><strong>Why tracing instead of custom logging?</strong></p>
<ul>
<li>Works with existing tracing infrastructure</li>
<li>Structured logging with spans</li>
<li>Compatible with OpenTelemetry, Jaeger, etc.</li>
<li>Users choose their subscriber (console, file, distributed tracing)</li>
</ul>
<h3 id="pathfilter"><a class="header" href="#pathfilter">PathFilter<b></b></a></h3>
<p>Restricts access to specific paths. Essential for sandboxing.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, PathFilter};

let backend = PathFilterLayer::builder()
    .allow("/workspace/**")           // Allow all under /workspace
    .allow("/tmp/**")                  // Allow temp files
    .deny("/workspace/.env")           // But deny .env files
    .deny("**/.git/**")               // Deny all .git directories
    .build()
    .layer(MemoryBackend::new());
<span class="boring">}</span></code></pre>
<p>When a path is denied, operations return <code>FsError::AccessDenied</code>.</p>
<h3 id="readonly"><a class="header" href="#readonly">ReadOnly<b></b></a></h3>
<p>Prevents all write operations. Useful for publishing immutable data.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, ReadOnly};

// Wrap any backend to make it read-only
let backend = ReadOnly::new(SqliteBackend::open("published.db")?);

backend.read("/doc.txt")?;     // OK
backend.write("/doc.txt", b"x"); // Error: FsError::ReadOnly
<span class="boring">}</span></code></pre>
<h3 id="ratelimit"><a class="header" href="#ratelimit">RateLimit<b></b></a></h3>
<p>Limits operations per second. Prevents runaway agents.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, RateLimit};
use std::time::Duration;

let backend = RateLimitLayer::builder()
    .max_ops(100)                        // 100 ops per window
    .window(Duration::from_secs(1))      // 1 second window
    .max_burst(10)                       // Allow bursts up to 10
    .build()
    .layer(MemoryBackend::new());

// When rate exceeded: FsError::RateLimitExceeded
<span class="boring">}</span></code></pre>
<h3 id="dryrun"><a class="header" href="#dryrun">DryRun<b></b></a></h3>
<p>Logs operations without executing writes. Great for testing and debugging.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, DryRun};

let backend = DryRun::new(MemoryBackend::new());

backend.write("/test.txt", b"hello")?;  // Logged but not written
backend.read("/test.txt");               // Error: file doesn't exist

// Get recorded operations
let ops = backend.operations();
// [Operation::Write { path: "/test.txt", size: 5 }]
<span class="boring">}</span></code></pre>
<h3 id="cache"><a class="header" href="#cache">Cache<b></b></a></h3>
<p>LRU cache for read operations. Essential for slow backends (S3, network).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Cache};

let backend = CacheLayer::builder()
    .max_size(100 * 1024 * 1024)      // 100 MB cache
    .max_entries(10_000)              // Max 10K entries
    .ttl(Duration::from_secs(300))    // 5 min TTL
    .build()
    .layer(SqliteBackend::open("data.db")?);

// First read: hits backend, caches result
let data = backend.read("/file.txt")?;

// Second read: served from cache (fast!)
let data = backend.read("/file.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="overlaybase-upper"><a class="header" href="#overlaybase-upper">Overlay&lt;Base, Upper&gt;</a></h3>
<p>Union filesystem with a read-only base and writable upper layer. Like Docker.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, MemoryBackend, Overlay};

// Base: read-only template
let base = SqliteBackend::open("template.db")?;

// Upper: writable layer for changes
let upper = MemoryBackend::new();

let backend = Overlay::new(base, upper);

// Reads check upper first, then base
// Writes always go to upper
// Deletes in upper "shadow" base files
<span class="boring">}</span></code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Container images (base image + writable layer)</li>
<li>Template filesystems with per-user modifications</li>
<li>Testing with rollback capability</li>
</ul>
<hr>
<h2 id="filestorageb-m-in-anyfs"><a class="header" href="#filestorageb-m-in-anyfs">FileStorage&lt;B, M&gt; (in <code>anyfs</code>)</a></h2>
<p><code>FileStorage&lt;B, M&gt;</code> is a <strong>zero-cost ergonomic wrapper</strong> with:</p>
<ul>
<li><strong><code>B</code></strong> - Backend type (generic, no boxing)</li>
<li><strong><code>M</code></strong> - Optional marker type for compile-time safety</li>
</ul>
<p><strong>Axum-style design:</strong> Zero-cost by default, type erasure opt-in via <code>.boxed()</code>.</p>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FileStorage};

// Type is inferred - no need to write it out
let fs = FileStorage::new(MemoryBackend::new());

fs.create_dir_all("/documents")?;
fs.write("/documents/hello.txt", b"Hello!")?;
let content = fs.read("/documents/hello.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="marker-types-type-safe-containers"><a class="header" href="#marker-types-type-safe-containers">Marker Types (Type-Safe Containers)</a></h3>
<p>Use <code>_</code> to infer backend while specifying marker:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, FileStorage};

// Define marker types for your domains
struct Sandbox;
struct UserData;

// Specify marker, infer backend with _
let sandbox: FileStorage&lt;_, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
let userdata: FileStorage&lt;_, UserData&gt; = FileStorage::new(SqliteBackend::open("data.db")?);

// Type-safe function signatures prevent mixing containers
fn process_sandbox(fs: &amp;FileStorage&lt;impl Fs, Sandbox&gt;) {
    // Can only accept Sandbox-marked containers
}

fn save_user_file(fs: &amp;mut FileStorage&lt;impl Fs, UserData&gt;, name: &amp;str, data: &amp;[u8]) {
    // Can only accept UserData-marked containers
}

// Compile-time safety:
process_sandbox(&amp;sandbox);   // OK
process_sandbox(&amp;userdata);  // Compile error! Type mismatch
<span class="boring">}</span></code></pre>
<h3 id="self-documenting-types"><a class="header" href="#self-documenting-types">Self-Documenting Types</a></h3>
<p>Both type parameters are meaningful:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FileStorage&lt;SqliteBackend, TenantA&gt;   // SQLite storage for TenantA
FileStorage&lt;MemoryBackend, Sandbox&gt;   // In-memory sandbox
FileStorage&lt;StdFsBackend, Production&gt; // Real filesystem, production
<span class="boring">}</span></code></pre>
<h3 id="type-aliases-for-clean-code"><a class="header" href="#type-aliases-for-clean-code">Type Aliases for Clean Code</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define your standard secure stack
type SecureBackend = Tracing&lt;Restrictions&lt;Quota&lt;SqliteBackend&gt;&gt;&gt;;

// Type aliases for common combinations
type SandboxFs = FileStorage&lt;MemoryBackend, Sandbox&gt;;
type UserDataFs = FileStorage&lt;SecureBackend, UserData&gt;;

// Clean function signatures
fn run_agent(fs: &amp;mut SandboxFs) { ... }
<span class="boring">}</span></code></pre>
<h3 id="filestorage-implementation"><a class="header" href="#filestorage-implementation">FileStorage Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

/// Zero-cost ergonomic wrapper.
/// Generic over backend (B) and marker (M).
pub struct FileStorage&lt;B, M = ()&gt; {
    backend: B,
    _marker: PhantomData&lt;M&gt;,
}

impl&lt;B: Fs, M&gt; FileStorage&lt;B, M&gt; {
    /// Marker type is specified via type annotation:
    /// `let fs: FileStorage&lt;_, MyMarker&gt; = FileStorage::new(backend);`
    pub fn new(backend: B) -&gt; Self {
        FileStorage { backend, _marker: PhantomData }
    }

    /// Type-erase the backend (opt-in boxing).
    pub fn boxed(self) -&gt; FileStorage&lt;Box&lt;dyn Fs&gt;, M&gt; {
        FileStorage { backend: Box::new(self.backend), _marker: PhantomData }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="type-erasure-opt-in"><a class="header" href="#type-erasure-opt-in">Type Erasure (Opt-in)</a></h3>
<p>When you need uniform types (e.g., collections), use <code>.boxed()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Type-erased for uniform storage
let filesystems: Vec&lt;FileStorage&lt;Box&lt;dyn Fs&gt;&gt;&gt; = vec![
    FileStorage::new(MemoryBackend::new()).boxed(),
    FileStorage::new(SqliteBackend::open("a.db")?).boxed(),
];
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-trait-in-anyfs-backend"><a class="header" href="#layer-trait-in-anyfs-backend">Layer Trait (in <code>anyfs-backend</code>)</a></h2>
<p>The <code>Layer</code> trait (inspired by Tower) standardizes middleware composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A layer that wraps a backend to add functionality.
pub trait Layer&lt;B: Fs&gt; {
    type Backend: Fs;
    fn layer(self, backend: B) -&gt; Self::Backend;
}
<span class="boring">}</span></code></pre>
<p>Each middleware provides a corresponding <code>Layer</code> implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// QuotaLayer, TracingLayer, RestrictionsLayer, etc.
pub struct QuotaLayer { limits: QuotaLimits }

impl&lt;B: Fs&gt; Layer&lt;B&gt; for QuotaLayer {
    type Backend = Quota&lt;B&gt;;
    fn layer(self, backend: B) -&gt; Self::Backend {
        Quota::from_limits(self.limits).layer(backend)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> Middleware that implements additional traits (like <code>FsInode</code>) can use more specific bounds to preserve capabilities through the layer.</p>
<hr>
<h2 id="composing-middleware"><a class="header" href="#composing-middleware">Composing Middleware</a></h2>
<p>Middleware composes by wrapping. Order matters - innermost applies first.</p>
<h3 id="fluent-composition"><a class="header" href="#fluent-composition">Fluent Composition</a></h3>
<p>Use the <code>.layer()</code> extension method for Axum-style composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, TracingLayer};

let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_permissions()  // Block set_permissions()
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<h3 id="backendstack-builder"><a class="header" href="#backendstack-builder">BackendStack Builder</a></h3>
<p>For complex stacks, use <code>BackendStack</code> for a fluent API:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::BackendStack;

let fs = BackendStack::new(SqliteBackend::open("data.db")?)
    .limited(|l| l
        .max_total_size(100 * 1024 * 1024)
        .max_file_size(10 * 1024 * 1024))
    .restricted(|g| g
        .deny_hard_links()      // Block hard_link() calls
        .deny_permissions())    // Block set_permissions() calls
    .traced()
    .into_container();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="built-in-backends-1"><a class="header" href="#built-in-backends-1">Built-in Backends</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td><code>memory</code> (default)</td><td>In-memory storage</td></tr>
<tr><td><code>SqliteBackend</code></td><td><code>sqlite</code></td><td>Single-file portable database</td></tr>
<tr><td><code>SqliteCipherBackend</code></td><td><code>sqlite-cipher</code></td><td>Encrypted SQLite via SQLCipher (AES-256)</td></tr>
<tr><td><code>StdFsBackend</code></td><td><code>stdfs</code></td><td>Direct <code>std::fs</code> delegation (no containment)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td><code>vrootfs</code></td><td>Host filesystem with path containment (via strict-path)</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> <code>sqlite</code> and <code>sqlite-cipher</code> features are mutually exclusive (both use rusqlite with different SQLite builds).</p>
<hr>
<h2 id="path-handling"><a class="header" href="#path-handling">Path Handling</a></h2>
<p>All layers use <code>impl AsRef&lt;Path&gt;</code>, aligned with <code>std::fs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All of these work
fs.write("/file.txt", data)?;
fs.write(String::from("/file.txt"), data)?;
fs.write(Path::new("/file.txt"), data)?;
fs.write(PathBuf::from("/file.txt"), data)?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-resolution"><a class="header" href="#path-resolution">Path Resolution</a></h2>
<p>Path resolution (walking directory structure, following symlinks) operates on the <strong><code>Fs</code> abstraction</strong>, not reimplemented per-backend.</p>
<h3 id="why-abstract-path-resolution"><a class="header" href="#why-abstract-path-resolution">Why Abstract Path Resolution?</a></h3>
<p>We simulate inodes - that’s the whole point of virtualizing a filesystem. Path resolution must work on that abstraction:</p>
<ul>
<li><code>/foo/../bar</code> cannot be resolved lexically - <code>foo</code> might be a symlink to <code>/other/place</code>, making <code>..</code> resolve to <code>/other</code></li>
<li>Resolution requires following the actual directory structure (inodes)</li>
<li>The <code>Fs</code> traits have the needed methods: <code>metadata()</code>, <code>read_link()</code>, <code>read_dir()</code></li>
</ul>
<h3 id="internal-resolution-private"><a class="header" href="#internal-resolution-private">Internal Resolution (Private)</a></h3>
<p><code>FileStorage</code> uses an internal resolution function to walk paths before passing them to backends:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Internal: Resolve a path, optionally following symlinks.
/// Used by FileStorage before delegating to backend.
fn resolve_path_internal(
    backend: &amp;(impl Fs + FsLink),
    path: impl AsRef&lt;Path&gt;,
    follow_symlinks: bool,
) -&gt; Result&lt;PathBuf, FsError&gt; {
    // Walk path component by component
    // Use backend.metadata() to check node types
    // Use backend.read_link() to follow symlinks (if enabled)
    // Detect circular symlinks
    // Return fully resolved canonical path
}
<span class="boring">}</span></code></pre>
<p><strong>This is NOT a public API.</strong> The public API for path resolution is the <code>canonicalize</code> family of methods on <code>FileStorage</code> (see “Path Canonicalization Utilities” below).</p>
<h3 id="when-resolution-is-needed"><a class="header" href="#when-resolution-is-needed">When Resolution Is Needed</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Needs Our Resolution?</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Yes</td><td>Storage (HashMap) has no FS semantics</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Yes</td><td>Storage (SQL tables) has no FS semantics</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>No</td><td>OS handles resolution; <code>strict-path</code> prevents escapes</td></tr>
</tbody>
</table>
</div>
<h3 id="opt-out-mechanism"><a class="header" href="#opt-out-mechanism">Opt-out Mechanism</a></h3>
<p>Virtual backends need resolution by default. Real filesystem backends opt out via a marker trait or associated constant:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Marker trait for backends that handle their own path resolution.
/// VRootFsBackend implements this because the OS handles resolution.
pub trait SelfResolving {}

impl SelfResolving for VRootFsBackend {}
<span class="boring">}</span></code></pre>
<p><code>FileStorage</code> (or a dedicated wrapper) applies resolution automatically for backends that don’t implement <code>SelfResolving</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M&gt; FileStorage&lt;M&gt; {
    pub fn new(backend: impl Fs + 'static) -&gt; FileStorage {
        // Resolution applied automatically if backend doesn't implement SelfResolving
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-canonicalization-utilities"><a class="header" href="#path-canonicalization-utilities">Path Canonicalization Utilities</a></h2>
<p><code>FileStorage</code> provides path canonicalization methods modeled after the <a href="https://crates.io/crates/soft-canonicalize">soft-canonicalize</a> crate, adapted to work on the virtual filesystem abstraction.</p>
<h3 id="why-we-need-our-own-canonicalization"><a class="header" href="#why-we-need-our-own-canonicalization">Why We Need Our Own Canonicalization</a></h3>
<p><code>std::fs::canonicalize</code> operates on the <strong>real</strong> filesystem. For virtual backends (<code>MemoryBackend</code>, <code>SqliteBackend</code>), there is no real filesystem - we need canonicalization that queries the virtual structure via <code>metadata()</code> and <code>read_link()</code>.</p>
<h3 id="core-methods"><a class="header" href="#core-methods">Core Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: Fs + FsLink, M&gt; FileStorage&lt;B, M&gt; {
    /// Strict canonicalization - entire path must exist.
    ///
    /// Resolves all symlinks and normalizes the path.
    /// Returns error if any component doesn't exist.
    pub fn canonicalize(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt;;

    /// Soft canonicalization - resolves existing components,
    /// appends non-existent remainder lexically.
    ///
    /// Walks path component-by-component:
    /// 1. For existing components → resolve symlinks, follow them
    /// 2. When hitting non-existent component → append remainder lexically
    ///
    /// Inspired by Python's `pathlib.Path.resolve(strict=False)`.
    pub fn soft_canonicalize(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt;;

    /// Anchored soft canonicalization - like soft_canonicalize but
    /// clamps result within a boundary directory.
    ///
    /// Useful for sandboxing: ensures the resolved path never escapes
    /// the anchor directory, even via symlinks or `..` traversal.
    pub fn anchored_canonicalize(
        &amp;self,
        path: impl AsRef&lt;Path&gt;,
        anchor: impl AsRef&lt;Path&gt;
    ) -&gt; Result&lt;PathBuf, FsError&gt;;
}

/// Standalone lexical normalization (no backend needed).
///
/// Pure string manipulation:
/// - Collapses `//` to `/`
/// - Removes trailing slashes
/// - Does NOT resolve `.` or `..` (those require filesystem context)
/// - Does NOT follow symlinks
pub fn normalize(path: impl AsRef&lt;Path&gt;) -&gt; PathBuf;
<span class="boring">}</span></code></pre>
<h3 id="algorithm-component-by-component-resolution"><a class="header" href="#algorithm-component-by-component-resolution">Algorithm: Component-by-Component Resolution</a></h3>
<p>The canonicalization algorithm walks the path one component at a time:</p>
<pre><code>Input: /a/b/c/d/e

1. Start at root (/)
2. Check /a exists?
   - Yes, and it's a symlink → follow to target
   - Yes, and it's a directory → continue
3. Check /a/b exists?
   - Yes → continue
4. Check /a/b/c exists?
   - No → stop resolution, append "c/d/e" lexically
5. Result: /resolved/path/to/b/c/d/e
</code></pre>
<p><strong>Key behaviors:</strong></p>
<ul>
<li><strong>Symlink following</strong>: Existing symlinks are resolved to their targets</li>
<li><strong>Non-existent handling</strong>: When a component doesn’t exist, the remainder is appended as-is</li>
<li><strong>Cycle detection</strong>: Bounded depth tracking prevents infinite loops from circular symlinks</li>
<li><strong>Root boundary</strong>: Never ascends past the filesystem root</li>
</ul>
<h3 id="comparison-with-stdfs"><a class="header" href="#comparison-with-stdfs">Comparison with std::fs</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th><code>std::fs</code></th><th><code>FileStorage</code></th></tr>
</thead>
<tbody>
<tr><td><code>canonicalize</code></td><td>Requires all components exist</td><td>Same - returns error if path doesn’t exist</td></tr>
<tr><td>N/A</td><td>N/A</td><td><code>soft_canonicalize</code> - handles non-existent paths</td></tr>
<tr><td>N/A</td><td>N/A</td><td><code>anchored_canonicalize</code> - sandboxed resolution</td></tr>
</tbody>
</table>
</div>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<p><strong>For virtual backends:</strong> Canonicalization happens entirely within the virtual structure. There is no host filesystem to escape to.</p>
<p><strong>For <code>VRootFsBackend</code>:</strong> Delegates to OS canonicalization + <code>strict-path</code> containment. The <code>anchored_canonicalize</code> provides additional safety by clamping paths within a boundary.</p>
<h3 id="platform-notes-vrootfsbackend-only"><a class="header" href="#platform-notes-vrootfsbackend-only">Platform Notes (VRootFsBackend only)</a></h3>
<p>When delegating to OS canonicalization:</p>
<ul>
<li><strong>Windows</strong>: Returns extended-length UNC paths (<code>\\?\C:\path</code>) by default</li>
<li><strong>Linux/macOS</strong>: Standard canonical paths</li>
</ul>
<h4 id="windows-unc-path-simplification"><a class="header" href="#windows-unc-path-simplification">Windows UNC Path Simplification</a></h4>
<p>The <code>dunce</code> crate provides <code>simplified()</code> - a <strong>lexical</strong> function that converts UNC paths to regular paths without filesystem access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dunce::simplified;

// \\?\C:\Users\foo\bar.txt → C:\Users\foo\bar.txt
let path = simplified(Path::new(r"\\?\C:\Users\foo\bar.txt"));
<span class="boring">}</span></code></pre>
<p><strong>Why this matters for <code>soft_canonicalize</code>:</strong></p>
<ul>
<li><code>soft_canonicalize</code> works with non-existent paths</li>
<li>We can’t use <code>dunce::canonicalize</code> (requires path to exist)</li>
<li><code>dunce::simplified</code> is pure string manipulation - works on any path</li>
</ul>
<p><strong>When UNC can be simplified:</strong></p>
<ul>
<li>Path is on a local drive (C:, D:, etc.)</li>
<li>Path doesn’t exceed MAX_PATH (260 chars)</li>
<li>No reserved names (CON, PRN, etc.)</li>
</ul>
<p><strong>When UNC must be kept:</strong></p>
<ul>
<li>Network paths (<code>\\?\UNC\server\share</code>)</li>
<li>Paths exceeding MAX_PATH</li>
<li>Paths with reserved device names</li>
</ul>
<p>Virtual backends have no platform differences - paths are just strings.</p>
<hr>
<h2 id="filesystem-semantics-linux-like-by-default"><a class="header" href="#filesystem-semantics-linux-like-by-default">Filesystem Semantics: Linux-like by Default</a></h2>
<p><strong>Design principle:</strong> Simple, secure defaults. Don’t close doors for alternative semantics.</p>
<h3 id="default-behavior-built-in-backends"><a class="header" href="#default-behavior-built-in-backends">Default Behavior (Built-in Backends)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Behavior</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>Case sensitivity</td><td><strong>Case-sensitive</strong></td><td>Simpler, more secure, Unix standard</td></tr>
<tr><td>Path separator</td><td><strong><code>/</code> internally</strong></td><td>Cross-platform consistency</td></tr>
<tr><td>Reserved names</td><td><strong>None</strong></td><td>No artificial restrictions</td></tr>
<tr><td>Max path length</td><td><strong>No limit</strong></td><td>Virtual, no OS constraints</td></tr>
<tr><td>ADS (<code>:stream</code>)</td><td><strong>Not supported</strong></td><td>Security risk, complexity</td></tr>
</tbody>
</table>
</div>
<h3 id="trait-is-agnostic"><a class="header" href="#trait-is-agnostic">Trait is Agnostic</a></h3>
<p>The <code>Fs</code> trait doesn’t enforce filesystem semantics - backends decide their behavior:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Built-in backends: Linux-like
let linux_fs = MemoryBackend::new();
assert!(linux_fs.exists("/Foo.txt")? != linux_fs.exists("/foo.txt")?);

// Someone wants NTFS-like behavior? User-implemented middleware or custom backend:
let ntfs_like = CaseInsensitive::new(           // (user-implemented middleware)
    NtfsValidation::new(MemoryBackend::new())   // (user-implemented middleware)
);

// Or full custom implementation
impl Fs for NtfsEmulatingBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let normalized = self.case_fold(path);  // Case-insensitive lookup
        // ...
    }
}
<span class="boring">}</span></code></pre>
<h3 id="fuse-mount-report-what-you-support"><a class="header" href="#fuse-mount-report-what-you-support">FUSE Mount: Report What You Support</a></h3>
<p>When mounting, the FUSE layer reports backend capabilities to the OS:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FuseOps for AnyFsFuse&lt;B&gt; {
    fn get_volume_params(&amp;self) -&gt; VolumeParams {
        VolumeParams {
            case_sensitive: self.backend.is_case_sensitive(),
            supports_hard_links: /* check if B: FsLink */,
            supports_symlinks: /* check if B: FsLink */,
            // ...
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Windows respects these flags - a case-sensitive mounted filesystem works correctly (modern Windows/WSL handle this).</p>
<h3 id="illustrative-custom-middleware-for-windows-compatibility"><a class="header" href="#illustrative-custom-middleware-for-windows-compatibility">Illustrative: Custom Middleware for Windows Compatibility</a></h3>
<p>For users who need Windows-safe paths in virtual backends, here are example middleware patterns (not built-in - implement as needed):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Example: Middleware that validates paths are Windows-compatible.
/// Rejects: CON, PRN, NUL, COM1-9, LPT1-9, trailing dots/spaces, ADS.
pub struct NtfsValidation&lt;B&gt; { /* user-implemented */ }

/// Example: Middleware that makes a backend case-insensitive.
/// Stores canonical (lowercase) keys, preserves original case in metadata.
pub struct CaseInsensitive&lt;B&gt; { /* user-implemented */ }
<span class="boring">}</span></code></pre>
<p><strong>Not built-in</strong> - these are illustrative patterns for users who need NTFS-like behavior.</p>
<hr>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<p>Security is achieved through composition:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Solution</th></tr>
</thead>
<tbody>
<tr><td>Path containment</td><td><code>PathFilter</code> + VRootFsBackend</td></tr>
<tr><td>Resource exhaustion</td><td><code>Quota</code> enforces quotas</td></tr>
<tr><td>Rate limiting</td><td><code>RateLimit</code> prevents abuse</td></tr>
<tr><td>Feature restriction</td><td><code>Restrictions</code> disables dangerous features</td></tr>
<tr><td>Read-only access</td><td><code>ReadOnly</code> prevents writes</td></tr>
<tr><td>Audit trail</td><td><code>Tracing</code> instruments operations</td></tr>
<tr><td>Tenant isolation</td><td>Separate backend instances</td></tr>
<tr><td>Testing</td><td><code>DryRun</code> logs without executing</td></tr>
</tbody>
</table>
</div>
<p><strong>Defense in depth:</strong> Compose multiple middleware layers for comprehensive security.</p>
<h3 id="ai-agent-sandbox-example"><a class="header" href="#ai-agent-sandbox-example">AI Agent Sandbox Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Quota, PathFilter, RateLimit, Restrictions, Tracing};

// Build a secure sandbox for an AI agent
let sandbox = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(50 * 1024 * 1024)  // 50 MB
        .max_file_size(5 * 1024 * 1024)    // 5 MB per file
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .deny("**/secrets/**")
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_symlinks()
        .deny_hard_links()
        .build())
    .layer(RateLimitLayer::builder()
        .max_ops(1000)
        .per_second()
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="extension-traits-in-anyfs-backend"><a class="header" href="#extension-traits-in-anyfs-backend">Extension Traits (in <code>anyfs-backend</code>)</a></h2>
<p>The <code>FsExt</code> trait provides convenience methods for any <code>Fs</code> backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Extension methods for Fs (auto-implemented for all backends).
pub trait FsExt: Fs {
    /// Check if path is a file.
    fn is_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        self.metadata(path).map(|m| m.file_type == FileType::File)
    }

    /// Check if path is a directory.
    fn is_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        self.metadata(path).map(|m| m.file_type == FileType::Directory)
    }

    // JSON methods require `serde` feature (see below)
    #[cfg(feature = "serde")]
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, FsError&gt;;
    #[cfg(feature = "serde")]
    fn write_json&lt;T: Serialize&gt;(&amp;self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), FsError&gt;;
}

// Blanket implementation for all Fs backends
impl&lt;B: Fs&gt; FsExt for B {}
<span class="boring">}</span></code></pre>
<h3 id="json-methods-feature-serde"><a class="header" href="#json-methods-feature-serde">JSON Methods (feature: <code>serde</code>)</a></h3>
<p>The <code>read_json</code> and <code>write_json</code> methods require the <code>serde</code> feature:</p>
<pre><code class="language-toml">anyfs-backend = { version = "0.1", features = ["serde"] }
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, de::DeserializeOwned};

#[cfg(feature = "serde")]
impl&lt;B: Fs&gt; FsExt for B {
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, FsError&gt; {
        let bytes = self.read(path)?;
        serde_json::from_slice(&amp;bytes).map_err(|e| FsError::Deserialization(e.to_string()))
    }

    fn write_json&lt;T: Serialize&gt;(&amp;self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), FsError&gt; {
        let bytes = serde_json::to_vec(value).map_err(|e| FsError::Serialization(e.to_string()))?;
        self.write(path, &amp;bytes)
    }
}
<span class="boring">}</span></code></pre>
<p>Users can define their own extension traits for domain-specific operations.</p>
<hr>
<h2 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h2>
<h3 id="bytes-support-feature-bytes"><a class="header" href="#bytes-support-feature-bytes">Bytes Support (feature: <code>bytes</code>)</a></h3>
<p>For zero-copy efficiency, enable the <code>bytes</code> feature to use <code>Bytes</code> instead of <code>Vec&lt;u8&gt;</code>:</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["bytes"] }
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bytes::Bytes;

// With bytes feature, read returns Bytes (O(1) slicing)
let data: Bytes = backend.read("/large-file.bin")?;
let slice = data.slice(1000..2000);  // Zero-copy!
<span class="boring">}</span></code></pre>
<p><strong>When to use:</strong></p>
<ul>
<li>Large file handling with frequent slicing</li>
<li>Network-backed storage</li>
<li>Streaming scenarios</li>
</ul>
<p><strong>Default:</strong> <code>Vec&lt;u8&gt;</code> (no extra dependency)</p>
<hr>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<p><code>FsError</code> includes context for better debugging:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FsError {
    /// Path not found.
    NotFound {
        path: PathBuf,
        operation: &amp;'static str,  // "read", "metadata", etc.
    },

    /// Path already exists.
    AlreadyExists {
        path: PathBuf,
        operation: &amp;'static str,
    },

    /// Expected a file, found directory.
    NotAFile { path: PathBuf },

    /// Expected a directory, found file.
    NotADirectory { path: PathBuf },

    /// Directory not empty (for remove_dir).
    DirectoryNotEmpty { path: PathBuf },

    /// Quota exceeded.
    QuotaExceeded {
        limit: u64,
        requested: u64,
        usage: u64,
    },

    /// File size limit exceeded.
    FileSizeExceeded {
        path: PathBuf,
        size: u64,
        limit: u64,
    },

    /// Feature not enabled (from Restrictions).
    FeatureNotEnabled {
        feature: &amp;'static str,  // "symlinks", "hard_links", "permissions"
        operation: &amp;'static str,
    },

    /// Access denied (from PathFilter).
    AccessDenied {
        path: PathBuf,
        reason: &amp;'static str,  // "path_denied", "pattern_blocked"
    },

    /// Read-only filesystem (from ReadOnly).
    ReadOnly {
        operation: &amp;'static str,
    },

    /// Rate limit exceeded (from RateLimit).
    RateLimitExceeded {
        limit: u32,
        window_secs: u64,
    },

    /// Operation not supported by this backend.
    NotSupported {
        operation: &amp;'static str,
    },

    /// Serialization error (from FsExt).
    Serialization(String),

    /// Deserialization error (from FsExt).
    Deserialization(String),

    /// Invalid password or encryption key (from SqliteCipherBackend).
    InvalidPassword,

    /// Data integrity verification failed (from encryption middleware).
    /// AEAD tag mismatch, HMAC verification failure, etc.
    IntegrityError {
        path: PathBuf,
    },

    /// Backend-specific error.
    Backend(String),

    /// I/O error.
    Io(std::io::Error),
}
<span class="boring">}</span></code></pre>
<p>All error variants include enough context for meaningful error messages.</p>
<hr>
<h2 id="cross-platform-compatibility"><a class="header" href="#cross-platform-compatibility">Cross-Platform Compatibility</a></h2>
<p>AnyFS is designed for cross-platform use. Virtual backends work everywhere; real filesystem backends have platform considerations.</p>
<h3 id="backend-compatibility"><a class="header" href="#backend-compatibility">Backend Compatibility</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th style="text-align: center">Windows</th><th style="text-align: center">Linux</th><th style="text-align: center">macOS</th><th style="text-align: center">WASM</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td><code>SqliteBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅*</td></tr>
<tr><td><code>VRootFsBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td><code>StdFsBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
</tbody>
</table>
</div>
<p>*SQLite on WASM requires <code>wasm32</code> build of rusqlite with bundled SQLite.</p>
<h3 id="feature-compatibility"><a class="header" href="#feature-compatibility">Feature Compatibility</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center">Virtual Backends</th><th style="text-align: center">VRootFsBackend</th></tr>
</thead>
<tbody>
<tr><td>Basic I/O (<code>Fs</code>)</td><td style="text-align: center">✅ All platforms</td><td style="text-align: center">✅ All platforms</td></tr>
<tr><td>Symlinks</td><td style="text-align: center">✅ All platforms</td><td style="text-align: center">Platform-dependent (see below)</td></tr>
<tr><td>Hard links</td><td style="text-align: center">✅ All platforms</td><td style="text-align: center">Platform-dependent</td></tr>
<tr><td>Permissions</td><td style="text-align: center">✅ Stored as metadata</td><td style="text-align: center">Platform-dependent</td></tr>
<tr><td>Extended attributes</td><td style="text-align: center">✅ Stored as metadata</td><td style="text-align: center">Platform-dependent</td></tr>
<tr><td>FUSE mounting</td><td style="text-align: center">N/A</td><td style="text-align: center">Platform-dependent</td></tr>
</tbody>
</table>
</div>
<h3 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h3>
<h4 id="virtual-backends-memorybackend-sqlitebackend"><a class="header" href="#virtual-backends-memorybackend-sqlitebackend">Virtual Backends (MemoryBackend, SqliteBackend)</a></h4>
<p><strong>Fully cross-platform.</strong> All features work identically everywhere because:</p>
<ul>
<li>Paths are just strings/keys - no OS path resolution</li>
<li>Symlinks are stored data, not OS constructs</li>
<li>Permissions are metadata, not enforced by OS</li>
<li>No filesystem syscalls involved</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This works identically on Windows, Linux, macOS, and WASM
let fs = MemoryBackend::new();
fs.symlink("/target", "/link")?;           // Just stores the link
fs.set_permissions("/file", 0o755.into())?; // Just stores metadata
<span class="boring">}</span></code></pre>
<h4 id="vrootfsbackend-real-filesystem"><a class="header" href="#vrootfsbackend-real-filesystem">VRootFsBackend (Real Filesystem)</a></h4>
<p>Wraps the host filesystem. Platform differences apply:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Linux</th><th>macOS</th><th>Windows</th></tr>
</thead>
<tbody>
<tr><td>Symlinks</td><td>✅</td><td>✅</td><td>⚠️ Requires privileges*</td></tr>
<tr><td>Hard links</td><td>✅</td><td>✅</td><td>✅ (NTFS only)</td></tr>
<tr><td>Permissions (mode bits)</td><td>✅</td><td>✅</td><td>⚠️ Limited mapping</td></tr>
<tr><td>Extended attributes</td><td>✅ xattr</td><td>✅ xattr</td><td>⚠️ ADS (different API)</td></tr>
<tr><td>Case sensitivity</td><td>✅</td><td>⚠️ Default insensitive</td><td>⚠️ Insensitive</td></tr>
</tbody>
</table>
</div>
<p>*Windows requires <code>SeCreateSymbolicLinkPrivilege</code> or Developer Mode for symlinks.</p>
<h4 id="fuse-mounting"><a class="header" href="#fuse-mounting">FUSE Mounting</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Support</th><th>Library</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>✅ Native</td><td>libfuse</td></tr>
<tr><td>macOS</td><td>⚠️ Third-party</td><td>macFUSE</td></tr>
<tr><td>Windows</td><td>⚠️ Third-party</td><td>WinFsp or Dokan</td></tr>
<tr><td>WASM</td><td>❌</td><td>N/A</td></tr>
</tbody>
</table>
</div>
<h3 id="path-handling-1"><a class="header" href="#path-handling-1">Path Handling</a></h3>
<p>Virtual backends use <code>/</code> as separator internally, regardless of platform:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Always use forward slashes with virtual backends
fs.write("/project/src/main.rs", code)?;  // Works everywhere
<span class="boring">}</span></code></pre>
<p><code>VRootFsBackend</code> translates to native paths internally:</p>
<ul>
<li>Linux/macOS: <code>/</code> stays <code>/</code></li>
<li>Windows: <code>/project/file.txt</code> → <code>C:\root\project\file.txt</code></li>
</ul>
<h3 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommended Backend</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>Cross-platform app</td><td><code>MemoryBackend</code> or <code>SqliteBackend</code></td><td>No platform differences</td></tr>
<tr><td>Portable storage</td><td><code>SqliteBackend</code></td><td>Single file, works everywhere</td></tr>
<tr><td>WASM/browser</td><td><code>MemoryBackend</code> or <code>SqliteBackend</code></td><td>No filesystem access needed</td></tr>
<tr><td>Host filesystem access</td><td><code>VRootFsBackend</code></td><td>With awareness of platform limits</td></tr>
<tr><td>Testing</td><td><code>MemoryBackend</code></td><td>Fast, no cleanup, deterministic</td></tr>
</tbody>
</table>
</div>
<h3 id="feature-detection"><a class="header" href="#feature-detection">Feature Detection</a></h3>
<p>Check platform capabilities at runtime if needed:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Check if symlinks are supported on the current platform.
pub fn symlinks_available() -&gt; bool {
    #[cfg(unix)]
    return true;

    #[cfg(windows)]
    {
        // Check for Developer Mode or symlink privilege
        // ...
    }
}
<span class="boring">}</span></code></pre>
<p>Or use <code>Restrictions</code> middleware to disable unsupported features uniformly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(windows)]
let backend = RestrictionsLayer::builder()
    .deny_symlinks()
    .build()
    .layer(backend);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="layered-design-backends--middleware--ergonomics"><a class="header" href="#layered-design-backends--middleware--ergonomics">Layered Design: Backends + Middleware + Ergonomics</a></h1>
<p>AnyFS uses a layered architecture that separates concerns:</p>
<ol>
<li><strong>Backends</strong>: Pure storage + filesystem semantics</li>
<li><strong>Middleware</strong>: Composable policy layers</li>
<li><strong>FileStorage</strong>: Ergonomic wrapper</li>
</ol>
<hr>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FileStorage                         │  ← Ergonomics only
├─────────────────────────────────────────┤
│  Middleware Stack (composable):         │  ← Policy enforcement
│    Tracing → PathFilter → Restrictions  │
│    → Quota → Backend                    │
├─────────────────────────────────────────┤
│  Fs                             │  ← Pure storage
│  (Memory, SQLite, VRootFs, custom)      │
└─────────────────────────────────────────┘
</code></pre>
<hr>
<h2 id="layer-responsibilities"><a class="header" href="#layer-responsibilities">Layer Responsibilities</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Responsibility</th><th>Path Handling</th></tr>
</thead>
<tbody>
<tr><td><code>FileStorage</code></td><td>Ergonomic API</td><td>Accepts <code>impl AsRef&lt;Path&gt;</code></td></tr>
<tr><td>Middleware</td><td>Policy enforcement</td><td>Accepts <code>impl AsRef&lt;Path&gt;</code></td></tr>
<tr><td>Backend</td><td>Storage + FS semantics</td><td>Accepts <code>impl AsRef&lt;Path&gt;</code></td></tr>
</tbody>
</table>
</div>
<p>All layers use <code>impl AsRef&lt;Path&gt;</code> for consistency with <code>std::fs</code>.</p>
<hr>
<h2 id="policy-via-middleware"><a class="header" href="#policy-via-middleware">Policy via Middleware</a></h2>
<p><strong>Old design (rejected):</strong> FileStorage contained quota/feature logic.</p>
<p><strong>Current design:</strong> Policy is handled by composable middleware:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Middleware enforces policy
let backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_symlinks()
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .build());

// FileStorage is just ergonomics
let fs = FileStorage::new(backend);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-containment"><a class="header" href="#path-containment">Path Containment</a></h2>
<p>For <code>VRootFsBackend</code> (real filesystem), path containment uses <code>strict-path::VirtualRoot</code> internally:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Fs for VRootFsBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // VirtualRoot ensures paths can't escape
        let safe_path = self.root.join(path)?;
        std::fs::read(safe_path).map_err(Into::into)
    }
}
<span class="boring">}</span></code></pre>
<p>For virtual backends (Memory, SQLite), paths are just keys - no OS path traversal possible.</p>
<p>For sandboxing across all backends, use <code>PathFilter</code> middleware:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PathFilterLayer::builder()
    .allow("/workspace/**")
    .deny("**/.env")
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<ul>
<li><strong>Separation of concerns</strong>: Backends focus on storage, middleware handles policy</li>
<li><strong>Composability</strong>: Add/remove policies without touching storage code</li>
<li><strong>Flexibility</strong>: Same middleware works with any backend</li>
<li><strong>Simplicity</strong>: Each layer has one job</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---architecture-decision-records"><a class="header" href="#anyfs---architecture-decision-records">AnyFS - Architecture Decision Records</a></h1>
<p>This file captures the decisions for the current AnyFS design.</p>
<hr>
<h2 id="adr-index"><a class="header" href="#adr-index">ADR Index</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ADR</th><th>Title</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>ADR-001</td><td>Path-based <code>Fs</code> trait</td><td>Accepted</td></tr>
<tr><td>ADR-002</td><td>Two-crate structure</td><td>Accepted</td></tr>
<tr><td>ADR-003</td><td><code>impl AsRef&lt;Path&gt;</code> for all path parameters</td><td>Accepted</td></tr>
<tr><td>ADR-004</td><td>Tower-style middleware pattern</td><td>Accepted</td></tr>
<tr><td>ADR-005</td><td><code>std::fs</code>-aligned method names</td><td>Accepted</td></tr>
<tr><td>ADR-006</td><td>Quota for quota enforcement</td><td>Accepted</td></tr>
<tr><td>ADR-007</td><td>Restrictions for least-privilege</td><td>Accepted</td></tr>
<tr><td>ADR-008</td><td>FileStorage as thin ergonomic wrapper</td><td>Accepted</td></tr>
<tr><td>ADR-009</td><td>Built-in backends are feature-gated</td><td>Accepted</td></tr>
<tr><td>ADR-010</td><td>Sync-first, async-ready design</td><td>Accepted</td></tr>
<tr><td>ADR-011</td><td>Layer trait for standardized composition</td><td>Accepted</td></tr>
<tr><td>ADR-012</td><td>Tracing for instrumentation</td><td>Accepted</td></tr>
<tr><td>ADR-013</td><td>FsExt for extension methods</td><td>Accepted</td></tr>
<tr><td>ADR-014</td><td>Optional Bytes support</td><td>Accepted</td></tr>
<tr><td>ADR-015</td><td>Contextual FsError</td><td>Accepted</td></tr>
<tr><td>ADR-016</td><td>PathFilter for path-based access control</td><td>Accepted</td></tr>
<tr><td>ADR-017</td><td>ReadOnly for preventing writes</td><td>Accepted</td></tr>
<tr><td>ADR-018</td><td>RateLimit for operation throttling</td><td>Accepted</td></tr>
<tr><td>ADR-019</td><td>DryRun for testing and debugging</td><td>Accepted</td></tr>
<tr><td>ADR-020</td><td>Cache for read performance</td><td>Accepted</td></tr>
<tr><td>ADR-021</td><td>Overlay for union filesystem</td><td>Accepted</td></tr>
<tr><td>ADR-022</td><td>Builder pattern for configurable middleware</td><td>Accepted</td></tr>
<tr><td>ADR-023</td><td>Interior mutability for all trait methods</td><td>Accepted</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="adr-001-path-based-fs-trait"><a class="header" href="#adr-001-path-based-fs-trait">ADR-001: Path-based <code>Fs</code> trait</a></h2>
<p><strong>Decision:</strong> Backends implement a path-based trait aligned with <code>std::fs</code> method naming.</p>
<p><strong>Why:</strong> Filesystem operations are naturally path-oriented; a single, familiar trait surface is easier to implement and adopt than graph-store or inode models.</p>
<hr>
<h2 id="adr-002-two-crate-structure"><a class="header" href="#adr-002-two-crate-structure">ADR-002: Two-crate structure</a></h2>
<p><strong>Decision:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract: <code>Fs</code> trait, <code>Layer</code> trait, <code>FsExt</code>, types</td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware + ergonomics (<code>FileStorage&lt;M&gt;</code>, <code>BackendStack</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Why:</strong></p>
<ul>
<li>Backend authors only need <code>anyfs-backend</code> (no heavy dependencies).</li>
<li>Middleware is composable and lives with backends in <code>anyfs</code>.</li>
<li><code>FileStorage</code> is purely ergonomic - no policy logic - included in <code>anyfs</code> for convenience.</li>
</ul>
<hr>
<h2 id="adr-003-impl-asrefpath-for-all-path-parameters"><a class="header" href="#adr-003-impl-asrefpath-for-all-path-parameters">ADR-003: <code>impl AsRef&lt;Path&gt;</code> for all path parameters</a></h2>
<p><strong>Decision:</strong> Both <code>Fs</code> traits and <code>FileStorage</code> accept <code>impl AsRef&lt;Path&gt;</code> for all path parameters.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Aligned with <code>std::fs</code> API conventions.</li>
<li>Works across all platforms (not limited to UTF-8).</li>
<li>Ergonomic: accepts <code>&amp;str</code>, <code>String</code>, <code>&amp;Path</code>, <code>PathBuf</code>.</li>
</ul>
<hr>
<h2 id="adr-004-tower-style-middleware-pattern"><a class="header" href="#adr-004-tower-style-middleware-pattern">ADR-004: Tower-style middleware pattern</a></h2>
<p><strong>Decision:</strong> Use composable middleware (decorator pattern) for cross-cutting concerns like limits, logging, and feature gates. Each middleware implements <code>Fs</code> by wrapping another <code>Fs</code>.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Complete separation of concerns - each layer has one job.</li>
<li>Composable - use only what you need.</li>
<li>Familiar pattern (Axum/Tower use the same approach).</li>
<li>No code duplication - middleware written once, works with any backend.</li>
<li>Testable - each layer can be tested in isolation.</li>
</ul>
<p><strong>Example:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_symlinks()
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-005-stdfs-aligned-method-names"><a class="header" href="#adr-005-stdfs-aligned-method-names">ADR-005: <code>std::fs</code>-aligned method names</a></h2>
<p><strong>Decision:</strong> Prefer <code>read_dir</code>, <code>create_dir_all</code>, <code>remove_file</code>, etc.</p>
<p><strong>Why:</strong> Familiarity and reduced cognitive overhead.</p>
<hr>
<h2 id="adr-006-quota-for-quota-enforcement"><a class="header" href="#adr-006-quota-for-quota-enforcement">ADR-006: Quota for quota enforcement</a></h2>
<p><strong>Decision:</strong> Quota/limit enforcement is handled by <code>Quota&lt;B&gt;</code> middleware, not by backends or FileStorage.</p>
<p><strong>Configuration:</strong></p>
<ul>
<li><code>with_max_total_size(bytes)</code> - total storage limit</li>
<li><code>with_max_file_size(bytes)</code> - per-file limit</li>
<li><code>with_max_node_count(count)</code> - max files/directories</li>
<li><code>with_max_dir_entries(count)</code> - max entries per directory</li>
<li><code>with_max_path_depth(depth)</code> - max directory nesting</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Limits are policy, not storage semantics.</li>
<li>Written once, works with any backend.</li>
<li>Optional - users who don’t need limits skip this middleware.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>On construction, scan existing backend to initialize usage counters.</li>
<li>Wrap <code>open_write</code> streams with <code>CountingWriter</code> to track streamed bytes.</li>
<li>Check limits before operations, update usage after successful operations.</li>
</ul>
<hr>
<h2 id="adr-007-restrictions-for-opt-in-restrictions"><a class="header" href="#adr-007-restrictions-for-opt-in-restrictions">ADR-007: Restrictions for opt-in restrictions</a></h2>
<p><strong>Decision:</strong> By default, all operations work. <code>Restrictions&lt;B&gt;</code> middleware provides opt-in restrictions.</p>
<p><strong>Default behavior (no Restrictions):</strong></p>
<ul>
<li>All operations work: <code>symlink()</code>, <code>hard_link()</code>, <code>set_permissions()</code></li>
</ul>
<p><strong>Opt-in restrictions:</strong></p>
<ul>
<li><code>.deny_symlinks()</code> - block <code>symlink()</code> calls</li>
<li><code>.deny_hard_links()</code> - block <code>hard_link()</code> calls</li>
<li><code>.deny_permissions()</code> - block <code>set_permissions()</code> calls</li>
</ul>
<p>When blocked, operations return <code>FsError::FeatureNotEnabled</code>.</p>
<p><strong>Symlink following:</strong> Controlled separately via <code>set_follow_symlinks(bool)</code> on virtual backends. VRootFsBackend delegates to OS (strict-path prevents escapes).</p>
<p><strong>Why:</strong></p>
<ul>
<li>Simple default: everything works out of the box.</li>
<li>Security is opt-in via middleware composition.</li>
<li>Clear separation: Restrictions blocks operations, backend settings control behavior.</li>
</ul>
<hr>
<h2 id="adr-008-filestorage-as-thin-ergonomic-wrapper"><a class="header" href="#adr-008-filestorage-as-thin-ergonomic-wrapper">ADR-008: FileStorage as thin ergonomic wrapper</a></h2>
<p><strong>Decision:</strong> <code>FileStorage&lt;B, M&gt;</code> is a thin wrapper that provides std::fs-aligned ergonomics only. It contains NO policy logic.</p>
<p><strong>What it does:</strong></p>
<ul>
<li>Provides familiar method names</li>
<li>Accepts <code>impl AsRef&lt;Path&gt;</code> for convenience</li>
<li>Delegates all operations to the wrapped backend</li>
</ul>
<p><strong>What it does NOT do:</strong></p>
<ul>
<li>Quota enforcement (use Quota)</li>
<li>Feature gating (use Restrictions)</li>
<li>Instrumentation (use Tracing)</li>
<li>Any other policy</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Single responsibility - ergonomics only.</li>
<li>Users who don’t need ergonomics can use backends directly.</li>
<li>Policy is composable via middleware, not hardcoded.</li>
</ul>
<hr>
<h2 id="adr-009-built-in-backends-are-feature-gated"><a class="header" href="#adr-009-built-in-backends-are-feature-gated">ADR-009: Built-in backends are feature-gated</a></h2>
<p><strong>Decision:</strong> <code>anyfs</code> uses Cargo features so users only pull the dependencies they need.</p>
<ul>
<li><code>memory</code> (default)</li>
<li><code>sqlite</code> (optional)</li>
<li><code>vrootfs</code> (optional)</li>
</ul>
<p><strong>Why:</strong> Minimizes binary size and compile time for users who don’t need all backends.</p>
<hr>
<h2 id="adr-010-sync-first-async-ready-design"><a class="header" href="#adr-010-sync-first-async-ready-design">ADR-010: Sync-first, async-ready design</a></h2>
<p><strong>Decision:</strong> <code>Fs</code> traits are synchronous for v1. The API is designed to allow adding <code>AsyncFs</code> later without breaking changes.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>All built-in backends are naturally synchronous:
<ul>
<li><code>MemoryBackend</code> - in-memory, instant</li>
<li><code>SqliteBackend</code> - rusqlite is sync</li>
<li><code>VRootFsBackend</code> - std::fs is sync</li>
</ul>
</li>
<li>Sync is simpler - no runtime dependency (tokio/async-std)</li>
<li>Users can wrap sync backends in <code>spawn_blocking</code> if needed</li>
</ul>
<p><strong>Async-ready design principles:</strong></p>
<ul>
<li>Traits require <code>Send</code> - compatible with async executors</li>
<li>Return types are <code>Result&lt;T, FsError&gt;</code> - works with async</li>
<li>No internal blocking assumptions</li>
<li>Methods are stateless per-call - no hidden blocking state</li>
</ul>
<p><strong>Future async path (Option 2):</strong>
When async is needed (e.g., network-backed storage), add a parallel trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-backend
pub trait AsyncFs: Send + Sync {
    async fn read(&amp;self, path: impl AsRef&lt;Path&gt; + Send) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    async fn write(&amp;mut self, path: impl AsRef&lt;Path&gt; + Send, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    // ... mirrors Fs with async

    // Streaming uses AsyncRead/AsyncWrite
    async fn open_read(&amp;self, path: impl AsRef&lt;Path&gt; + Send)
        -&gt; Result&lt;Box&lt;dyn AsyncRead + Send + Unpin&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Migration notes:</strong></p>
<ul>
<li><code>AsyncFs</code> would be a separate trait, not replacing <code>Fs</code></li>
<li>Blanket impl possible: <code>impl&lt;T: Fs&gt; AsyncFs for T</code> using <code>spawn_blocking</code></li>
<li>Middleware would need async variants: <code>AsyncQuota&lt;B&gt;</code>, etc.</li>
<li>No breaking changes to existing sync API</li>
</ul>
<p><strong>Why not async now:</strong></p>
<ul>
<li>Complexity without benefit - all current backends are sync</li>
<li>Rust 1.75 makes async traits easy, so adding later is low-cost</li>
<li>Better to wait for real async backend requirements</li>
</ul>
<hr>
<h2 id="adr-011-layer-trait-for-standardized-composition"><a class="header" href="#adr-011-layer-trait-for-standardized-composition">ADR-011: Layer trait for standardized composition</a></h2>
<p><strong>Decision:</strong> Provide a <code>Layer</code> trait (inspired by Tower) that standardizes middleware composition.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Layer&lt;B: Fs&gt; {
    type Backend: Fs;
    fn layer(self, backend: B) -&gt; Self::Backend;
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li>Standardized composition pattern familiar to Tower/Axum users.</li>
<li>IDE autocomplete for available layers.</li>
<li>Enables <code>BackendStack</code> fluent builder in anyfs.</li>
<li>Each middleware provides a corresponding <code>*Layer</code> type.</li>
</ul>
<p><strong>Example:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::new().max_total_size(100_000))
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-012-tracing-for-instrumentation"><a class="header" href="#adr-012-tracing-for-instrumentation">ADR-012: Tracing for instrumentation</a></h2>
<p><strong>Decision:</strong> Use <code>Tracing&lt;B&gt;</code> integrated with the <code>tracing</code> ecosystem instead of a custom logging solution.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Works with existing tracing infrastructure (tracing-subscriber, OpenTelemetry, Jaeger).</li>
<li>Structured logging with spans for each operation.</li>
<li>Users choose their subscriber - no logging framework lock-in.</li>
<li>Consistent with modern Rust ecosystem practices.</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>backend.layer(TracingLayer::new()
    .with_target("anyfs")
    .with_level(tracing::Level::DEBUG))
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-013-fsext-for-extension-methods"><a class="header" href="#adr-013-fsext-for-extension-methods">ADR-013: FsExt for extension methods</a></h2>
<p><strong>Decision:</strong> Provide <code>FsExt</code> trait with convenience methods, auto-implemented for all backends.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsExt: Fs {
    fn is_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;
    fn is_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;

    // JSON methods require `serde` feature
    #[cfg(feature = "serde")]
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, FsError&gt;;
    #[cfg(feature = "serde")]
    fn write_json&lt;T: Serialize&gt;(&amp;mut self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), FsError&gt;;
}

impl&lt;B: Fs&gt; FsExt for B {}
<span class="boring">}</span></code></pre>
<p><strong>Feature gating:</strong></p>
<ul>
<li><code>is_file()</code> and <code>is_dir()</code> are always available.</li>
<li><code>read_json()</code> and <code>write_json()</code> require <code>anyfs-backend = { features = ["serde"] }</code>.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Adds convenience without bloating <code>Fs</code> trait.</li>
<li>Blanket impl means all backends get these methods for free.</li>
<li>Users can define their own extension traits for domain-specific operations.</li>
<li>Follows Rust convention (e.g., <code>IteratorExt</code>, <code>StreamExt</code>).</li>
<li>Serde is optional - users who don’t need JSON avoid the dependency.</li>
</ul>
<hr>
<h2 id="adr-014-optional-bytes-support"><a class="header" href="#adr-014-optional-bytes-support">ADR-014: Optional Bytes support</a></h2>
<p><strong>Decision:</strong> Support the <code>bytes</code> crate via an optional feature for zero-copy efficiency.</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["bytes"] }
</code></pre>
<p><strong>Why:</strong></p>
<ul>
<li><code>Bytes</code> provides O(1) slicing via reference counting.</li>
<li>Beneficial for large file handling, network backends, streaming.</li>
<li>Optional - users who don’t need it avoid the dependency.</li>
<li>Default remains <code>Vec&lt;u8&gt;</code> for simplicity.</li>
</ul>
<p><strong>Implementation:</strong> Use a type alias to avoid breaking API:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-backend/src/types.rs

#[cfg(feature = "bytes")]
pub type FileContent = bytes::Bytes;

#[cfg(not(feature = "bytes"))]
pub type FileContent = Vec&lt;u8&gt;;

// In trait definition
pub trait FsRead: Send {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;FileContent, FsError&gt;;
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Middleware compatibility:</strong> Middleware passes <code>FileContent</code> through unchanged. No special handling needed - both <code>Vec&lt;u8&gt;</code> and <code>Bytes</code> implement <code>AsRef&lt;[u8]&gt;</code> and <code>Deref&lt;Target=[u8]&gt;</code>.</p>
<hr>
<h2 id="adr-015-contextual-fserror"><a class="header" href="#adr-015-contextual-fserror">ADR-015: Contextual FsError</a></h2>
<p><strong>Decision:</strong> <code>FsError</code> variants include context for better debugging.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FsError::NotFound {
    path: PathBuf,
    operation: &amp;'static str,  // "read", "metadata", etc.
}

FsError::QuotaExceeded {
    limit: u64,
    requested: u64,
    usage: u64,
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li>Error messages include enough context to understand what failed.</li>
<li>No need for separate error context crate (like anyhow) for basic usage.</li>
<li>Operation field helps distinguish “file not found during read” vs “during metadata”.</li>
<li>Quota errors include all relevant numbers for debugging.</li>
</ul>
<hr>
<h2 id="adr-016-pathfilter-for-path-based-access-control"><a class="header" href="#adr-016-pathfilter-for-path-based-access-control">ADR-016: PathFilter for path-based access control</a></h2>
<p><strong>Decision:</strong> Provide <code>PathFilter&lt;B&gt;</code> middleware for glob-based path access control.</p>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PathFilterLayer::builder()
    .allow("/workspace/**")    // Allow workspace access
    .deny("**/.env")           // Deny .env files anywhere
    .deny("**/secrets/**")     // Deny secrets directories
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Rules are evaluated in order; first match wins.</li>
<li>If no rules match, access is denied (deny by default).</li>
<li>Uses glob patterns (e.g., <code>**</code> for recursive, <code>*</code> for single segment).</li>
<li>Returns <code>FsError::AccessDenied</code> for denied paths.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Essential for AI agent sandboxing - restrict to specific directories.</li>
<li>Prevents access to sensitive files (.env, secrets, credentials).</li>
<li>Separate from backend - works with any backend.</li>
<li>Inspired by AgentFS and similar AI sandbox patterns.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Use <code>globset</code> crate for efficient glob pattern matching.</li>
<li><code>read_dir</code> filters out denied entries from results (don’t expose existence of denied files).</li>
<li>Check path at operation start, then delegate to inner backend.</li>
</ul>
<hr>
<h2 id="adr-017-readonly-for-preventing-writes"><a class="header" href="#adr-017-readonly-for-preventing-writes">ADR-017: ReadOnly for preventing writes</a></h2>
<p><strong>Decision:</strong> Provide <code>ReadOnly&lt;B&gt;</code> middleware that blocks all write operations.</p>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let readonly_fs = ReadOnly::new(backend);
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>All read operations pass through to inner backend.</li>
<li>All write operations return <code>FsError::ReadOnly</code>.</li>
<li>Simple, no configuration needed.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Safe browsing of container contents without modification risk.</li>
<li>Useful for debugging, inspection, auditing.</li>
<li>Simpler than configuring Restrictions for read-only use case.</li>
</ul>
<hr>
<h2 id="adr-018-ratelimit-for-operation-throttling"><a class="header" href="#adr-018-ratelimit-for-operation-throttling">ADR-018: RateLimit for operation throttling</a></h2>
<p><strong>Decision:</strong> Provide <code>RateLimit&lt;B&gt;</code> middleware to limit operations per time window.</p>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RateLimitLayer::builder()
    .max_ops(1000)
    .per_second()
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Tracks operation count in sliding time window.</li>
<li>Returns <code>FsError::RateLimitExceeded</code> when limit exceeded.</li>
<li>Counter resets after window expires.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Protects against runaway processes consuming resources.</li>
<li>Essential for multi-tenant environments.</li>
<li>Prevents denial-of-service from misbehaving code.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Use <code>std::time::Instant</code> for timing.</li>
<li>Store window start time and counter; reset when window expires.</li>
<li>Count operation calls (including <code>open_read</code>/<code>open_write</code>), not bytes transferred.</li>
<li>Return error immediately when limit exceeded (no blocking/waiting).</li>
</ul>
<hr>
<h2 id="adr-019-dryrun-for-testing-and-debugging"><a class="header" href="#adr-019-dryrun-for-testing-and-debugging">ADR-019: DryRun for testing and debugging</a></h2>
<p><strong>Decision:</strong> Provide <code>DryRun&lt;B&gt;</code> middleware that logs write operations without executing them.</p>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut dry_run = DryRun::new(backend);
dry_run.write("/test.txt", b"hello")?;  // Logged but not written
let ops = dry_run.operations();         // ["write /test.txt (5 bytes)"]
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Read operations execute normally against inner backend.</li>
<li>Write operations are logged but return <code>Ok(())</code> without executing.</li>
<li>Operations log can be inspected for verification.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Test code paths without side effects.</li>
<li>Debug complex operation sequences.</li>
<li>Audit what would happen before committing.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Read operations delegate to inner backend (test against real state).</li>
<li>Write operations log and return <code>Ok(())</code> without executing.</li>
<li><code>open_write</code> returns <code>std::io::sink()</code> - writes are discarded.</li>
<li>Useful for: “What would this code do?” not “Run this in isolation.”</li>
</ul>
<hr>
<h2 id="adr-020-cache-for-read-performance"><a class="header" href="#adr-020-cache-for-read-performance">ADR-020: Cache for read performance</a></h2>
<p><strong>Decision:</strong> Provide <code>Cache&lt;B&gt;</code> middleware with LRU caching for read operations.</p>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CacheLayer::builder()
    .max_entries(1000)
    .max_entry_size(1024 * 1024)  // 1MB max per entry
    .ttl(Duration::from_secs(60))
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Read operations check cache first, populate on miss.</li>
<li>Write operations invalidate relevant cache entries.</li>
<li>LRU eviction when max entries exceeded.</li>
<li>TTL-based expiration for freshness.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Improves performance for repeated reads.</li>
<li>Reduces load on underlying backend (especially for SQLite/network).</li>
<li>Configurable to balance memory vs performance.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Cache bulk reads only: <code>read()</code>, <code>read_to_string()</code>, <code>read_range()</code>, <code>metadata()</code>, <code>exists()</code>.</li>
<li>Do NOT cache <code>open_read()</code> - streams are for large files that shouldn’t be cached.</li>
<li>Invalidate cache entry on any write to that path.</li>
<li>Use <code>lru</code> crate or similar for LRU eviction.</li>
<li>Check TTL on cache hits; evict expired entries.</li>
</ul>
<hr>
<h2 id="adr-021-overlay-for-union-filesystem"><a class="header" href="#adr-021-overlay-for-union-filesystem">ADR-021: Overlay for union filesystem</a></h2>
<p><strong>Decision:</strong> Provide <code>Overlay&lt;B1, B2&gt;</code> middleware for copy-on-write layered filesystems.</p>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let base = SqliteBackend::open("base.db")?;  // Read-only base
let upper = MemoryBackend::new();             // Writable upper layer

let overlay = Overlay::new(base, upper);
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Read: check upper layer first, fall back to base if not found.</li>
<li>Write: always to upper layer (copy-on-write).</li>
<li>Delete: create whiteout marker in upper layer (file appears deleted but base unchanged).</li>
<li>Directory listing: merge results from both layers.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Docker-like layered filesystem for containers.</li>
<li>Base image with per-instance modifications.</li>
<li>Testing with isolated changes over shared baseline.</li>
<li>Inspired by OverlayFS and VFS crate patterns.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Whiteout convention: <code>.wh.&lt;filename&gt;</code> marks deleted files from base layer.</li>
<li><code>read_dir</code> must merge results from both layers, excluding whiteouts and whited-out files.</li>
<li><code>exists</code> checks upper first, then base (respecting whiteouts).</li>
<li>All writes go to upper layer; base is never modified.</li>
<li>Consider <code>opaque</code> directories (<code>.wh..wh..opq</code>) to hide entire base directories.</li>
</ul>
<hr>
<h2 id="adr-022-builder-pattern-for-configurable-middleware"><a class="header" href="#adr-022-builder-pattern-for-configurable-middleware">ADR-022: Builder pattern for configurable middleware</a></h2>
<p><strong>Decision:</strong> Middleware that requires configuration MUST use a builder pattern that prevents construction without meaningful values. <code>::new()</code> constructors are NOT allowed for middleware where a default configuration is nonsensical.</p>
<p><strong>Problem:</strong> A constructor like <code>QuotaLayer::new()</code> raises the question: “What quota?” An unlimited quota is pointless - you wouldn’t use <code>QuotaLayer</code> at all. Similarly, <code>RestrictionsLayer::new()</code> with no restrictions, <code>PathFilterLayer::new()</code> with no rules, and <code>RateLimitLayer::new()</code> with no rate limit are all nonsensical.</p>
<p><strong>Solution:</strong> Use builders that enforce at least one meaningful configuration:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// QuotaLayer - requires at least one limit
let quota = QuotaLayer::builder()
    .max_total_size(100 * 1024 * 1024)
    .build();

// Can also set multiple limits
let quota = QuotaLayer::builder()
    .max_total_size(1_000_000)
    .max_file_size(100_000)
    .max_node_count(1000)
    .build();

// RestrictionsLayer - requires at least one restriction
let restrictions = RestrictionsLayer::builder()
    .deny_symlinks()
    .build();

// PathFilterLayer - requires at least one rule
let filter = PathFilterLayer::builder()
    .allow("/workspace/**")
    .deny("**/.env")
    .build();

// RateLimitLayer - requires rate limit parameters
let rate_limit = RateLimitLayer::builder()
    .max_ops(1000)
    .per_second()
    .build();

// CacheLayer - requires cache configuration
let cache = CacheLayer::builder()
    .max_entries(1000)
    .build();
<span class="boring">}</span></code></pre>
<p><strong>Middleware that MAY keep <code>::new()</code>:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td><code>TracingLayer</code></td><td>Default (global tracing subscriber) is meaningful</td></tr>
<tr><td><code>ReadOnlyLayer</code></td><td>No configuration needed</td></tr>
<tr><td><code>DryRunLayer</code></td><td>No configuration needed</td></tr>
<tr><td><code>OverlayLayer</code></td><td>Takes two backends as required params: <code>Overlay::new(lower, upper)</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Implementation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder with typestate pattern for compile-time enforcement
pub struct QuotaLayerBuilder&lt;State = Unconfigured&gt; {
    max_total_size: Option&lt;u64&gt;,
    max_file_size: Option&lt;u64&gt;,
    max_node_count: Option&lt;u64&gt;,
    _state: PhantomData&lt;State&gt;,
}

pub struct Unconfigured;
pub struct Configured;

impl QuotaLayerBuilder&lt;Unconfigured&gt; {
    pub fn max_total_size(mut self, bytes: u64) -&gt; QuotaLayerBuilder&lt;Configured&gt; {
        self.max_total_size = Some(bytes);
        QuotaLayerBuilder {
            max_total_size: self.max_total_size,
            max_file_size: self.max_file_size,
            max_node_count: self.max_node_count,
            _state: PhantomData,
        }
    }

    pub fn max_file_size(mut self, bytes: u64) -&gt; QuotaLayerBuilder&lt;Configured&gt; {
        // Similar transition to Configured state
    }

    pub fn max_node_count(mut self, count: u64) -&gt; QuotaLayerBuilder&lt;Configured&gt; {
        // Similar transition to Configured state
    }

    // Note: NO build() method on Unconfigured state!
}

impl QuotaLayerBuilder&lt;Configured&gt; {
    // Additional configuration methods stay in Configured state
    pub fn max_total_size(mut self, bytes: u64) -&gt; Self {
        self.max_total_size = Some(bytes);
        self
    }

    // Only Configured state has build()
    pub fn build(self) -&gt; QuotaLayer {
        QuotaLayer { /* ... */ }
    }
}

impl QuotaLayer {
    pub fn builder() -&gt; QuotaLayerBuilder&lt;Unconfigured&gt; {
        QuotaLayerBuilder {
            max_total_size: None,
            max_file_size: None,
            max_node_count: None,
            _state: PhantomData,
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li><strong>Compile-time safety:</strong> Invalid configurations don’t compile.</li>
<li><strong>Self-documenting API:</strong> Users must explicitly choose configuration.</li>
<li><strong>No meaningless defaults:</strong> Eliminates “what does this default to?” confusion.</li>
<li><strong>IDE guidance:</strong> Autocomplete shows required methods before <code>build()</code>.</li>
<li><strong>Familiar pattern:</strong> Rust builders are idiomatic and widely understood.</li>
</ul>
<p><strong>Error prevention:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't compile - no build() on Unconfigured
let quota = QuotaLayer::builder().build();  // ❌ Error!

// This compiles - at least one limit set
let quota = QuotaLayer::builder()
    .max_total_size(1_000_000)
    .build();  // ✅ OK
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-023-interior-mutability-for-all-trait-methods"><a class="header" href="#adr-023-interior-mutability-for-all-trait-methods">ADR-023: Interior mutability for all trait methods</a></h2>
<p><strong>Decision:</strong> All <code>Fs</code> trait methods use <code>&amp;self</code>, not <code>&amp;mut self</code>. Backends manage their own synchronization internally (interior mutability).</p>
<p><strong>Previous design:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
}

pub trait FsWrite: Send {
    fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>New design:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
}

pub trait FsWrite: Send + Sync {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ol>
<li>
<p><strong>Filesystems are conceptually always mutable.</strong> A filesystem doesn’t become “borrowed” when you write to it - the underlying storage manages concurrency itself.</p>
</li>
<li>
<p><strong>Enables concurrent access patterns.</strong> With <code>&amp;mut self</code>, you cannot have concurrent readers and writers even when the backend supports it (e.g., SQLite with WAL mode, real filesystems).</p>
</li>
<li>
<p><strong>Matches real-world filesystem semantics.</strong> <code>std::fs::write()</code> takes a path, not a mutable reference to some filesystem object. Files are shared resources.</p>
</li>
<li>
<p><strong>Simplifies middleware implementation.</strong> Middleware no longer needs to worry about propagating mutability - all operations use <code>&amp;self</code>.</p>
</li>
<li>
<p><strong>Common pattern in Rust.</strong> Many I/O abstractions use interior mutability: <code>std::io::Write</code> for <code>File</code> (via OS handles), <code>tokio::fs</code>, database connection pools, etc.</p>
</li>
</ol>
<p><strong>Implementation:</strong></p>
<p>Backends use appropriate synchronization primitives:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MemoryBackend {
    // Interior mutability via Mutex/RwLock
    data: RwLock&lt;HashMap&lt;PathBuf, Vec&lt;u8&gt;&gt;&gt;,
}

impl FsWrite for MemoryBackend {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let mut guard = self.data.write().unwrap();
        guard.insert(path.as_ref().to_path_buf(), data.to_vec());
        Ok(())
    }
}

pub struct SqliteBackend {
    // SQLite handles its own locking
    conn: Connection,  // rusqlite::Connection is internally synchronized
}
<span class="boring">}</span></code></pre>
<p><strong>Trade-offs:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>&amp;mut self</th><th>&amp;self (interior mutability)</th></tr>
</thead>
<tbody>
<tr><td>Compile-time safety</td><td>Single writer enforced</td><td>Runtime synchronization</td></tr>
<tr><td>Concurrent access</td><td>Not possible</td><td>Backend decides</td></tr>
<tr><td>API simplicity</td><td>Simple</td><td>Slightly more complex backends</td></tr>
<tr><td>Real-world match</td><td>Poor</td><td>Good</td></tr>
</tbody>
</table>
</div>
<p><strong>Conclusion:</strong> The benefits of matching filesystem semantics and enabling concurrent access outweigh the loss of compile-time single-writer enforcement. Backends are responsible for their own thread safety.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="layered-traits-anyfs-backend"><a class="header" href="#layered-traits-anyfs-backend">Layered Traits (anyfs-backend)</a></h1>
<p>AnyFS uses a <strong>layered trait architecture</strong> for maximum flexibility with minimal complexity.</p>
<hr>
<h2 id="trait-hierarchy"><a class="header" href="#trait-hierarchy">Trait Hierarchy</a></h2>
<pre><code>                    FsPosix
                       │
        ┌──────────────┼──────────────┐
        │              │              │
   FsHandles       FsLock        FsXattr
        │              │              │
        └──────────────┼──────────────┘
                       │
                    FsFuse
                       │
                   FsInode
                       │
                    FsFull
                       │
        ┌──────┬───────┼───────┬──────┐
        │      │       │       │      │
   FsLink   FsPerm  FsSync  FsStats   │
        │      │       │       │      │
        └──────┴───────┼───────┴──────┘
                       │
                      Fs   ← Most users only need this
                       │
           ┌───────────┼───────────┐
           │           │           │
        FsRead      FsWrite     FsDir
</code></pre>
<p><strong>Simple rule:</strong> Import <code>Fs</code> for basic use. Add traits as needed for advanced features.</p>
<hr>
<h2 id="layer-1-core-traits-required"><a class="header" href="#layer-1-core-traits-required">Layer 1: Core Traits (Required)</a></h2>
<h3 id="fsread"><a class="header" href="#fsread">FsRead</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, FsError&gt;;
    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;
    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt;;
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fswrite"><a class="header" href="#fswrite">FsWrite</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsWrite: Send + Sync {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn append(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn rename(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn copy(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn truncate(&amp;self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), FsError&gt;;
    fn open_write(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fsdir"><a class="header" href="#fsdir">FsDir</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsDir: Send + Sync {
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt;;
    fn create_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn create_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-2-extended-traits-optional"><a class="header" href="#layer-2-extended-traits-optional">Layer 2: Extended Traits (Optional)</a></h2>
<h3 id="fslink"><a class="header" href="#fslink">FsLink</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsLink: Send + Sync {
    fn symlink(&amp;self, target: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn hard_link(&amp;self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fspermissions"><a class="header" href="#fspermissions">FsPermissions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsPermissions: Send + Sync {
    fn set_permissions(&amp;self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fssync"><a class="header" href="#fssync">FsSync</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsSync: Send + Sync {
    fn sync(&amp;self) -&gt; Result&lt;(), FsError&gt;;
    fn fsync(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fsstats"><a class="header" href="#fsstats">FsStats</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsStats: Send + Sync {
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-3-inode-trait-for-fuse"><a class="header" href="#layer-3-inode-trait-for-fuse">Layer 3: Inode Trait (For FUSE)</a></h2>
<h3 id="fsinode"><a class="header" href="#fsinode">FsInode</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsInode: Send + Sync {
    fn path_to_inode(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;u64, FsError&gt;;
    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn lookup(&amp;self, parent_inode: u64, name: &amp;OsStr) -&gt; Result&lt;u64, FsError&gt;;
    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-4-posix-traits-full-posix"><a class="header" href="#layer-4-posix-traits-full-posix">Layer 4: POSIX Traits (Full POSIX)</a></h2>
<h3 id="posix-types"><a class="header" href="#posix-types">POSIX Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Opaque file handle (inode-based for efficiency)
pub struct Handle(pub u64);

/// File open flags (mirrors POSIX)
#[derive(Clone, Copy, Debug)]
pub struct OpenFlags {
    pub read: bool,
    pub write: bool,
    pub create: bool,
    pub truncate: bool,
    pub append: bool,
}

impl OpenFlags {
    pub const READ: Self = Self { read: true, write: false, create: false, truncate: false, append: false };
    pub const WRITE: Self = Self { read: false, write: true, create: true, truncate: true, append: false };
    pub const READ_WRITE: Self = Self { read: true, write: true, create: false, truncate: false, append: false };
    pub const APPEND: Self = Self { read: false, write: true, create: true, truncate: false, append: true };
}

/// File lock type (mirrors POSIX flock)
#[derive(Clone, Copy, Debug)]
pub enum LockType {
    Shared,     // Multiple readers
    Exclusive,  // Single writer
}
<span class="boring">}</span></code></pre>
<h3 id="fshandles"><a class="header" href="#fshandles">FsHandles</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsHandles: Send + Sync {
    fn open(&amp;self, path: impl AsRef&lt;Path&gt;, flags: OpenFlags) -&gt; Result&lt;Handle, FsError&gt;;
    fn read_at(&amp;self, handle: Handle, buf: &amp;mut [u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn write_at(&amp;self, handle: Handle, data: &amp;[u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn close(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fslock"><a class="header" href="#fslock">FsLock</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsLock: Send + Sync {
    fn lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;(), FsError&gt;;
    fn try_lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;bool, FsError&gt;;
    fn unlock(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fsxattr"><a class="header" href="#fsxattr">FsXattr</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsXattr: Send + Sync {
    fn get_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn set_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str, value: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str) -&gt; Result&lt;(), FsError&gt;;
    fn list_xattr(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;String&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="convenience-supertraits"><a class="header" href="#convenience-supertraits">Convenience Supertraits</a></h2>
<p>These are automatically implemented via blanket impls:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Basic filesystem - covers 90% of use cases
pub trait Fs: FsRead + FsWrite + FsDir {}
impl&lt;T: FsRead + FsWrite + FsDir&gt; Fs for T {}

/// Full filesystem with all std::fs features
pub trait FsFull: Fs + FsLink + FsPermissions + FsSync + FsStats {}
impl&lt;T: Fs + FsLink + FsPermissions + FsSync + FsStats&gt; FsFull for T {}

/// FUSE-mountable filesystem
pub trait FsFuse: FsFull + FsInode {}
impl&lt;T: FsFull + FsInode&gt; FsFuse for T {}

/// Full POSIX filesystem
pub trait FsPosix: FsFuse + FsHandles + FsLock + FsXattr {}
impl&lt;T: FsFuse + FsHandles + FsLock + FsXattr&gt; FsPosix for T {}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="when-to-use-each-level"><a class="header" href="#when-to-use-each-level">When to Use Each Level</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Trait</th><th>Use When</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>Fs</code></td><td>Basic file operations (read, write, dirs)</td></tr>
<tr><td>2</td><td><code>FsFull</code></td><td>Need links, permissions, sync, or stats</td></tr>
<tr><td>3</td><td><code>FsFuse</code></td><td>FUSE mounting or hardlink support</td></tr>
<tr><td>4</td><td><code>FsPosix</code></td><td>Full POSIX (file handles, locks, xattr)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="implementing-functions"><a class="header" href="#implementing-functions">Implementing Functions</a></h2>
<p>Use trait bounds to specify requirements:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Works with any backend
fn process_files(fs: &amp;impl Fs) -&gt; Result&lt;(), FsError&gt; {
    let data = fs.read("/input.txt")?;
    fs.write("/output.txt", &amp;data)?;
    Ok(())
}

// Requires link support
fn create_backup(fs: &amp;(impl Fs + FsLink)) -&gt; Result&lt;(), FsError&gt; {
    fs.hard_link("/data.txt", "/data.txt.bak")?;
    Ok(())
}

// Requires FUSE-level support
fn mount_filesystem(fs: impl FsFuse) -&gt; Result&lt;(), FsError&gt; {
    anyfs_mount::FuseMount::mount(fs, "/mnt/myfs")?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="extension-trait"><a class="header" href="#extension-trait">Extension Trait</a></h2>
<p><code>FsExt</code> provides convenience methods for any <code>Fs</code> backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsExt: Fs {
    /// Check if path is a file.
    fn is_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;

    /// Check if path is a directory.
    fn is_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;

    /// JSON methods (require `serde` feature in anyfs-backend)
    #[cfg(feature = "serde")]
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, FsError&gt;;
    #[cfg(feature = "serde")]
    fn write_json&lt;T: Serialize&gt;(&amp;self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), FsError&gt;;
}

// Blanket implementation
impl&lt;B: Fs&gt; FsExt for B {}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="filestorageb-m-anyfs"><a class="header" href="#filestorageb-m-anyfs">FileStorage&lt;B, M&gt; (anyfs)</a></h1>
<p><strong>Zero-cost ergonomic wrapper for std::fs-aligned API</strong></p>
<hr>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><code>FileStorage&lt;B, M&gt;</code> is a <strong>thin wrapper</strong> that provides a familiar std::fs-aligned API with:</p>
<ul>
<li><strong><code>B</code></strong> - Backend type (generic, zero-cost)</li>
<li><strong><code>M</code></strong> - Optional marker type for compile-time safety</li>
</ul>
<p><strong>Axum-style design:</strong> Zero-cost by default, type erasure opt-in.</p>
<p><strong>It does TWO things:</strong></p>
<ol>
<li>Ergonomics (std::fs-aligned API)</li>
<li>Optional type-safety via marker types</li>
</ol>
<p>All policy (limits, feature gates, logging) is handled by middleware, not FileStorage.</p>
<hr>
<h2 id="creating-a-container"><a class="header" href="#creating-a-container">Creating a Container</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FileStorage};

// Simple: just ergonomics (type inferred)
let fs = FileStorage::new(MemoryBackend::new());
<span class="boring">}</span></code></pre>
<p>With middleware (layer-based):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, FileStorage};

// Type is inferred - no need to write it out
let fs = FileStorage::new(
    SqliteBackend::open("data.db")?
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .build())
        .layer(RestrictionsLayer::builder()
            .deny_hard_links()
            .deny_permissions()
            .build())
);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="marker-types-compile-time-safety"><a class="header" href="#marker-types-compile-time-safety">Marker Types (Compile-Time Safety)</a></h2>
<p>Use <code>_</code> to infer the backend type while specifying the marker:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, FileStorage};

// Define marker types for your domains
struct Sandbox;
struct UserData;

// Specify marker in type annotation, infer backend with _
let sandbox: FileStorage&lt;_, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
let userdata: FileStorage&lt;_, UserData&gt; = FileStorage::new(SqliteBackend::open("data.db")?);

// Type-safe function signatures prevent mixing containers
fn process_sandbox(fs: &amp;FileStorage&lt;impl Fs, Sandbox&gt;) {
    // Can only accept Sandbox-marked containers
}

fn save_user_file(fs: &amp;mut FileStorage&lt;impl Fs, UserData&gt;, name: &amp;str, data: &amp;[u8]) {
    // Can only accept UserData-marked containers
}

// Compile-time safety:
process_sandbox(&amp;sandbox);   // OK
process_sandbox(&amp;userdata);  // Compile error! Type mismatch
<span class="boring">}</span></code></pre>
<h3 id="self-documenting-types-1"><a class="header" href="#self-documenting-types-1">Self-Documenting Types</a></h3>
<p>Both dimensions are meaningful:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FileStorage&lt;SqliteBackend, TenantA&gt;   // SQLite storage for TenantA
FileStorage&lt;MemoryBackend, Sandbox&gt;   // In-memory sandbox
FileStorage&lt;StdFsBackend, Production&gt; // Real filesystem, production
<span class="boring">}</span></code></pre>
<h3 id="type-aliases-for-clean-code-1"><a class="header" href="#type-aliases-for-clean-code-1">Type Aliases for Clean Code</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define your standard secure stack
type SecureBackend = Tracing&lt;Restrictions&lt;Quota&lt;SqliteBackend&gt;&gt;&gt;;

// Type aliases for common combinations
type SandboxFs = FileStorage&lt;MemoryBackend, Sandbox&gt;;
type UserDataFs = FileStorage&lt;SecureBackend, UserData&gt;;
type TenantFs&lt;T&gt; = FileStorage&lt;SecureBackend, T&gt;;

// Now signatures are clean AND informative
fn run_agent(fs: &amp;mut SandboxFs) { ... }
fn save_document(fs: &amp;mut UserDataFs, doc: &amp;Document) { ... }
<span class="boring">}</span></code></pre>
<h3 id="when-to-use-markers"><a class="header" href="#when-to-use-markers">When to Use Markers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Use Markers?</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>Single container</td><td>No</td><td><code>FileStorage&lt;B&gt;</code> is sufficient</td></tr>
<tr><td>Multiple containers, same type</td><td><strong>Yes</strong></td><td>Prevent accidental mixing</td></tr>
<tr><td>Multi-tenant systems</td><td><strong>Yes</strong></td><td>Compile-time tenant isolation</td></tr>
<tr><td>Sandbox + user data</td><td><strong>Yes</strong></td><td>Never write user data to sandbox</td></tr>
<tr><td>Testing</td><td>Maybe</td><td>Tag test vs production containers</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="stdfs-aligned-methods"><a class="header" href="#stdfs-aligned-methods">std::fs-aligned Methods</a></h2>
<p>FileStorage mirrors std::fs naming:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FileStorage</th><th>std::fs</th></tr>
</thead>
<tbody>
<tr><td><code>read()</code></td><td><code>std::fs::read</code></td></tr>
<tr><td><code>read_to_string()</code></td><td><code>std::fs::read_to_string</code></td></tr>
<tr><td><code>write()</code></td><td><code>std::fs::write</code></td></tr>
<tr><td><code>read_dir()</code></td><td><code>std::fs::read_dir</code></td></tr>
<tr><td><code>create_dir()</code></td><td><code>std::fs::create_dir</code></td></tr>
<tr><td><code>create_dir_all()</code></td><td><code>std::fs::create_dir_all</code></td></tr>
<tr><td><code>remove_file()</code></td><td><code>std::fs::remove_file</code></td></tr>
<tr><td><code>remove_dir()</code></td><td><code>std::fs::remove_dir</code></td></tr>
<tr><td><code>remove_dir_all()</code></td><td><code>std::fs::remove_dir_all</code></td></tr>
<tr><td><code>rename()</code></td><td><code>std::fs::rename</code></td></tr>
<tr><td><code>copy()</code></td><td><code>std::fs::copy</code></td></tr>
<tr><td><code>metadata()</code></td><td><code>std::fs::metadata</code></td></tr>
<tr><td><code>symlink_metadata()</code></td><td><code>std::fs::symlink_metadata</code></td></tr>
<tr><td><code>read_link()</code></td><td><code>std::fs::read_link</code></td></tr>
<tr><td><code>set_permissions()</code></td><td><code>std::fs::set_permissions</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="what-filestorage-does-not-do"><a class="header" href="#what-filestorage-does-not-do">What FileStorage Does NOT Do</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Use Instead</th></tr>
</thead>
<tbody>
<tr><td>Quota enforcement</td><td><code>Quota&lt;B&gt;</code></td></tr>
<tr><td>Feature gating</td><td><code>Restrictions&lt;B&gt;</code></td></tr>
<tr><td>Audit logging</td><td><code>Tracing&lt;B&gt;</code></td></tr>
<tr><td>Path containment</td><td>Backend-specific (VRootFsBackend)</td></tr>
</tbody>
</table>
</div>
<p>FileStorage is <strong>purely ergonomic</strong>. If you need policy, compose middleware.</p>
<hr>
<h2 id="filestorage-implementation-1"><a class="header" href="#filestorage-implementation-1">FileStorage Implementation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;
use anyfs_backend::Fs;

/// Zero-cost ergonomic wrapper.
/// Generic over backend (B) and marker (M).
pub struct FileStorage&lt;B, M = ()&gt; {
    backend: B,
    _marker: PhantomData&lt;M&gt;,
}

impl&lt;B: Fs, M&gt; FileStorage&lt;B, M&gt; {
    /// Create a new FileStorage.
    /// Marker type is specified via type annotation:
    /// `let fs: FileStorage&lt;_, MyMarker&gt; = FileStorage::new(backend);`
    pub fn new(backend: B) -&gt; Self {
        FileStorage { backend, _marker: PhantomData }
    }

    /// Type-erase the backend for simpler types (opt-in boxing).
    pub fn boxed(self) -&gt; FileStorage&lt;Box&lt;dyn Fs&gt;, M&gt; {
        FileStorage { backend: Box::new(self.backend), _marker: PhantomData }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="type-erasure-opt-in-1"><a class="header" href="#type-erasure-opt-in-1">Type Erasure (Opt-in)</a></h2>
<p>When you need simpler types (e.g., storing in collections), use <code>.boxed()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, FileStorage, Fs};

// Type-erased for uniform storage
let filesystems: Vec&lt;FileStorage&lt;Box&lt;dyn Fs&gt;&gt;&gt; = vec![
    FileStorage::new(MemoryBackend::new()).boxed(),
    FileStorage::new(SqliteBackend::open("a.db")?).boxed(),
    FileStorage::new(SqliteBackend::open("b.db")?).boxed(),
];

// Or use type alias
type DynFileStorage&lt;M = ()&gt; = FileStorage&lt;Box&lt;dyn Fs&gt;, M&gt;;
<span class="boring">}</span></code></pre>
<p><strong>When to use <code>.boxed()</code>:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Situation</th><th>Use Generic</th><th>Use <code>.boxed()</code></th></tr>
</thead>
<tbody>
<tr><td>Local variables</td><td>Yes</td><td>No</td></tr>
<tr><td>Function params</td><td>Yes (<code>impl Fs</code>)</td><td>No</td></tr>
<tr><td>Return types</td><td>Yes (<code>impl Fs</code>)</td><td>No</td></tr>
<tr><td>Collections of mixed backends</td><td>No</td><td><strong>Yes</strong></td></tr>
<tr><td>Struct fields (want simple type)</td><td>Maybe</td><td><strong>Yes</strong></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="direct-backend-access"><a class="header" href="#direct-backend-access">Direct Backend Access</a></h2>
<p>If you don’t need the wrapper, use backends directly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, Fs};

let backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build());

// Use Fs trait methods directly
backend.write("/file.txt", b"data")?;
<span class="boring">}</span></code></pre>
<p><code>FileStorage&lt;B, M&gt;</code> is part of the <code>anyfs</code> crate, not a separate crate.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="which-crate-should-i-use"><a class="header" href="#which-crate-should-i-use">Which Crate Should I Use?</a></h1>
<hr>
<h2 id="decision-guide"><a class="header" href="#decision-guide">Decision Guide</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>You want to…</th><th>Use</th></tr>
</thead>
<tbody>
<tr><td>Build an application</td><td><code>anyfs</code></td></tr>
<tr><td>Use built-in backends (Memory, SQLite, VRootFs)</td><td><code>anyfs</code></td></tr>
<tr><td>Use built-in middleware (Quota, PathFilter, etc.)</td><td><code>anyfs</code></td></tr>
<tr><td>Implement a custom backend</td><td><code>anyfs-backend</code> only</td></tr>
<tr><td>Implement custom middleware</td><td><code>anyfs-backend</code> only</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="quick-examples"><a class="header" href="#quick-examples">Quick Examples</a></h2>
<h3 id="simple-usage"><a class="header" href="#simple-usage">Simple usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs::FileStorage;

let fs = FileStorage::new(MemoryBackend::new());
fs.create_dir_all("/data")?;
fs.write("/data/file.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<h3 id="with-middleware-quotas-sandboxing-tracing"><a class="header" href="#with-middleware-quotas-sandboxing-tracing">With middleware (quotas, sandboxing, tracing)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, PathFilterLayer, TracingLayer};
use anyfs::FileStorage;

let stack = SqliteBackend::open("tenant.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_symlinks()
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(stack);
<span class="boring">}</span></code></pre>
<h3 id="custom-backend-implementation"><a class="header" href="#custom-backend-implementation">Custom backend implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, FsError, Metadata, DirEntry};
use std::path::Path;

pub struct MyBackend;

impl Fs for MyBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        todo!()
    }

    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    // ... implement all 25 methods
}
<span class="boring">}</span></code></pre>
<h3 id="custom-middleware-implementation"><a class="header" href="#custom-middleware-implementation">Custom middleware implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, Layer, FsError};
use std::path::Path;

pub struct MyMiddleware&lt;B: Fs&gt; {
    inner: B,
}

impl&lt;B: Fs&gt; Fs for MyMiddleware&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Intercept, transform, or delegate
        self.inner.read(path)
    }
    // ... implement all methods
}

pub struct MyMiddlewareLayer;

impl&lt;B: Fs&gt; Layer&lt;B&gt; for MyMiddlewareLayer {
    type Backend = MyMiddleware&lt;B&gt;;
    fn layer(self, backend: B) -&gt; Self::Backend {
        MyMiddleware { inner: backend }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h2>
<ul>
<li><strong>Don’t depend on <code>anyfs</code></strong> if you’re only implementing a backend or middleware. Use <code>anyfs-backend</code>.</li>
<li><strong>Don’t put policy in backends.</strong> Use middleware (Quota, PathFilter, etc.).</li>
<li><strong>Don’t put policy in FileStorage.</strong> It’s just an ergonomic wrapper.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs-implementation-patterns"><a class="header" href="#anyfs-implementation-patterns">AnyFS Implementation Patterns</a></h1>
<p><strong>Purpose:</strong> Quick reference for implementing backends, middleware, and adapters.</p>
<hr>
<h2 id="trait-hierarchy-pick-your-level"><a class="header" href="#trait-hierarchy-pick-your-level">Trait Hierarchy (Pick Your Level)</a></h2>
<pre><code>FsPosix  ← Full POSIX (handles, locks, xattr)
    ↑
FsFuse   ← FUSE-mountable (+ inodes)
    ↑
FsFull   ← std::fs features (+ links, permissions, sync, stats)
    ↑
   Fs    ← Basic filesystem (90% of use cases)
    ↑
FsRead + FsWrite + FsDir  ← Core traits
</code></pre>
<p><strong>Rule:</strong> Implement the lowest level you need. Higher levels include all below.</p>
<hr>
<h2 id="pattern-1-implement-a-backend"><a class="header" href="#pattern-1-implement-a-backend">Pattern 1: Implement a Backend</a></h2>
<h3 id="minimum-implement-fs-3-traits"><a class="header" href="#minimum-implement-fs-3-traits">Minimum: Implement <code>Fs</code> (3 traits)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Metadata, DirEntry, FileType, Permissions};
use std::path::Path;

pub struct MyBackend { /* your storage */ }

impl FsRead for MyBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        todo!("return file contents")
    }
    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, FsError&gt; {
        String::from_utf8(self.read(path)?).map_err(|e| FsError::Backend(e.to_string()))
    }
    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        todo!("return slice of file")
    }
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        todo!("check if path exists")
    }
    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt; {
        todo!("return Metadata { inode, nlink, file_type, size, permissions, created, modified, accessed }")
    }
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn std::io::Read + Send&gt;, FsError&gt; {
        Ok(Box::new(std::io::Cursor::new(self.read(path)?)))
    }
}

impl FsWrite for MyBackend {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        todo!("create or overwrite file")
    }
    fn append(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        todo!("append to file")
    }
    fn remove_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("delete file")
    }
    fn rename(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("move/rename")
    }
    fn copy(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("copy file")
    }
    fn truncate(&amp;self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), FsError&gt; {
        todo!("resize file")
    }
    fn open_write(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn std::io::Write + Send&gt;, FsError&gt; {
        todo!("return writer")
    }
}

impl FsDir for MyBackend {
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt; {
        todo!("return Vec&lt;DirEntry { name, inode, file_type }&gt;")
    }
    fn create_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("create single directory")
    }
    fn create_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("create directory and parents")
    }
    fn remove_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("remove empty directory")
    }
    fn remove_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("remove directory recursively")
    }
}
// MyBackend now implements Fs automatically!
<span class="boring">}</span></code></pre>
<h3 id="add-linkspermissions-implement-fsfull-add-4-traits"><a class="header" href="#add-linkspermissions-implement-fsfull-add-4-traits">Add Links/Permissions: Implement <code>FsFull</code> (add 4 traits)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsLink for MyBackend {
    fn symlink(&amp;self, target: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("create symlink pointing to target")
    }
    fn hard_link(&amp;self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("create hard link (same inode)")
    }
    fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;std::path::PathBuf, FsError&gt; {
        todo!("return symlink target")
    }
    fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt; {
        todo!("metadata without following symlink")
    }
}

impl FsPermissions for MyBackend {
    fn set_permissions(&amp;self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), FsError&gt; {
        todo!("set file permissions")
    }
}

impl FsSync for MyBackend {
    fn sync(&amp;self) -&gt; Result&lt;(), FsError&gt; {
        todo!("flush all writes to storage")
    }
    fn fsync(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!("flush writes for one file")
    }
}

impl FsStats for MyBackend {
    fn statfs(&amp;self) -&gt; Result&lt;anyfs_backend::StatFs, FsError&gt; {
        todo!("return StatFs { total_bytes, available_bytes, ... }")
    }
}
// MyBackend now implements FsFull!
<span class="boring">}</span></code></pre>
<h3 id="add-fuse-support-implement-fsfuse-add-1-trait"><a class="header" href="#add-fuse-support-implement-fsfuse-add-1-trait">Add FUSE Support: Implement <code>FsFuse</code> (add 1 trait)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsInode for MyBackend {
    fn path_to_inode(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;u64, FsError&gt; {
        todo!("return unique inode for path")
    }
    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;std::path::PathBuf, FsError&gt; {
        todo!("return path for inode")
    }
    fn lookup(&amp;self, parent_inode: u64, name: &amp;std::ffi::OsStr) -&gt; Result&lt;u64, FsError&gt; {
        todo!("find child inode by name")
    }
    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt; {
        todo!("get metadata by inode (fast path)")
    }
}
// MyBackend now implements FsFuse!
<span class="boring">}</span></code></pre>
<hr>
<h2 id="pattern-2-implement-middleware"><a class="header" href="#pattern-2-implement-middleware">Pattern 2: Implement Middleware</a></h2>
<p><strong>Rule:</strong> Middleware implements the same traits as its inner backend, intercepting some methods.</p>
<h3 id="template"><a class="header" href="#template">Template</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Layer};

pub struct MyMiddleware&lt;B&gt; {
    inner: B,
    // your state
}

impl&lt;B&gt; MyMiddleware&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self { inner }
    }
}

// Implement each trait, delegating or intercepting as needed
impl&lt;B: FsRead&gt; FsRead for MyMiddleware&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // INTERCEPT: add your logic
        let data = self.inner.read(path)?;  // DELEGATE
        // INTERCEPT: modify result
        Ok(data)
    }

    // For passthrough methods, just delegate:
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        self.inner.exists(path)
    }
    // ... implement all FsRead methods
}

impl&lt;B: FsWrite&gt; FsWrite for MyMiddleware&lt;B&gt; {
    // ... implement all FsWrite methods
}

impl&lt;B: FsDir&gt; FsDir for MyMiddleware&lt;B&gt; {
    // ... implement all FsDir methods
}

// Optional: Layer for .layer() syntax
pub struct MyMiddlewareLayer { /* config */ }

impl&lt;B: Fs&gt; Layer&lt;B&gt; for MyMiddlewareLayer {
    type Backend = MyMiddleware&lt;B&gt;;
    fn layer(self, backend: B) -&gt; Self::Backend {
        MyMiddleware::new(backend)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="common-middleware-patterns"><a class="header" href="#common-middleware-patterns">Common Middleware Patterns</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Intercept</th><th>Delegate</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Logging</strong></td><td>All (before/after)</td><td>All</td><td><code>Tracing</code></td></tr>
<tr><td><strong>Block writes</strong></td><td>Write methods → return error</td><td>Read methods</td><td><code>ReadOnly</code></td></tr>
<tr><td><strong>Transform data</strong></td><td><code>read</code>/<code>write</code></td><td>Everything else</td><td><code>Encryption</code></td></tr>
<tr><td><strong>Check permissions</strong></td><td>All (before)</td><td>All</td><td><code>PathFilter</code></td></tr>
<tr><td><strong>Enforce limits</strong></td><td>Write methods (check size)</td><td>Read methods</td><td><code>Quota</code></td></tr>
<tr><td><strong>Count operations</strong></td><td>All (increment counter)</td><td>All</td><td><code>Counter</code></td></tr>
</tbody>
</table>
</div>
<h3 id="example-readonly-middleware"><a class="header" href="#example-readonly-middleware">Example: ReadOnly Middleware</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsWrite&gt; FsWrite for ReadOnly&lt;B&gt; {
    fn write(&amp;self, _: impl AsRef&lt;Path&gt;, _: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "write" })
    }
    fn remove_file(&amp;self, _: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_file" })
    }
    // ... all write methods return ReadOnly error
}
<span class="boring">}</span></code></pre>
<h3 id="example-encryption-middleware"><a class="header" href="#example-encryption-middleware">Example: Encryption Middleware</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsRead&gt; FsRead for Encrypted&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let encrypted = self.inner.read(path)?;
        Ok(self.decrypt(&amp;encrypted))
    }
}

impl&lt;B: FsWrite&gt; FsWrite for Encrypted&lt;B&gt; {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let encrypted = self.encrypt(data);
        self.inner.write(path, &amp;encrypted)
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="pattern-3-implement-an-adapter"><a class="header" href="#pattern-3-implement-an-adapter">Pattern 3: Implement an Adapter</a></h2>
<h3 id="adapter-from-another-crates-trait"><a class="header" href="#adapter-from-another-crates-trait">Adapter FROM another crate’s trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wrap external crate's filesystem to use as AnyFS backend
pub struct ExternalCompat&lt;F&gt;(F);

impl&lt;F: external::FileSystem&gt; FsRead for ExternalCompat&lt;F&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.0.read_file(path).map_err(|e| FsError::Backend(e.to_string()))
    }
    // Map each method, converting errors
}

impl&lt;F: external::FileSystem&gt; FsWrite for ExternalCompat&lt;F&gt; { /* ... */ }
impl&lt;F: external::FileSystem&gt; FsDir for ExternalCompat&lt;F&gt; { /* ... */ }
// Only implement traits the external crate supports
<span class="boring">}</span></code></pre>
<h3 id="adapter-to-another-crates-trait"><a class="header" href="#adapter-to-another-crates-trait">Adapter TO another crate’s trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wrap AnyFS backend to use with external crate
pub struct AnyFsCompat&lt;B: Fs&gt;(B);

impl&lt;B: Fs&gt; external::FileSystem for AnyFsCompat&lt;B&gt; {
    fn read_file(&amp;self, path: &amp;Path) -&gt; external::Result&lt;Vec&lt;u8&gt;&gt; {
        self.0.read(path).map_err(|e| external::Error::from(e.to_string()))
    }
    // Only expose methods the external trait requires
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p><strong>Rule:</strong> Always return <code>FsError</code>, never panic.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Common error returns
FsError::NotFound { path, operation }      // Path doesn't exist
FsError::AlreadyExists { path, operation } // Path already exists
FsError::NotAFile { path }                 // Expected file, got directory
FsError::NotADirectory { path }            // Expected directory, got file
FsError::DirectoryNotEmpty { path }        // Can't remove non-empty dir
FsError::ReadOnly { operation }            // Write blocked by ReadOnly middleware
FsError::AccessDenied { path, reason }     // Blocked by PathFilter
FsError::QuotaExceeded { limit, requested, usage }
FsError::NotSupported { operation }        // Backend doesn't support this
FsError::Backend(String)                   // Backend-specific error
<span class="boring">}</span></code></pre>
<hr>
<h2 id="quick-reference-what-to-implement"><a class="header" href="#quick-reference-what-to-implement">Quick Reference: What to Implement</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>You want to…</th><th>Implement</th></tr>
</thead>
<tbody>
<tr><td>Basic file operations</td><td><code>FsRead</code> + <code>FsWrite</code> + <code>FsDir</code> (= <code>Fs</code>)</td></tr>
<tr><td>+ Symlinks/hardlinks</td><td>+ <code>FsLink</code></td></tr>
<tr><td>+ Permissions</td><td>+ <code>FsPermissions</code></td></tr>
<tr><td>+ Durability (sync)</td><td>+ <code>FsSync</code></td></tr>
<tr><td>+ Filesystem stats</td><td>+ <code>FsStats</code></td></tr>
<tr><td>All of above</td><td><code>Fs</code> + <code>FsLink</code> + <code>FsPermissions</code> + <code>FsSync</code> + <code>FsStats</code> (= <code>FsFull</code>)</td></tr>
<tr><td>+ FUSE mounting</td><td>+ <code>FsInode</code> (= <code>FsFuse</code>)</td></tr>
<tr><td>+ File handles/locks</td><td>+ <code>FsHandles</code> + <code>FsLock</code> + <code>FsXattr</code> (= <code>FsPosix</code>)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="usage-examples-1"><a class="header" href="#usage-examples-1">Usage Examples</a></h2>
<h3 id="create-a-backend-stack"><a class="header" href="#create-a-backend-stack">Create a backend stack</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, PathFilterLayer, TracingLayer};

let backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<h3 id="with-filestorage-wrapper"><a class="header" href="#with-filestorage-wrapper">With FileStorage wrapper</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::FileStorage;

let fs = FileStorage::new(backend);
fs.write("/file.txt", b"hello")?;
let data = fs.read("/file.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="type-safe-containers"><a class="header" href="#type-safe-containers">Type-safe containers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Sandbox;
struct UserData;

// Specify marker in type annotation, infer backend with _
let sandbox: FileStorage&lt;_, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
let userdata: FileStorage&lt;_, UserData&gt; = FileStorage::new(SqliteBackend::open("data.db")?);

fn process(fs: &amp;FileStorage&lt;impl Fs, Sandbox&gt;) { /* only accepts Sandbox */ }
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cross-platform-virtual-drive-mounting"><a class="header" href="#cross-platform-virtual-drive-mounting">Cross-Platform Virtual Drive Mounting</a></h1>
<p><strong>Mounting AnyFS backends as real filesystem mount points</strong></p>
<hr>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>AnyFS backends can be mounted as real filesystem drives that any application can access. This requires platform-specific adapters because each OS uses different userspace filesystem technologies.</p>
<hr>
<h2 id="platform-technologies"><a class="header" href="#platform-technologies">Platform Technologies</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Technology</th><th>Rust Crate</th><th>User Installation</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>FUSE</td><td><code>fuser</code></td><td>Usually pre-installed</td></tr>
<tr><td>macOS</td><td>macFUSE</td><td><code>fuser</code></td><td><a href="https://osxfuse.github.io/">macFUSE</a></td></tr>
<tr><td>Windows</td><td>WinFsp</td><td><code>winfsp</code></td><td><a href="https://winfsp.dev/">WinFsp</a></td></tr>
<tr><td>Windows</td><td>Dokan</td><td><code>dokan</code></td><td><a href="https://dokan-dev.github.io/">Dokan</a></td></tr>
</tbody>
</table>
</div>
<p><strong>Key insight:</strong> Linux and macOS both use FUSE (via <code>fuser</code> crate), but Windows requires a completely different API (WinFsp or Dokan).</p>
<hr>
<h2 id="architecture-3"><a class="header" href="#architecture-3">Architecture</a></h2>
<h3 id="unified-mount-trait"><a class="header" href="#unified-mount-trait">Unified Mount Trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Platform-agnostic mount handle.
/// Drop to unmount.
pub struct MountHandle {
    inner: Box&lt;dyn MountHandleInner&gt;,
}

impl MountHandle {
    /// Mount a backend at the specified path.
    ///
    /// Platform requirements:
    /// - Linux: FUSE (usually available)
    /// - macOS: macFUSE must be installed
    /// - Windows: WinFsp or Dokan must be installed
    pub fn mount&lt;B: FsFuse&gt;(backend: B, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, MountError&gt; {
        #[cfg(unix)]
        return fuse_mount(backend, path);

        #[cfg(windows)]
        return winfsp_mount(backend, path);

        #[cfg(not(any(unix, windows)))]
        return Err(MountError::PlatformNotSupported);
    }

    /// Check if mounting is available on this platform.
    pub fn is_available() -&gt; bool {
        #[cfg(target_os = "linux")]
        return check_fuse_available();

        #[cfg(target_os = "macos")]
        return check_macfuse_available();

        #[cfg(windows)]
        return check_winfsp_available() || check_dokan_available();

        #[cfg(not(any(unix, windows)))]
        return false;
    }

    /// Unmount the filesystem.
    pub fn unmount(self) -&gt; Result&lt;(), MountError&gt; {
        self.inner.unmount()
    }
}

impl Drop for MountHandle {
    fn drop(&amp;mut self) {
        let _ = self.inner.unmount();
    }
}
<span class="boring">}</span></code></pre>
<h3 id="platform-adapters"><a class="header" href="#platform-adapters">Platform Adapters</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                     MountHandle (unified API)               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │ FuseAdapter │  │ FuseAdapter │  │ WinFspAdapter       │ │
│  │   (Linux)   │  │   (macOS)   │  │    (Windows)        │ │
│  └──────┬──────┘  └──────┬──────┘  └──────────┬──────────┘ │
│         │                │                     │            │
│         ▼                ▼                     ▼            │
│    ┌─────────┐      ┌─────────┐         ┌──────────┐       │
│    │  fuser  │      │  fuser  │         │  winfsp  │       │
│    │  crate  │      │  crate  │         │  crate   │       │
│    └────┬────┘      └────┬────┘         └────┬─────┘       │
│         │                │                   │              │
│         ▼                ▼                   ▼              │
│    ┌─────────┐      ┌─────────┐         ┌──────────┐       │
│    │  FUSE   │      │ macFUSE │         │  WinFsp  │       │
│    │ (kernel)│      │ (kext)  │         │ (driver) │       │
│    └─────────┘      └─────────┘         └──────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<hr>
<h2 id="crate-structure"><a class="header" href="#crate-structure">Crate Structure</a></h2>
<pre><code>anyfs-mount/                    # Unified mounting crate
  Cargo.toml
  src/
    lib.rs                      # MountHandle, MountError

    unix/
      mod.rs                    # cfg(unix)
      fuse_adapter.rs           # FUSE implementation via fuser

    windows/
      mod.rs                    # cfg(windows)
      winfsp_adapter.rs         # WinFsp implementation
      dokan_adapter.rs          # Dokan implementation (alternative)
</code></pre>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<pre><code class="language-toml">[package]
name = "anyfs-mount"
version = "0.1.0"

[dependencies]
anyfs-backend = { version = "0.1" }

[target.'cfg(unix)'.dependencies]
fuser = "0.14"

[target.'cfg(windows)'.dependencies]
winfsp = "0.4"
# or: dokan = "0.3"

[features]
default = []
dokan = ["dep:dokan"]  # Use Dokan instead of WinFsp on Windows
</code></pre>
<hr>
<h2 id="fuse-adapter-linuxmacos"><a class="header" href="#fuse-adapter-linuxmacos">FUSE Adapter (Linux/macOS)</a></h2>
<p>The FUSE adapter translates between <code>fuser::Filesystem</code> trait and our <code>FsFuse</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fuser::{Filesystem, Request, ReplyEntry, ReplyAttr, ReplyData, ReplyDirectory};
use anyfs_backend::{FsFuse, FsError, Metadata, FileType};

pub struct FuseAdapter&lt;B: FsFuse&gt; {
    backend: B,
}

impl&lt;B: FsFuse&gt; Filesystem for FuseAdapter&lt;B&gt; {
    fn lookup(&amp;mut self, _req: &amp;Request, parent: u64, name: &amp;OsStr, reply: ReplyEntry) {
        match self.backend.lookup(parent, name) {
            Ok(inode) =&gt; {
                match self.backend.metadata_by_inode(inode) {
                    Ok(meta) =&gt; reply.entry(&amp;TTL, &amp;to_fuse_attr(&amp;meta), 0),
                    Err(e) =&gt; reply.error(to_errno(&amp;e)),
                }
            }
            Err(e) =&gt; reply.error(to_errno(&amp;e)),
        }
    }

    fn getattr(&amp;mut self, _req: &amp;Request, ino: u64, reply: ReplyAttr) {
        match self.backend.metadata_by_inode(ino) {
            Ok(meta) =&gt; reply.attr(&amp;TTL, &amp;to_fuse_attr(&amp;meta)),
            Err(e) =&gt; reply.error(to_errno(&amp;e)),
        }
    }

    fn read(&amp;mut self, _req: &amp;Request, ino: u64, _fh: u64, offset: i64, size: u32, _flags: i32, _lock: Option&lt;u64&gt;, reply: ReplyData) {
        let path = match self.backend.inode_to_path(ino) {
            Ok(p) =&gt; p,
            Err(e) =&gt; return reply.error(to_errno(&amp;e)),
        };

        match self.backend.read_range(&amp;path, offset as u64, size as usize) {
            Ok(data) =&gt; reply.data(&amp;data),
            Err(e) =&gt; reply.error(to_errno(&amp;e)),
        }
    }

    fn readdir(&amp;mut self, _req: &amp;Request, ino: u64, _fh: u64, offset: i64, mut reply: ReplyDirectory) {
        let path = match self.backend.inode_to_path(ino) {
            Ok(p) =&gt; p,
            Err(e) =&gt; return reply.error(to_errno(&amp;e)),
        };

        match self.backend.read_dir(&amp;path) {
            Ok(entries) =&gt; {
                for (i, entry) in entries.iter().enumerate().skip(offset as usize) {
                    let file_type = match entry.file_type {
                        FileType::File =&gt; fuser::FileType::RegularFile,
                        FileType::Directory =&gt; fuser::FileType::Directory,
                        FileType::Symlink =&gt; fuser::FileType::Symlink,
                    };

                    if reply.add(entry.inode, (i + 1) as i64, file_type, &amp;entry.name) {
                        break;
                    }
                }
                reply.ok();
            }
            Err(e) =&gt; reply.error(to_errno(&amp;e)),
        }
    }

    // ... write, create, mkdir, unlink, rmdir, rename, symlink, etc.
}

fn to_errno(e: &amp;FsError) -&gt; i32 {
    match e {
        FsError::NotFound { .. } =&gt; libc::ENOENT,
        FsError::AlreadyExists { .. } =&gt; libc::EEXIST,
        FsError::NotADirectory { .. } =&gt; libc::ENOTDIR,
        FsError::NotAFile { .. } =&gt; libc::EISDIR,
        FsError::DirectoryNotEmpty { .. } =&gt; libc::ENOTEMPTY,
        FsError::AccessDenied { .. } =&gt; libc::EACCES,
        FsError::ReadOnly { .. } =&gt; libc::EROFS,
        FsError::QuotaExceeded { .. } =&gt; libc::ENOSPC,
        _ =&gt; libc::EIO,
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="winfsp-adapter-windows"><a class="header" href="#winfsp-adapter-windows">WinFsp Adapter (Windows)</a></h2>
<p>WinFsp has a different API but similar concepts:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use winfsp::filesystem::{FileSystem, FileSystemContext, FileInfo, DirInfo};
use anyfs_backend::{FsFuse, FsError};

pub struct WinFspAdapter&lt;B: FsFuse&gt; {
    backend: B,
}

impl&lt;B: FsFuse&gt; FileSystem for WinFspAdapter&lt;B&gt; {
    fn get_file_info(&amp;self, file_context: &amp;FileContext) -&gt; Result&lt;FileInfo, NTSTATUS&gt; {
        let meta = self.backend.metadata(&amp;file_context.path)
            .map_err(to_ntstatus)?;
        Ok(to_file_info(&amp;meta))
    }

    fn read(&amp;self, file_context: &amp;FileContext, buffer: &amp;mut [u8], offset: u64) -&gt; Result&lt;usize, NTSTATUS&gt; {
        let data = self.backend.read_range(&amp;file_context.path, offset, buffer.len())
            .map_err(to_ntstatus)?;
        buffer[..data.len()].copy_from_slice(&amp;data);
        Ok(data.len())
    }

    fn read_directory(&amp;self, file_context: &amp;FileContext, marker: Option&lt;&amp;str&gt;, callback: impl FnMut(DirInfo)) -&gt; Result&lt;(), NTSTATUS&gt; {
        let entries = self.backend.read_dir(&amp;file_context.path)
            .map_err(to_ntstatus)?;

        for entry in entries {
            callback(to_dir_info(&amp;entry));
        }
        Ok(())
    }

    // ... write, create, delete, rename, etc.
}

fn to_ntstatus(e: FsError) -&gt; NTSTATUS {
    match e {
        FsError::NotFound { .. } =&gt; STATUS_OBJECT_NAME_NOT_FOUND,
        FsError::AlreadyExists { .. } =&gt; STATUS_OBJECT_NAME_COLLISION,
        FsError::AccessDenied { .. } =&gt; STATUS_ACCESS_DENIED,
        FsError::ReadOnly { .. } =&gt; STATUS_MEDIA_WRITE_PROTECTED,
        _ =&gt; STATUS_INTERNAL_ERROR,
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="basic-mount"><a class="header" href="#basic-mount">Basic Mount</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer};
use anyfs_mount::MountHandle;

// Create backend with middleware
let backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build());

// Mount as drive
let mount = MountHandle::mount(backend, "/mnt/ramdisk")?;

// Now /mnt/ramdisk is a real mount point
// Any application can read/write files there

// Unmount when done (or on drop)
mount.unmount()?;
<span class="boring">}</span></code></pre>
<h3 id="windows-drive-letter"><a class="header" href="#windows-drive-letter">Windows Drive Letter</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(windows)]
let mount = MountHandle::mount(backend, "X:")?;

// Now X: is a virtual drive
<span class="boring">}</span></code></pre>
<h3 id="check-availability"><a class="header" href="#check-availability">Check Availability</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if MountHandle::is_available() {
    let mount = MountHandle::mount(backend, path)?;
} else {
    eprintln!("Mounting not available. Install:");
    #[cfg(target_os = "macos")]
    eprintln!("  - macFUSE: https://osxfuse.github.io/");
    #[cfg(windows)]
    eprintln!("  - WinFsp: https://winfsp.dev/");
}
<span class="boring">}</span></code></pre>
<h3 id="mount-options"><a class="header" href="#mount-options">Mount Options</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mount = MountHandle::builder(backend)
    .mount_point("/mnt/data")
    .read_only(true)                    // Force read-only mount
    .allow_other(true)                  // Allow other users (Linux/macOS)
    .auto_unmount(true)                 // Unmount on process exit
    .uid(1000)                          // Override UID (Linux/macOS)
    .gid(1000)                          // Override GID (Linux/macOS)
    .mount()?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MountError {
    /// Platform doesn't support mounting (e.g., WASM)
    PlatformNotSupported,

    /// Required driver not installed (macFUSE, WinFsp)
    DriverNotInstalled {
        driver: &amp;'static str,
        install_url: &amp;'static str,
    },

    /// Mount point doesn't exist or isn't accessible
    InvalidMountPoint { path: PathBuf },

    /// Mount point already in use
    MountPointBusy { path: PathBuf },

    /// Permission denied (need root/admin)
    PermissionDenied,

    /// Backend error during mount
    Backend(FsError),

    /// Platform-specific error
    Platform(String),
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="integration-with-middleware"><a class="header" href="#integration-with-middleware">Integration with Middleware</a></h2>
<p>All middleware works transparently when mounted:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Quota, PathFilter, Tracing, RateLimit};
use anyfs_mount::MountHandle;

// Build secure, audited, rate-limited mount
let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(1024 * 1024 * 1024)  // 1 GB
        .build())
    .layer(PathFilterLayer::builder()
        .deny("**/.git/**")
        .deny("**/.env")
        .build())
    .layer(RateLimitLayer::builder()
        .max_ops(10000)
        .per_second()
        .build())
    .layer(TracingLayer::new());

let mount = MountHandle::mount(backend, "/mnt/secure")?;

// External apps see a normal filesystem
// But all operations are:
// - Quota-limited
// - Path-filtered
// - Rate-limited
// - Traced/audited
<span class="boring">}</span></code></pre>
<hr>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="temporary-workspace"><a class="header" href="#temporary-workspace">Temporary Workspace</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = MemoryBackend::new();
let mount = MountHandle::mount(workspace, "/tmp/workspace")?;

// Run build tools that expect real filesystem
std::process::Command::new("cargo")
    .current_dir("/tmp/workspace")
    .arg("build")
    .status()?;
<span class="boring">}</span></code></pre>
<h3 id="portable-database-as-drive"><a class="header" href="#portable-database-as-drive">Portable Database as Drive</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User's files stored in SQLite
let db = SqliteBackend::open("user_files.db")?;
let mount = MountHandle::mount(db, "U:")?;

// User can browse U: in Explorer
// Files are actually in SQLite database
<span class="boring">}</span></code></pre>
<h3 id="network-storage"><a class="header" href="#network-storage">Network Storage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remote backend (future anyfs-s3, anyfs-sftp, etc.)
let remote = S3Backend::new("my-bucket")?;
let cached = remote.layer(CacheLayer::builder()
    .max_size(100 * 1024 * 1024)
    .build());
let mount = MountHandle::mount(cached, "/mnt/cloud")?;

// Local apps see /mnt/cloud as regular filesystem
// Actually reads/writes to S3 with local caching
<span class="boring">}</span></code></pre>
<hr>
<h2 id="platform-requirements-summary"><a class="header" href="#platform-requirements-summary">Platform Requirements Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Driver</th><th>Install Command / URL</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>FUSE</td><td>Usually pre-installed. If not: <code>apt install fuse3</code></td></tr>
<tr><td>macOS</td><td>macFUSE</td><td>https://osxfuse.github.io/</td></tr>
<tr><td>Windows</td><td>WinFsp</td><td>https://winfsp.dev/ (recommended)</td></tr>
<tr><td>Windows</td><td>Dokan</td><td>https://dokan-dev.github.io/ (alternative)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ol>
<li><strong>Requires external driver</strong> - Users must install macFUSE (macOS) or WinFsp (Windows)</li>
<li><strong>Root/admin may be required</strong> - Some mount operations need elevated privileges</li>
<li><strong>Not available on WASM</strong> - Browser environment has no filesystem mounting</li>
<li><strong>Performance overhead</strong> - Userspace filesystem has kernel boundary crossing overhead</li>
<li><strong>Backend must implement FsFuse</strong> - Requires <code>FsInode</code> trait for inode operations</li>
</ol>
<hr>
<h2 id="alternative-no-mount-needed"><a class="header" href="#alternative-no-mount-needed">Alternative: No Mount Needed</a></h2>
<p>For many use cases, mounting isn’t necessary. AnyFS backends can be used directly:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Need</th><th>With Mounting</th><th>Without Mounting</th></tr>
</thead>
<tbody>
<tr><td>Build tools</td><td>Mount, run tools</td><td>Use tool’s VFS plugin if available</td></tr>
<tr><td>File browser</td><td>Mount as drive</td><td>Build custom UI with AnyFS API</td></tr>
<tr><td>Backup</td><td>Mount, use rsync</td><td>Use AnyFS API directly</td></tr>
<tr><td>Database</td><td>Mount for SQL tools</td><td>Query SQLite directly</td></tr>
</tbody>
</table>
</div>
<p><strong>Rule of thumb:</strong> Only mount when you need compatibility with external applications that expect real filesystem paths.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-building-a-txt-backend-yes-really"><a class="header" href="#tutorial-building-a-txt-backend-yes-really">Tutorial: Building a TXT Backend (Yes, Really)</a></h1>
<p><strong>How to turn a humble text file into a functioning virtual filesystem</strong></p>
<hr>
<h2 id="the-absurd-premise"><a class="header" href="#the-absurd-premise">The Absurd Premise</a></h2>
<p>What if your entire filesystem was just… a text file you can edit in Notepad?</p>
<pre><code>path,type,mode,data
/,dir,755,
/hello.txt,file,644,SGVsbG8sIFdvcmxkIQ==
/docs,dir,755,
/docs/readme.md,file,644,IyBXZWxjb21lIQoKWWVzLCB0aGlzIGlzIGluIGEgLnR4dCBmaWxl
</code></pre>
<p>One line per file. Comma-separated. Base64 content. Open it in Notepad, edit a file, save, done.</p>
<p>Sounds ridiculous? It is. But it <em>works</em>. And building it teaches you everything about implementing AnyFS backends.</p>
<p>Let’s do this.</p>
<hr>
<h2 id="why-this-is-actually-useful"><a class="header" href="#why-this-is-actually-useful">Why This Is Actually Useful</a></h2>
<p>Beyond the memes, a TXT backend demonstrates:</p>
<ol>
<li><strong>Backend flexibility</strong> - AnyFS doesn’t care how you store bytes</li>
<li><strong>Trait implementation</strong> - You’ll implement <code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code></li>
<li><strong>Middleware composition</strong> - We’ll add <code>Quota</code> to prevent the file from exploding</li>
<li><strong>Real-world patterns</strong> - The same patterns apply to serious backends</li>
<li><strong>Separation of concerns</strong> - Backends just store bytes; FileStorage handles path resolution</li>
</ol>
<p>Plus, you can literally edit your “filesystem” in Notepad. Try doing that with ext4.</p>
<blockquote>
<p><strong>Important:</strong> Backends receive <strong>already-resolved paths</strong> from FileStorage. You don’t need to handle <code>..</code>, symlinks, or normalization - that’s FileStorage’s job. Your backend just stores and retrieves bytes at the given paths.</p>
</blockquote>
<hr>
<h2 id="the-format"><a class="header" href="#the-format">The Format</a></h2>
<p>One line per entry. Four comma-separated fields. Dead simple:</p>
<pre><code>path,type,mode,data
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td>Absolute path</td><td><code>/docs/file.txt</code></td></tr>
<tr><td><code>type</code></td><td><code>file</code> or <code>dir</code></td><td><code>file</code></td></tr>
<tr><td><code>mode</code></td><td>Unix permissions (octal)</td><td><code>644</code></td></tr>
<tr><td><code>data</code></td><td>Base64-encoded content</td><td><code>SGVsbG8=</code></td></tr>
</tbody>
</table>
</div>
<p>Directories have empty data field. That’s the entire format. Open in Notepad, add a line, you created a file.</p>
<hr>
<h2 id="step-1-data-structures"><a class="header" href="#step-1-data-structures">Step 1: Data Structures</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::path::{Path, PathBuf};
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};

/// A single entry in our TXT filesystem
#[derive(Clone, Debug)]
struct TxtEntry {
    path: PathBuf,
    is_dir: bool,
    mode: u32,
    content: Vec&lt;u8&gt;,
}

impl TxtEntry {
    fn new_dir(path: impl Into&lt;PathBuf&gt;) -&gt; Self {
        Self {
            path: path.into(),
            is_dir: true,
            mode: 0o755,
            content: Vec::new(),
        }
    }

    fn new_file(path: impl Into&lt;PathBuf&gt;, content: Vec&lt;u8&gt;) -&gt; Self {
        Self {
            path: path.into(),
            is_dir: false,
            mode: 0o644,
            content,
        }
    }

    /// Serialize to a line: path,type,mode,data
    fn to_line(&amp;self) -&gt; String {
        let file_type = if self.is_dir { "dir" } else { "file" };
        let data_b64 = if self.content.is_empty() {
            String::new()
        } else {
            BASE64.encode(&amp;self.content)
        };

        format!("{},{},{:o},{}", self.path.display(), file_type, self.mode, data_b64)
    }

    /// Parse from line: path,type,mode,data
    fn from_line(line: &amp;str) -&gt; Result&lt;Self, TxtParseError&gt; {
        let parts: Vec&lt;&amp;str&gt; = line.splitn(4, ',').collect();
        if parts.len() &lt; 3 {
            return Err(TxtParseError::InvalidFormat);
        }

        let content = if parts.len() == 4 &amp;&amp; !parts[3].is_empty() {
            BASE64.decode(parts[3]).map_err(|_| TxtParseError::InvalidBase64)?
        } else {
            Vec::new()
        };

        Ok(Self {
            path: PathBuf::from(parts[0]),
            is_dir: parts[1] == "dir",
            mode: u32::from_str_radix(parts[2], 8)
                .map_err(|_| TxtParseError::InvalidNumber)?,
            content,
        })
    }
}

#[derive(Debug)]
enum TxtParseError {
    InvalidFormat,
    InvalidBase64,
    InvalidNumber,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-2-the-backend-structure"><a class="header" href="#step-2-the-backend-structure">Step 2: The Backend Structure</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, RwLock};
use std::fs::File;
use std::io::{BufRead, BufReader, Write};

/// A filesystem backend that stores everything in a .txt file.
///
/// Yes, this is cursed. Yes, it works. Yes, you can edit it in Notepad.
pub struct TxtBackend {
    /// Path to the .txt file on the host filesystem
    txt_path: PathBuf,
    /// In-memory cache of entries (path -&gt; entry)
    entries: Arc&lt;RwLock&lt;HashMap&lt;PathBuf, TxtEntry&gt;&gt;&gt;,
}

impl TxtBackend {
    /// Create a new TXT backend, loading from file if it exists
    pub fn open(txt_path: impl Into&lt;PathBuf&gt;) -&gt; Result&lt;Self, FsError&gt; {
        let txt_path = txt_path.into();
        let mut entries = HashMap::new();

        // Always ensure root directory exists
        entries.insert(PathBuf::from("/"), TxtEntry::new_dir("/"));

        // Load existing entries if file exists
        if txt_path.exists() {
            let file = File::open(&amp;txt_path)
                .map_err(|e| FsError::Io {
                    operation: "open txt",
                    path: txt_path.clone(),
                    source: e,
                })?;

            for (line_num, line) in BufReader::new(file).lines().enumerate() {
                let line = line.map_err(|e| FsError::Io {
                    operation: "read line",
                    path: txt_path.clone(),
                    source: e,
                })?;

                // Skip header line
                if line_num == 0 &amp;&amp; line.starts_with("path,") {
                    continue;
                }

                // Skip empty lines
                if line.trim().is_empty() {
                    continue;
                }

                let entry = TxtEntry::from_line(&amp;line)
                    .map_err(|_| FsError::CorruptedData {
                        path: txt_path.clone(),
                        details: format!("line {}", line_num + 1),
                    })?;

                entries.insert(entry.path.clone(), entry);
            }
        }

        Ok(Self {
            txt_path,
            entries: Arc::new(RwLock::new(entries)),
        })
    }

    /// Create a new in-memory backend (won't persist to disk)
    pub fn in_memory() -&gt; Self {
        let mut entries = HashMap::new();
        entries.insert(PathBuf::from("/"), TxtEntry::new_dir("/"));

        Self {
            txt_path: PathBuf::from(":memory:"),
            entries: Arc::new(RwLock::new(entries)),
        }
    }

    /// Flush all entries to the .txt file
    fn flush(&amp;self) -&gt; Result&lt;(), FsError&gt; {
        // Skip if in-memory mode
        if self.txt_path.as_os_str() == ":memory:" {
            return Ok(());
        }

        let entries = self.entries.read().unwrap();

        let mut file = File::create(&amp;self.txt_path)
            .map_err(|e| FsError::Io {
                operation: "create txt",
                path: self.txt_path.clone(),
                source: e,
            })?;

        // Write header
        writeln!(file, "path,type,mode,data")
            .map_err(|e| FsError::Io {
                operation: "write header",
                path: self.txt_path.clone(),
                source: e,
            })?;

        // Write entries (sorted for consistency)
        let mut paths: Vec&lt;_&gt; = entries.keys().collect();
        paths.sort();

        for path in paths {
            let entry = &amp;entries[path];
            writeln!(file, "{}", entry.to_line())
                .map_err(|e| FsError::Io {
                    operation: "write entry",
                    path: path.clone(),
                    source: e,
                })?;
        }

        Ok(())
    }

}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-3-implement-fsread"><a class="header" href="#step-3-implement-fsread">Step 3: Implement FsRead</a></h2>
<p>Now the fun part - making it quack like a filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsError, Metadata, FileType};

impl FsRead for TxtBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        let entries = self.entries.read().unwrap();

        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if entry.is_dir {
            return Err(FsError::NotAFile { path });
        }

        Ok(entry.content.clone())
    }

    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, FsError&gt; {
        let bytes = self.read(path.as_ref())?;
        String::from_utf8(bytes)
            .map_err(|_| FsError::InvalidData {
                path: path.as_ref().to_path_buf(),
                details: "not valid UTF-8".to_string(),
            })
    }

    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let content = self.read(path)?;
        let start = offset as usize;

        if start &gt;= content.len() {
            return Ok(Vec::new());
        }

        let end = (start + len).min(content.len());
        Ok(content[start..end].to_vec())
    }

    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        let path = path.as_ref();
        let entries = self.entries.read().unwrap();
        Ok(entries.contains_key(path))
    }

    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt; {
        let path = path.as_ref();
        let entries = self.entries.read().unwrap();

        let entry = entries.get(path)
            .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;

        Ok(Metadata {
            file_type: if entry.is_dir { FileType::Directory } else { FileType::File },
            size: entry.content.len() as u64,
            created: None,  // We keep it simple - no timestamps
            modified: None,
            accessed: None,
            permissions: Some(entry.mode),
            inode: None,
        })
    }

    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn std::io::Read + Send&gt;, FsError&gt; {
        let content = self.read(path)?;
        Ok(Box::new(std::io::Cursor::new(content)))
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-4-implement-fswrite"><a class="header" href="#step-4-implement-fswrite">Step 4: Implement FsWrite</a></h2>
<p>Where the magic happens - writing files to a text file:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsWrite;

impl FsWrite for TxtBackend {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            if parent != Path::new("/") &amp;&amp; parent != Path::new("") {
                let entries = self.entries.read().unwrap();
                if !entries.contains_key(parent) {
                    drop(entries);
                    return Err(FsError::NotFound {
                        path: parent.to_path_buf()
                    });
                }
            }
        }

        let mut entries = self.entries.write().unwrap();

        // Check if it's a directory
        if let Some(existing) = entries.get(&amp;path) {
            if existing.is_dir {
                return Err(FsError::NotAFile { path });
            }
        }

        // Create or update the file
        let entry = TxtEntry::new_file(path.clone(), data.to_vec());
        entries.insert(path, entry);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn append(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let mut entries = self.entries.write().unwrap();

        let entry = entries.get_mut(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if entry.is_dir {
            return Err(FsError::NotAFile { path });
        }

        entry.content.extend_from_slice(data);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn remove_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let mut entries = self.entries.write().unwrap();

        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if entry.is_dir {
            return Err(FsError::NotAFile { path });
        }

        entries.remove(&amp;path);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn rename(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let from = from.as_ref().to_path_buf();
        let to = to.as_ref().to_path_buf();

        let mut entries = self.entries.write().unwrap();

        let mut entry = entries.remove(&amp;from)
            .ok_or_else(|| FsError::NotFound { path: from.clone() })?;

        entry.path = to.clone();
        entries.insert(to, entry);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn copy(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let from = from.as_ref().to_path_buf();
        let to = to.as_ref().to_path_buf();

        let entries = self.entries.read().unwrap();

        let source = entries.get(&amp;from)
            .ok_or_else(|| FsError::NotFound { path: from.clone() })?;

        if source.is_dir {
            return Err(FsError::NotAFile { path: from });
        }

        let mut new_entry = source.clone();
        new_entry.path = to.clone();

        drop(entries);

        let mut entries = self.entries.write().unwrap();
        entries.insert(to, new_entry);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn truncate(&amp;self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let mut entries = self.entries.write().unwrap();

        let entry = entries.get_mut(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if entry.is_dir {
            return Err(FsError::NotAFile { path });
        }

        entry.content.truncate(size as usize);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn open_write(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn std::io::Write + Send&gt;, FsError&gt; {
        // For simplicity, we buffer writes and apply on drop
        // A real implementation would be more sophisticated
        let path = path.as_ref().to_path_buf();

        // Ensure file exists (create empty if not)
        if !self.exists(&amp;path)? {
            self.write(&amp;path, b"")?;
        }

        Ok(Box::new(TxtFileWriter {
            backend: self.entries.clone(),
            txt_path: self.txt_path.clone(),
            path,
            buffer: Vec::new(),
        }))
    }
}

/// Writer that buffers content and writes to TXT on drop
struct TxtFileWriter {
    backend: Arc&lt;RwLock&lt;HashMap&lt;PathBuf, TxtEntry&gt;&gt;&gt;,
    txt_path: PathBuf,
    path: PathBuf,
    buffer: Vec&lt;u8&gt;,
}

impl std::io::Write for TxtFileWriter {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; std::io::Result&lt;usize&gt; {
        self.buffer.extend_from_slice(buf);
        Ok(buf.len())
    }

    fn flush(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {
        Ok(())
    }
}

impl Drop for TxtFileWriter {
    fn drop(&amp;mut self) {
        let mut entries = self.backend.write().unwrap();
        if let Some(entry) = entries.get_mut(&amp;self.path) {
            entry.content = std::mem::take(&amp;mut self.buffer);
        }
        // Note: flush to disk happens on next explicit flush() call
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-5-implement-fsdir"><a class="header" href="#step-5-implement-fsdir">Step 5: Implement FsDir</a></h2>
<p>Directory operations to complete the <code>Fs</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsDir, DirEntry};

impl FsDir for TxtBackend {
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let entries = self.entries.read().unwrap();

        // Verify the path is a directory
        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if !entry.is_dir {
            return Err(FsError::NotADirectory { path });
        }

        // Find all direct children
        let mut children = Vec::new();

        for (child_path, child_entry) in entries.iter() {
            if let Some(parent) = child_path.parent() {
                if parent == path &amp;&amp; child_path != &amp;path {
                    children.push(DirEntry {
                        name: child_path.file_name()
                            .unwrap_or_default()
                            .to_string_lossy()
                            .into_owned(),
                        path: child_path.clone(),
                        file_type: if child_entry.is_dir {
                            FileType::Directory
                        } else {
                            FileType::File
                        },
                        size: child_entry.size,
                        inode: None,
                    });
                }
            }
        }

        // Sort for consistent ordering
        children.sort_by(|a, b| a.name.cmp(&amp;b.name));

        Ok(children)
    }

    fn create_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Check parent exists
        if let Some(parent) = path.parent() {
            if parent != Path::new("/") &amp;&amp; parent != Path::new("") {
                let entries = self.entries.read().unwrap();
                let parent_entry = entries.get(parent)
                    .ok_or_else(|| FsError::NotFound {
                        path: parent.to_path_buf()
                    })?;

                if !parent_entry.is_dir {
                    return Err(FsError::NotADirectory {
                        path: parent.to_path_buf()
                    });
                }
            }
        }

        let mut entries = self.entries.write().unwrap();

        // Check if already exists
        if entries.contains_key(&amp;path) {
            return Err(FsError::AlreadyExists { path, operation: "create_dir" });
        }

        entries.insert(path.clone(), TxtEntry::new_dir(path));

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn create_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Build list of directories to create
        let mut to_create = Vec::new();
        let mut current = path.clone();

        loop {
            {
                let entries = self.entries.read().unwrap();
                if entries.contains_key(&amp;current) {
                    break;
                }
            }

            to_create.push(current.clone());

            match current.parent() {
                Some(parent) if parent != Path::new("") =&gt; {
                    current = parent.to_path_buf();
                }
                _ =&gt; break,
            }
        }

        // Create directories from root to leaf
        to_create.reverse();
        for dir_path in to_create {
            let mut entries = self.entries.write().unwrap();
            if !entries.contains_key(&amp;dir_path) {
                entries.insert(dir_path.clone(), TxtEntry::new_dir(dir_path));
            }
        }

        self.flush()?;
        Ok(())
    }

    fn remove_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Can't remove root
        if path == Path::new("/") {
            return Err(FsError::PermissionDenied {
                path,
                operation: "remove root directory"
            });
        }

        let entries = self.entries.read().unwrap();

        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if !entry.is_dir {
            return Err(FsError::NotADirectory { path });
        }

        // Check if empty
        let has_children = entries.keys().any(|p| {
            p != &amp;path &amp;&amp; p.starts_with(&amp;path)
        });

        if has_children {
            return Err(FsError::DirectoryNotEmpty { path });
        }

        drop(entries);

        let mut entries = self.entries.write().unwrap();
        entries.remove(&amp;path);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn remove_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Can't remove root
        if path == Path::new("/") {
            return Err(FsError::PermissionDenied {
                path,
                operation: "remove root directory"
            });
        }

        let mut entries = self.entries.write().unwrap();

        // Verify it exists and is a directory
        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if !entry.is_dir {
            return Err(FsError::NotADirectory { path: path.clone() });
        }

        // Remove all entries under this path
        let to_remove: Vec&lt;_&gt; = entries.keys()
            .filter(|p| p.starts_with(&amp;path))
            .cloned()
            .collect();

        for p in to_remove {
            entries.remove(&amp;p);
        }

        drop(entries);
        self.flush()?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-6-putting-it-all-together"><a class="header" href="#step-6-putting-it-all-together">Step 6: Putting It All Together</a></h2>
<p>Now you have a complete <code>Fs</code> implementation! Let’s use it:</p>
<pre class="playground"><code class="language-rust">use anyfs::{FileStorage, QuotaLayer, TracingLayer};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create our glorious TXT filesystem
    let backend = TxtBackend::open("my_filesystem.txt")?
        // Wrap it with middleware to prevent the file from exploding
        .layer(QuotaLayer::builder()
            .max_total_size(10 * 1024 * 1024)  // 10 MB max
            .max_file_size(1 * 1024 * 1024)    // 1 MB per file
            .build())
        // Add tracing because why not
        .layer(TracingLayer::new());

    // Create the filesystem wrapper
    let fs = FileStorage::new(backend);

    // Use it like any other filesystem!
    fs.create_dir_all("/projects/secret")?;
    fs.write("/projects/secret/plans.txt", b"World domination via TXT")?;
    fs.write("/projects/readme.md", b"# My TXT-backed project\n\nYes, really.")?;

    // Read it back
    let content = fs.read_to_string("/projects/secret/plans.txt")?;
    println!("Plans: {}", content);

    // List directory
    for entry in fs.read_dir("/projects")? {
        println!("  {} ({})", entry.name,
            if entry.file_type == FileType::Directory { "dir" } else { "file" });
    }

    // Copy a file
    fs.copy("/projects/readme.md", "/projects/readme_backup.md")?;

    // Delete a file
    fs.remove_file("/projects/readme_backup.md")?;

    println!("\nNow open my_filesystem.txt in Notepad!");

    Ok(())
}</code></pre>
<hr>
<h2 id="the-result"><a class="header" href="#the-result">The Result</a></h2>
<p>After running the code, your <code>my_filesystem.txt</code> looks like:</p>
<pre><code>path,type,mode,data
/,dir,755,
/projects,dir,755,
/projects/secret,dir,755,
/projects/secret/plans.txt,file,644,V29ybGQgZG9taW5hdGlvbiB2aWEgVFhU
/projects/readme.md,file,644,IyBNeSBUWFQtYmFja2VkIHByb2plY3QKCllzLCByZWFsbHku
</code></pre>
<p>Open it in Notepad. Marvel at your filesystem. Edit a line. Save. You just modified a file.</p>
<hr>
<h2 id="why-this-actually-matters"><a class="header" href="#why-this-actually-matters">Why This Actually Matters</a></h2>
<p>This ridiculous example demonstrates the power of AnyFS’s design:</p>
<ol>
<li>
<p><strong>True backend abstraction</strong> - The <code>FileStorage</code> API doesn’t know or care that it’s backed by a text file</p>
</li>
<li>
<p><strong>Middleware just works</strong> - <code>Quota</code> and <code>Tracing</code> wrap your custom backend with zero extra code</p>
</li>
<li>
<p><strong>Type safety preserved</strong> - Compile-time guarantees work with any backend</p>
</li>
<li>
<p><strong>Easy to implement</strong> - ~250 lines for a complete working backend</p>
</li>
<li>
<p><strong>Testable</strong> - Use <code>TxtBackend::in_memory()</code> for fast tests</p>
</li>
<li>
<p><strong>Human-editable</strong> - Open in Notepad, add a line, you created a file</p>
</li>
</ol>
<hr>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>If you’re feeling brave:</p>
<ol>
<li><strong>Add symlink support</strong> - Implement <code>FsLink</code> trait</li>
<li><strong>Make it async</strong> - Wrap with <code>tokio::fs</code> for the host CSV file</li>
<li><strong>Add compression</strong> - Gzip the base64 content</li>
<li><strong>Excel integration</strong> - Add formulas that compute file sizes (why not?)</li>
</ol>
<hr>
<h2 id="bonus-mount-it-as-a-drive"><a class="header" href="#bonus-mount-it-as-a-drive">Bonus: Mount It as a Drive</a></h2>
<p>With <code>anyfs-mount</code>, you can mount your text file as a real filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_mount::MountHandle;

let backend = TxtBackend::open("filesystem.txt")?;
let mount = MountHandle::mount(backend, "/mnt/txt")?;

// Now /mnt/txt is a real mount point backed by a .txt file
// Any application can read/write files there
// The data goes into a text file you can edit in Notepad
// This is fine
<span class="boring">}</span></code></pre>
<hr>
<h2 id="the-moral"><a class="header" href="#the-moral">The Moral</a></h2>
<p>AnyFS doesn’t care where bytes come from or where they go. Memory, SQLite, a text file, a REST API, carrier pigeons with USB drives - if you can implement the traits, it’s a valid backend.</p>
<p>The middleware layer (quotas, sandboxing, rate limiting, logging) works transparently on any backend. That’s the power of good abstractions.</p>
<p>Now go build something less cursed. Or don’t. I’m not your supervisor.</p>
<hr>
<p><em>“I store my production data in text files” - Nobody, ever (until now)</em></p>
<p><em>“Can I edit my filesystem in Notepad?” - Yes. Yes you can.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---comparison-and-positioning"><a class="header" href="#anyfs---comparison-and-positioning">AnyFS - Comparison and Positioning</a></h1>
<p><strong>How AnyFS compares to existing solutions</strong></p>
<p>AnyFS is a <strong>filesystem abstraction with composable middleware</strong>. It separates storage (backends) from policy (middleware) using a Tower-style pattern. With the SQLite backend, a tenant’s filesystem becomes a single portable <code>.db</code> file.</p>
<hr>
<h2 id="executive-comparison"><a class="header" href="#executive-comparison">Executive Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Solution</th><th>Type</th><th style="text-align: center">Middleware</th><th style="text-align: center">Backend Choice</th><th style="text-align: center">Quotas</th><th style="text-align: center">Portable Storage</th></tr>
</thead>
<tbody>
<tr><td><strong>AnyFS</strong></td><td>Library</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes (SQLite)</td></tr>
<tr><td><code>vfs</code> crate</td><td>Library</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>AgentFS</td><td>Runtime</td><td style="text-align: center">No</td><td style="text-align: center">No (SQLite)</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>SQLAR</td><td>Format</td><td style="text-align: center">N/A</td><td style="text-align: center">No (SQLite)</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>libsqlfs</td><td>FUSE</td><td style="text-align: center">N/A</td><td style="text-align: center">No (SQLite)</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>OpenDAL</td><td>Library</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes (cloud)</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="detailed-comparisons"><a class="header" href="#detailed-comparisons">Detailed Comparisons</a></h2>
<h3 id="vs-vfs-crate-rust"><a class="header" href="#vs-vfs-crate-rust">vs. <code>vfs</code> crate (Rust)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th><code>vfs</code> crate</th><th>AnyFS</th></tr>
</thead>
<tbody>
<tr><td>Middleware pattern</td><td>No</td><td>Yes (Tower-style)</td></tr>
<tr><td>Quotas/limits</td><td>No</td><td>Yes (Quota middleware)</td></tr>
<tr><td>Path sandboxing</td><td>Backend-dependent</td><td>Yes (PathFilter middleware)</td></tr>
<tr><td>Feature gating</td><td>No</td><td>Yes (Restrictions middleware)</td></tr>
<tr><td>SQLite backend</td><td>No</td><td>Yes (built-in)</td></tr>
<tr><td>Path containment</td><td>Prefix-based (AltrootFS)</td><td>Canonicalization-based (<code>strict-path</code>)</td></tr>
<tr><td>Third-party extensibility</td><td>Implement trait</td><td>Implement trait + Layer</td></tr>
<tr><td>Path type</td><td>Custom <code>VfsPath</code></td><td><code>impl AsRef&lt;Path&gt;</code> (std-compatible)</td></tr>
</tbody>
</table>
</div>
<p><strong>Path containment difference:</strong></p>
<p>The <code>vfs</code> crate’s <code>AltrootFS</code> uses path prefix translation - it prepends a root path before delegating to the underlying filesystem. This is vulnerable to symlink-based escapes:</p>
<pre><code>AltrootFS root: /data/tenant1/
Symlink: /data/tenant1/link → ../tenant2/secrets.txt
Access: /link → escapes to /data/tenant2/secrets.txt
</code></pre>
<p>AnyFS’s <code>VRootFsBackend</code> uses <code>strict-path</code> for full canonicalization. Symlinks are resolved and validated <em>before</em> any filesystem operation, preventing escapes.</p>
<p><strong>Use <code>vfs</code> when:</strong> You need simple VFS abstraction without policies or security-sensitive containment.</p>
<p><strong>Use AnyFS when:</strong> You need composable middleware (quotas, sandboxing, logging) or hardened path containment.</p>
<hr>
<h3 id="vs-agentfs-turso"><a class="header" href="#vs-agentfs-turso">vs. AgentFS (Turso)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>AgentFS</th><th>AnyFS</th></tr>
</thead>
<tbody>
<tr><td>Scope</td><td>Agent runtime (FS + KV + auditing)</td><td>Filesystem abstraction</td></tr>
<tr><td>Backend choice</td><td>SQLite only</td><td>Memory, SQLite, RealFS, custom</td></tr>
<tr><td>Middleware</td><td>No</td><td>Yes (composable)</td></tr>
<tr><td>KV store</td><td>Included</td><td>Not included (different abstraction)</td></tr>
<tr><td>Tool auditing</td><td>Built-in</td><td>Use Tracing middleware</td></tr>
</tbody>
</table>
</div>
<p><strong>Use AgentFS when:</strong> You need a complete AI agent runtime with KV and auditing.</p>
<p><strong>Use AnyFS when:</strong> You need just filesystem with backend flexibility and composable policies.</p>
<hr>
<h3 id="vs-sqlar-sqlite-archive"><a class="header" href="#vs-sqlar-sqlite-archive">vs. SQLAR (SQLite archive)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>SQLAR</th><th>AnyFS</th></tr>
</thead>
<tbody>
<tr><td>API</td><td>SQL statements</td><td>Filesystem methods</td></tr>
<tr><td>Quotas</td><td>No</td><td>Yes</td></tr>
<tr><td>Middleware</td><td>No</td><td>Yes</td></tr>
<tr><td>Streaming I/O</td><td>No</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<p><strong>Use SQLAR when:</strong> You want a simple archive format.</p>
<p><strong>Use AnyFS when:</strong> You need filesystem operations with policies.</p>
<hr>
<h3 id="vs-libsqlfs-guardian-project"><a class="header" href="#vs-libsqlfs-guardian-project">vs. libsqlfs (Guardian Project)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>libsqlfs</th><th>AnyFS</th></tr>
</thead>
<tbody>
<tr><td>Interface</td><td>FUSE mount</td><td>Library API</td></tr>
<tr><td>Deployment</td><td>Requires OS integration</td><td>No mount needed</td></tr>
<tr><td>Backend choice</td><td>SQLite only</td><td>Multiple</td></tr>
</tbody>
</table>
</div>
<p><strong>Use libsqlfs when:</strong> You need a mounted filesystem.</p>
<p><strong>Use AnyFS when:</strong> You want embedded storage without mounting.</p>
<hr>
<h3 id="vs-opendal"><a class="header" href="#vs-opendal">vs. OpenDAL</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>OpenDAL</th><th>AnyFS</th></tr>
</thead>
<tbody>
<tr><td>Focus</td><td>Cloud object storage</td><td>Local/embedded filesystem</td></tr>
<tr><td>Async</td><td>Yes (async-first)</td><td>Sync-first (async planned)</td></tr>
<tr><td>Backends</td><td>Cloud services (S3, GCS, etc.)</td><td>Local (Memory, SQLite, RealFS)</td></tr>
<tr><td>Middleware</td><td>Yes</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<p><strong>Use OpenDAL when:</strong> Your storage is cloud object storage.</p>
<p><strong>Use AnyFS when:</strong> Your storage is local/embedded.</p>
<hr>
<h2 id="feature-matrix"><a class="header" href="#feature-matrix">Feature Matrix</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center">AnyFS</th><th style="text-align: center"><code>vfs</code></th><th style="text-align: center">AgentFS</th><th style="text-align: center">OpenDAL</th></tr>
</thead>
<tbody>
<tr><td>Composable middleware</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>Multiple backends</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>SQLite backend</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
<tr><td>Memory backend</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>Real FS backend</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>Quota enforcement</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>Path sandboxing</td><td style="text-align: center">Yes</td><td style="text-align: center">Partial</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>Symlink-safe containment</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">N/A</td><td style="text-align: center">N/A</td></tr>
<tr><td>Rate limiting</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>Streaming I/O</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td></tr>
<tr><td>Async API</td><td style="text-align: center">Planned</td><td style="text-align: center">Partial</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>FUSE mount</td><td style="text-align: center">Possible</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="when-to-use-anyfs"><a class="header" href="#when-to-use-anyfs">When to Use AnyFS</a></h2>
<p><strong>Good fit:</strong></p>
<ul>
<li>Multi-tenant SaaS with per-tenant quotas</li>
<li>AI agent sandboxing with path restrictions</li>
<li>Desktop apps with portable user data</li>
<li>Plugin systems with isolated storage</li>
<li>Testing with deterministic isolated storage</li>
<li>Any case where you might swap backends later</li>
</ul>
<p><strong>Not a good fit:</strong></p>
<ul>
<li>You must mount a filesystem (use FUSE solution)</li>
<li>You need full POSIX behavior (xattrs, ACLs)</li>
<li>Your storage is cloud object storage (use OpenDAL)</li>
<li>You need async-first design today (wait for AnyFS async)</li>
</ul>
<hr>
<h2 id="migration-examples"><a class="header" href="#migration-examples">Migration Examples</a></h2>
<h3 id="from-stdfs"><a class="header" href="#from-stdfs">From <code>std::fs</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: host filesystem
std::fs::write("/data/file.txt", content)?;

// After: AnyFS (can swap backend later)
fs.write("/data/file.txt", content)?;
<span class="boring">}</span></code></pre>
<h3 id="from-raw-sqlite"><a class="header" href="#from-raw-sqlite">From raw SQLite</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: raw SQL
conn.execute("INSERT INTO files(path, data) VALUES (?, ?)", [path, data])?;

// After: AnyFS with SQLite backend
fs.write(path, data)?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>AnyFS is positioned as the <strong>Tower/Axum of filesystems</strong>: composable middleware over pluggable backends. It fills the gap between simple VFS abstractions (no policies) and complete runtimes (too much bundled together).</p>
<p><em>For technical details, see <a href="#anyfs---design-overview">Design Overview</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h1>
<p><strong>Security model, threat analysis, and containment guarantees</strong></p>
<hr>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>AnyFS is designed with security as a primary concern. Security policies are enforced via <strong>composable middleware</strong>, not hardcoded in backends or the container wrapper.</p>
<hr>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<h3 id="in-scope-mitigated-by-middleware"><a class="header" href="#in-scope-mitigated-by-middleware">In Scope (Mitigated by Middleware)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Description</th><th>Middleware</th></tr>
</thead>
<tbody>
<tr><td><strong>Path traversal</strong></td><td>Access files outside allowed paths</td><td><code>PathFilter</code></td></tr>
<tr><td><strong>Symlink attacks</strong></td><td>Use symlinks to bypass controls</td><td>Backend-dependent (see below)</td></tr>
<tr><td><strong>Resource exhaustion</strong></td><td>Fill storage or create excessive files</td><td><code>Quota</code></td></tr>
<tr><td><strong>Runaway processes</strong></td><td>Excessive operations consuming resources</td><td><code>RateLimit</code></td></tr>
<tr><td><strong>Unauthorized writes</strong></td><td>Modifications to read-only data</td><td><code>ReadOnly</code></td></tr>
<tr><td><strong>Sensitive file access</strong></td><td>Access to <code>.env</code>, secrets, etc.</td><td><code>PathFilter</code></td></tr>
</tbody>
</table>
</div>
<h3 id="out-of-scope"><a class="header" href="#out-of-scope">Out of Scope</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><strong>Side-channel attacks</strong></td><td>Requires OS-level mitigations</td></tr>
<tr><td><strong>Physical access</strong></td><td>Disk encryption is application’s responsibility</td></tr>
<tr><td><strong>SQLite vulnerabilities</strong></td><td>Upstream dependency; update regularly</td></tr>
<tr><td><strong>Network attacks</strong></td><td>AnyFS is local storage, not network-facing</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h2>
<h3 id="1-middleware-based-policy"><a class="header" href="#1-middleware-based-policy">1. Middleware-Based Policy</a></h3>
<p>Security policies are composable middleware layers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, PathFilterLayer, RestrictionsLayer, RateLimitLayer, TracingLayer};

let secure_backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()              // Limit resources
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()       // Block dangerous features
        .deny_symlinks()
        .deny_hard_links()
        .build())
    .layer(PathFilterLayer::builder()         // Sandbox paths
        .allow("/workspace/**")
        .deny("**/.env")
        .deny("**/secrets/**")
        .build())
    .layer(RateLimitLayer::builder()          // Throttle operations
        .max_ops(1000)
        .per_second()
        .build())
    .layer(TracingLayer::new());              // Audit trail
<span class="boring">}</span></code></pre>
<h3 id="2-path-sandboxing-pathfilter"><a class="header" href="#2-path-sandboxing-pathfilter">2. Path Sandboxing (PathFilter)</a></h3>
<p><code>PathFilter</code> middleware restricts path access using glob patterns:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PathFilterLayer::builder()
    .allow("/workspace/**")    // Allow workspace access
    .deny("**/.env")           // Block .env files
    .deny("**/secrets/**")     // Block secrets directories
    .deny("**/*.key")          // Block key files
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Guarantees:</strong></p>
<ul>
<li>First matching rule wins</li>
<li>No rule = denied (deny by default)</li>
<li><code>read_dir</code> filters denied entries from results</li>
</ul>
<h3 id="3-feature-gating-restrictions"><a class="header" href="#3-feature-gating-restrictions">3. Feature Gating (Restrictions)</a></h3>
<p>By default, all operations work. Use <code>Restrictions</code> middleware to <strong>opt-in to restrictions</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RestrictionsLayer::builder()
    .deny_hard_links()         // Block hard_link() calls
    .deny_permissions()        // Block set_permissions() calls
    .deny_symlinks()           // Block symlink() calls
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Sandboxing untrusted code (block permission changes)</li>
<li>Archive extraction (block symlink/hardlink creation)</li>
<li>Read-only-ish environments (block permission mutations)</li>
</ul>
<p><strong>Note:</strong> This controls operation <strong>availability</strong>. For symlink <strong>following</strong> behavior, see “Symlink Security” below.</p>
<h3 id="4-resource-limits-quota"><a class="header" href="#4-resource-limits-quota">4. Resource Limits (Quota)</a></h3>
<p><code>Quota</code> middleware enforces capacity limits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>QuotaLayer::builder()
    .max_total_size(100 * 1024 * 1024)  // 100 MB total
    .max_file_size(10 * 1024 * 1024)    // 10 MB per file
    .max_node_count(10_000)             // Max files/dirs
    .max_dir_entries(1_000)             // Max per directory
    .max_path_depth(64)                 // Max nesting
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Guarantees:</strong></p>
<ul>
<li>Writes rejected when limits exceeded</li>
<li>Streaming writes tracked via <code>CountingWriter</code></li>
</ul>
<h3 id="5-rate-limiting-ratelimit"><a class="header" href="#5-rate-limiting-ratelimit">5. Rate Limiting (RateLimit)</a></h3>
<p><code>RateLimit</code> middleware throttles operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RateLimitLayer::builder()
    .max_ops(1000)
    .per_second()
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Guarantees:</strong></p>
<ul>
<li>Operations rejected when limit exceeded</li>
<li>Protects against runaway processes</li>
</ul>
<h3 id="6-backend-level-containment"><a class="header" href="#6-backend-level-containment">6. Backend-Level Containment</a></h3>
<p>Different backends achieve containment differently:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Containment Mechanism</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Isolated in process memory</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Each container is a separate <code>.db</code> file</td></tr>
<tr><td><code>StdFsBackend</code></td><td><strong>None</strong> - full filesystem access (use <code>PathFilter</code> for sandboxing)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Uses <code>strict-path::VirtualRoot</code> to contain paths</td></tr>
</tbody>
</table>
</div>
<h3 id="7-why-virtual-backends-are-inherently-safe"><a class="header" href="#7-why-virtual-backends-are-inherently-safe">7. Why Virtual Backends Are Inherently Safe</a></h3>
<p>For <code>MemoryBackend</code> and <code>SqliteBackend</code>, the underlying storage is isolated from the host filesystem. There is no OS filesystem to exploit - paths operate entirely within the virtual structure.</p>
<p><strong>Path resolution is symlink-aware but contained</strong>: FileStorage resolves paths by walking the <em>virtual</em> directory structure (using <code>metadata()</code> and <code>read_link()</code> on the backend), not the OS filesystem:</p>
<pre><code>Virtual backend symlink example:
  /foo/bar  where bar → /other/place
  /foo/bar/..  resolves to /other (following the symlink target's parent)

This is correct filesystem semantics - but it happens entirely within
the virtual structure. There is no host filesystem to escape to.
</code></pre>
<p>This means:</p>
<ul>
<li><strong>No host filesystem access</strong> - symlinks point to paths within the virtual structure only</li>
<li><strong>No TOCTOU via OS state</strong> - resolution uses the backend’s own data</li>
<li><strong>Controllable via <code>set_follow_symlinks()</code></strong> - disable symlink following entirely if needed</li>
</ul>
<p>For <code>VRootFsBackend</code> (real filesystem), <code>strict-path::VirtualRoot</code> provides equivalent guarantees by validating and containing all paths before they reach the OS.</p>
<h3 id="8-symlink-security-virtual-vs-real-backends"><a class="header" href="#8-symlink-security-virtual-vs-real-backends">8. Symlink Security: Virtual vs Real Backends</a></h3>
<p><strong>The security concern with symlinks is <em>following</em> them, not <em>creating</em> them.</strong></p>
<p>Symlinks are just data. Creating <code>/sandbox/link -&gt; /etc/passwd</code> is harmless. The danger is when reading <code>/sandbox/link</code> follows the symlink and accesses <code>/etc/passwd</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Type</th><th>Symlink Creation</th><th>Symlink Following</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Always supported</td><td><strong>We control</strong> via <code>set_follow_symlinks()</code></td></tr>
<tr><td><code>SqliteBackend</code></td><td>Always supported</td><td><strong>We control</strong> via <code>set_follow_symlinks()</code></td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Always supported</td><td><strong>OS controls</strong> - <code>strict-path</code> prevents escapes</td></tr>
</tbody>
</table>
</div>
<h4 id="virtual-backends-memory-sqlite"><a class="header" href="#virtual-backends-memory-sqlite">Virtual Backends (Memory, SQLite)</a></h4>
<p>Virtual backends always support symlinks. They also provide control over symlink following:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = MemoryBackend::new();
backend.set_follow_symlinks(false);  // Don't follow symlinks during path resolution
<span class="boring">}</span></code></pre>
<p>When following is disabled:</p>
<ul>
<li><code>read("/link")</code> on a symlink returns <code>FsError::IsSymlink</code> (or reads link as opaque data)</li>
<li>Path resolution treats symlinks as terminal nodes</li>
</ul>
<p><strong>This is the actual security feature</strong> - controlling whether symlinks are resolved.</p>
<h4 id="real-filesystem-backend-vrootfsbackend"><a class="header" href="#real-filesystem-backend-vrootfsbackend">Real Filesystem Backend (VRootFsBackend)</a></h4>
<p>VRootFsBackend calls OS functions (<code>std::fs::read()</code>, etc.) which follow symlinks automatically. <strong>We cannot control this</strong> - the OS does the symlink resolution, not us.</p>
<p><code>strict-path::VirtualRoot</code> prevents <strong>escapes</strong>:</p>
<pre><code>User requests: /sandbox/link
link -&gt; ../../../etc/passwd
strict-path: canonicalize(/sandbox/link) = /etc/passwd
strict-path: /etc/passwd is NOT within /sandbox → DENIED
</code></pre>
<p>This is “follow and verify containment” - symlinks are followed by the OS, but escapes are blocked by strict-path.</p>
<p><strong>Limitation:</strong> Symlinks within the jail are followed. We cannot disable this without implementing custom path resolution (TOCTOU risk) or platform-specific hacks.</p>
<h4 id="summary-1"><a class="header" href="#summary-1">Summary</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Virtual Backend</th><th>VRootFsBackend</th></tr>
</thead>
<tbody>
<tr><td>Symlink creation</td><td>Always allowed (just data)</td><td>Always allowed (just data)</td></tr>
<tr><td>Symlink following</td><td><code>set_follow_symlinks(bool)</code></td><td>OS controls (strict-path prevents escapes)</td></tr>
<tr><td>Jail escape via symlink</td><td><code>set_follow_symlinks(false)</code></td><td>Prevented by strict-path</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="secure-usage-patterns"><a class="header" href="#secure-usage-patterns">Secure Usage Patterns</a></h2>
<h3 id="ai-agent-sandbox"><a class="header" href="#ai-agent-sandbox">AI Agent Sandbox</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, PathFilterLayer, RestrictionsLayer, RateLimitLayer, TracingLayer, FileStorage};

let sandbox = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(50 * 1024 * 1024)
        .max_file_size(5 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_symlinks()
        .deny_hard_links()
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .deny("**/secrets/**")
        .build())
    .layer(RateLimitLayer::builder()
        .max_ops(1000)
        .per_second()
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(sandbox);
// Agent code can only access /workspace, limited resources, audited
<span class="boring">}</span></code></pre>
<h3 id="multi-tenant-isolation"><a class="header" href="#multi-tenant-isolation">Multi-Tenant Isolation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Quota, FileStorage};

fn create_tenant_storage(tenant_id: &amp;str, quota_bytes: u64) -&gt; FileStorage&lt;impl Fs&gt; {
    let db_path = format!("tenants/{}.db", tenant_id);
    let backend = QuotaLayer::builder()
        .max_total_size(quota_bytes)
        .build()
        .layer(SqliteBackend::open(&amp;db_path).unwrap());

    FileStorage::new(backend)
}

// Complete isolation: separate database files
<span class="boring">}</span></code></pre>
<h3 id="read-only-browsing"><a class="header" href="#read-only-browsing">Read-Only Browsing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, ReadOnly, FileStorage};

let readonly_fs = FileStorage::new(
    ReadOnly::new(SqliteBackend::open("archive.db")?)
);

// All write operations return FsError::ReadOnly
<span class="boring">}</span></code></pre>
<hr>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security Checklist</a></h2>
<h3 id="for-application-developers"><a class="header" href="#for-application-developers">For Application Developers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Use <code>PathFilter</code> to sandbox untrusted code</li>
<li><input disabled="" type="checkbox"> Use <code>Quota</code> to prevent resource exhaustion</li>
<li><input disabled="" type="checkbox"> Use <code>Restrictions</code> (default) to disable dangerous features</li>
<li><input disabled="" type="checkbox"> Use <code>RateLimit</code> for untrusted/shared environments</li>
<li><input disabled="" type="checkbox"> Use <code>Tracing</code> for audit trails</li>
<li><input disabled="" type="checkbox"> Use separate backends for separate tenants</li>
<li><input disabled="" type="checkbox"> Keep dependencies updated</li>
</ul>
<h3 id="for-backend-implementers"><a class="header" href="#for-backend-implementers">For Backend Implementers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Ensure paths cannot escape intended scope</li>
<li><input disabled="" type="checkbox"> For filesystem backends: use <code>strict-path</code> for containment</li>
<li><input disabled="" type="checkbox"> Handle concurrent access safely</li>
<li><input disabled="" type="checkbox"> Don’t leak internal paths in errors</li>
</ul>
<h3 id="for-middleware-implementers"><a class="header" href="#for-middleware-implementers">For Middleware Implementers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Handle streaming I/O appropriately (wrap or block)</li>
<li><input disabled="" type="checkbox"> Document which operations are intercepted</li>
<li><input disabled="" type="checkbox"> Fail closed (deny on error)</li>
</ul>
<hr>
<h2 id="encryption-and-integrity-protection"><a class="header" href="#encryption-and-integrity-protection">Encryption and Integrity Protection</a></h2>
<p>AnyFS’s design enables encryption at multiple levels. Understanding the difference between <strong>container-level</strong> and <strong>file-level</strong> protection is crucial for choosing the right approach.</p>
<h3 id="container-level-vs-file-level-protection"><a class="header" href="#container-level-vs-file-level-protection">Container-Level vs File-Level Protection</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>What’s Protected</th><th>Integrity</th><th>Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>Container-level</strong></td><td>Entire storage medium (<code>.db</code> file, serialized state)</td><td>Full structure protected</td><td>Encrypted backend</td></tr>
<tr><td><strong>File-level</strong></td><td>Individual file contents</td><td>File contents only</td><td>Encryption middleware</td></tr>
</tbody>
</table>
</div>
<p><strong>Key insight:</strong> File-level encryption alone is NOT sufficient. If an attacker can modify the container structure (directory tree, metadata, file names), they can sabotage integrity even without decrypting file contents.</p>
<h3 id="threat-analysis"><a class="header" href="#threat-analysis">Threat Analysis</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>File-Level Encryption</th><th>Container-Level Encryption</th></tr>
</thead>
<tbody>
<tr><td>Read file contents</td><td>Protected</td><td>Protected</td></tr>
<tr><td>Modify file contents</td><td>Detected (with AEAD)</td><td>Detected</td></tr>
<tr><td>Delete files</td><td><strong>NOT protected</strong></td><td>Protected</td></tr>
<tr><td>Rename/move files</td><td><strong>NOT protected</strong></td><td>Protected</td></tr>
<tr><td>Corrupt directory structure</td><td><strong>NOT protected</strong></td><td>Protected</td></tr>
<tr><td>Replay old file versions</td><td><strong>NOT protected</strong></td><td>Protected (with versioning)</td></tr>
<tr><td>Metadata exposure (filenames, sizes)</td><td><strong>NOT protected</strong></td><td>Protected</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> For sensitive data, prefer container-level encryption. Use file-level encryption when you need selective access (some files encrypted, others not).</p>
<h3 id="container-level-encryption"><a class="header" href="#container-level-encryption">Container-Level Encryption</a></h3>
<h4 id="option-1-sqlcipher-backend"><a class="header" href="#option-1-sqlcipher-backend">Option 1: SQLCipher Backend</a></h4>
<p><a href="https://www.zetetic.net/sqlcipher/">SQLCipher</a> provides transparent AES-256 encryption for SQLite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// SQLite backend with full database encryption via SQLCipher.
pub struct SqliteCipherBackend {
    conn: rusqlite::Connection,  // Built with sqlcipher feature
}

impl SqliteCipherBackend {
    pub fn open(path: &amp;str, password: &amp;str) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path)?;
        // SQLCipher: derive key from password, encrypt everything
        conn.pragma_update(None, "key", password)?;
        Ok(Self { conn })
    }

    pub fn open_with_key(path: &amp;str, key: &amp;[u8; 32]) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path)?;
        // Use raw key instead of password
        conn.pragma_update(None, "key", &amp;format!("x'{}'", hex::encode(key)))?;
        Ok(Self { conn })
    }
}

impl Fs for SqliteCipherBackend { /* same as SqliteBackend */ }
<span class="boring">}</span></code></pre>
<p><strong>What’s protected:</strong></p>
<ul>
<li>All file contents</li>
<li>All metadata (names, sizes, timestamps, permissions)</li>
<li>Directory structure</li>
<li>Inode mappings</li>
<li>Everything in the <code>.db</code> file</li>
</ul>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = SqliteCipherBackend::open("secure.db", "correct-horse-battery-staple")?;
let fs = FileStorage::new(backend);

// If someone gets secure.db without the password, they see random bytes
<span class="boring">}</span></code></pre>
<h4 id="option-2-encrypted-serialization-memorybackend"><a class="header" href="#option-2-encrypted-serialization-memorybackend">Option 2: Encrypted Serialization (MemoryBackend)</a></h4>
<p>For in-memory backends that need persistence:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MemoryBackend {
    /// Serialize entire state to encrypted blob.
    pub fn serialize_encrypted(&amp;self, key: &amp;[u8; 32]) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let plaintext = bincode::serialize(&amp;self.state)?;
        let nonce = generate_nonce();
        let ciphertext = aes_gcm_encrypt(key, &amp;nonce, &amp;plaintext)?;
        Ok([nonce.as_slice(), &amp;ciphertext].concat())
    }

    /// Deserialize from encrypted blob.
    pub fn deserialize_encrypted(data: &amp;[u8], key: &amp;[u8; 32]) -&gt; Result&lt;Self, FsError&gt; {
        let (nonce, ciphertext) = data.split_at(12);
        let plaintext = aes_gcm_decrypt(key, nonce, ciphertext)?;
        let state = bincode::deserialize(&amp;plaintext)?;
        Ok(Self { state })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Use case:</strong> Periodically save encrypted snapshots, load on startup.</p>
<h3 id="file-level-encryption-middleware"><a class="header" href="#file-level-encryption-middleware">File-Level Encryption (Middleware)</a></h3>
<p>When you need selective encryption or per-file keys:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Middleware that encrypts file contents on write, decrypts on read.
/// Does NOT protect metadata, filenames, or directory structure.
pub struct FileEncryption&lt;B&gt; {
    inner: B,
    key: Secret&lt;[u8; 32]&gt;,
}

impl&lt;B: Fs&gt; FsWrite for FileEncryption&lt;B&gt; {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        // Encrypt content with authenticated encryption (AES-GCM)
        let nonce = generate_nonce();
        let ciphertext = aes_gcm_encrypt(&amp;self.key, &amp;nonce, data)?;
        let encrypted = [nonce.as_slice(), &amp;ciphertext].concat();
        self.inner.write(path, &amp;encrypted)
    }
}

impl&lt;B: Fs&gt; FsRead for FileEncryption&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let encrypted = self.inner.read(path)?;
        let (nonce, ciphertext) = encrypted.split_at(12);
        aes_gcm_decrypt(&amp;self.key, nonce, ciphertext)
            .map_err(|_| FsError::IntegrityError { path: path.as_ref().to_path_buf() })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li>Filenames visible</li>
<li>Directory structure visible</li>
<li>File sizes visible (roughly - ciphertext slightly larger)</li>
<li>Metadata unprotected</li>
</ul>
<p><strong>When to use:</strong></p>
<ul>
<li>Some files need encryption, others don’t</li>
<li>Different files need different keys</li>
<li>Interop with systems that expect plaintext structure</li>
</ul>
<h3 id="integrity-without-encryption"><a class="header" href="#integrity-without-encryption">Integrity Without Encryption</a></h3>
<p>Sometimes you need tamper detection without hiding contents:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Middleware that adds HMAC to each file for integrity verification.
pub struct IntegrityVerified&lt;B&gt; {
    inner: B,
    key: Secret&lt;[u8; 32]&gt;,
}

impl&lt;B: Fs&gt; FsWrite for IntegrityVerified&lt;B&gt; {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let mac = hmac_sha256(&amp;self.key, data);
        let protected = [data, mac.as_slice()].concat();
        self.inner.write(path, &amp;protected)
    }
}

impl&lt;B: Fs&gt; FsRead for IntegrityVerified&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let protected = self.inner.read(path)?;
        let (data, mac) = protected.split_at(protected.len() - 32);
        if !hmac_verify(&amp;self.key, data, mac) {
            return Err(FsError::IntegrityError { path: path.as_ref().to_path_buf() });
        }
        Ok(data.to_vec())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="ram-encryption-and-secure-memory"><a class="header" href="#ram-encryption-and-secure-memory">RAM Encryption and Secure Memory</a></h3>
<p>For high-security scenarios where memory dumps are a threat:</p>
<h4 id="threat-levels"><a class="header" href="#threat-levels">Threat Levels</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Mitigation</th><th>Library-Level?</th></tr>
</thead>
<tbody>
<tr><td>Memory inspection after process exit</td><td><code>zeroize</code> on drop</td><td>Yes</td></tr>
<tr><td>Core dumps</td><td>Disable via <code>setrlimit</code></td><td>Yes (process config)</td></tr>
<tr><td>Swap file exposure</td><td><code>mlock()</code> to pin pages</td><td>Yes (OS permitting)</td></tr>
<tr><td>Live memory scanning (same user)</td><td>OS process isolation</td><td>No</td></tr>
<tr><td>Cold boot attack</td><td>Hardware RAM encryption</td><td>No (Intel TME/AMD SME)</td></tr>
<tr><td>Hypervisor/DMA attack</td><td>SGX/SEV enclaves</td><td>No (hardware)</td></tr>
</tbody>
</table>
</div>
<h4 id="encrypted-memory-backend-illustrative-pattern"><a class="header" href="#encrypted-memory-backend-illustrative-pattern">Encrypted Memory Backend (Illustrative Pattern)</a></h4>
<blockquote>
<p><strong>Note:</strong> <code>EncryptedMemoryBackend</code> is an illustrative pattern for users who need encrypted RAM storage. It is not a built-in backend in v1. Users can implement this pattern using the guidance below.</p>
</blockquote>
<p>Keep data encrypted even in RAM - decrypt only during active use:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use zeroize::{Zeroize, ZeroizeOnDrop};
use secrecy::Secret;

/// Memory backend that stores all data encrypted in RAM.
/// Plaintext exists only briefly during read operations.
pub struct EncryptedMemoryBackend {
    /// All nodes stored as encrypted blobs
    nodes: HashMap&lt;PathBuf, EncryptedNode&gt;,
    /// Encryption key - auto-zeroized on drop
    key: Secret&lt;[u8; 32]&gt;,
}

struct EncryptedNode {
    /// Encrypted file content (nonce || ciphertext)
    encrypted_data: Vec&lt;u8&gt;,
    /// Metadata can be encrypted too, or stored in the encrypted blob
    metadata: EncryptedMetadata,
}

impl FsRead for EncryptedMemoryBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let node = self.nodes.get(path.as_ref())
            .ok_or_else(|| FsError::NotFound { path: path.as_ref().to_path_buf() })?;

        // Decrypt - plaintext briefly in RAM
        let plaintext = self.decrypt(&amp;node.encrypted_data)?;

        // Return owned Vec - caller responsible for zeroizing if sensitive
        Ok(plaintext)
    }
}

impl FsWrite for EncryptedMemoryBackend {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        // Encrypt immediately - plaintext never stored
        let encrypted = self.encrypt(data)?;

        self.nodes.insert(path.as_ref().to_path_buf(), EncryptedNode {
            encrypted_data: encrypted,
            metadata: self.encrypt_metadata(...)?,
        });
        Ok(())
    }
}

impl Drop for EncryptedMemoryBackend {
    fn drop(&amp;mut self) {
        // Zeroize all encrypted data (defense in depth)
        for node in self.nodes.values_mut() {
            node.encrypted_data.zeroize();
        }
        // Key is auto-zeroized via Secret&lt;&gt;
    }
}
<span class="boring">}</span></code></pre>
<h4 id="serialization-of-encrypted-ram"><a class="header" href="#serialization-of-encrypted-ram">Serialization of Encrypted RAM</a></h4>
<p>When persisting an encrypted memory backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EncryptedMemoryBackend {
    /// Serialize to disk - data stays encrypted throughout.
    /// RAM encrypted → Serialized encrypted → Disk encrypted
    pub fn save_to_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        // Data is already encrypted in self.nodes
        // Serialize the encrypted blobs directly - no decryption needed
        let serialized = bincode::serialize(&amp;self.nodes)?;

        // Optionally add another encryption layer with different key
        // (defense in depth: compromise of runtime key doesn't expose persisted data)
        std::fs::write(path, &amp;serialized)?;
        Ok(())
    }

    /// Load from disk - data stays encrypted throughout.
    /// Disk encrypted → Deserialized encrypted → RAM encrypted
    pub fn load_from_file(path: &amp;Path, key: Secret&lt;[u8; 32]&gt;) -&gt; Result&lt;Self, FsError&gt; {
        let serialized = std::fs::read(path)?;
        let nodes = bincode::deserialize(&amp;serialized)?;

        Ok(Self { nodes, key })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key property:</strong> Plaintext NEVER exists during save/load. Data flows:</p>
<pre><code>Write: plaintext → encrypt → RAM (encrypted) → serialize → disk (encrypted)
Read:  disk (encrypted) → deserialize → RAM (encrypted) → decrypt → plaintext
</code></pre>
<h4 id="secure-allocator-considerations"><a class="header" href="#secure-allocator-considerations">Secure Allocator Considerations</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In Cargo.toml - mimalloc secure mode zeros on free
mimalloc = { version = "0.1", features = ["secure"] }

// Note: This prevents USE-AFTER-FREE info leaks, but does NOT:
// - Encrypt RAM contents
// - Prevent live memory scanning
// - Protect against cold boot attacks
<span class="boring">}</span></code></pre>
<p>For true defense against memory scanning, combine:</p>
<ol>
<li><code>EncryptedMemoryBackend</code> (data encrypted at rest in RAM)</li>
<li><code>zeroize</code> (immediate cleanup of temporary plaintext)</li>
<li><code>mlock()</code> (prevent swapping sensitive pages)</li>
<li>Minimize plaintext lifetime (decrypt → use → zeroize immediately)</li>
</ol>
<h3 id="encryption-summary"><a class="header" href="#encryption-summary">Encryption Summary</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Protects Contents</th><th>Protects Structure</th><th>RAM Security</th><th>Persistence</th></tr>
</thead>
<tbody>
<tr><td><code>SqliteCipherBackend</code></td><td>Yes</td><td>Yes</td><td>No (SQLite uses plaintext RAM)</td><td>Encrypted <code>.db</code> file</td></tr>
<tr><td><code>FileEncryption&lt;B&gt;</code> middleware</td><td>Yes</td><td>No</td><td>Depends on B</td><td>Depends on B</td></tr>
<tr><td><code>EncryptedMemoryBackend</code> (illustrative)</td><td>Yes</td><td>Yes</td><td>Yes (encrypted in RAM)</td><td>Via <code>save_to_file()</code></td></tr>
<tr><td><code>IntegrityVerified&lt;B&gt;</code> middleware</td><td>No</td><td>No (files only)</td><td>No</td><td>Depends on B</td></tr>
</tbody>
</table>
</div>
<h3 id="recommended-configurations"><a class="header" href="#recommended-configurations">Recommended Configurations</a></h3>
<h4 id="sensitive-data-storage"><a class="header" href="#sensitive-data-storage">Sensitive Data Storage</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Full protection: encrypted container + secure memory practices
let backend = SqliteCipherBackend::open("secure.db", password)?;
let fs = FileStorage::new(backend);
<span class="boring">}</span></code></pre>
<h4 id="high-security-ram-processing-illustrative"><a class="header" href="#high-security-ram-processing-illustrative">High-Security RAM Processing (Illustrative)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Data never plaintext at rest (RAM or disk)
// Note: EncryptedMemoryBackend is user-implemented (see pattern above)
let backend = EncryptedMemoryBackend::new(derive_key(password));
// ... use fs ...
backend.save_to_file("snapshot.enc")?;  // Persists encrypted
<span class="boring">}</span></code></pre>
<h4 id="selective-file-encryption"><a class="header" href="#selective-file-encryption">Selective File Encryption</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Some files encrypted, structure visible
let backend = FileEncryption::new(SqliteBackend::open("data.db")?)
    .with_key(key);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="toctou-proof-tenant-isolation-with-virtual-backends"><a class="header" href="#toctou-proof-tenant-isolation-with-virtual-backends">TOCTOU-Proof Tenant Isolation with Virtual Backends</a></h2>
<h3 id="why-virtual-backends-eliminate-toctou"><a class="header" href="#why-virtual-backends-eliminate-toctou">Why Virtual Backends Eliminate TOCTOU</a></h3>
<p>Traditional path security libraries like <code>strict-path</code> work against a <strong>real filesystem</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    REAL FILESYSTEM SECURITY                      │
│                                                                  │
│   Your Process          OS Filesystem         Other Processes   │
│   ┌──────────┐         ┌───────────┐         ┌──────────────┐   │
│   │ Check    │────────▶│ Canonical │◀────────│ Create       │   │
│   │ path     │         │ path      │         │ symlink      │   │
│   └──────────┘         └───────────┘         └──────────────┘   │
│        │                     │                      │           │
│        │    TOCTOU WINDOW    │                      │           │
│        ▼                     ▼                      ▼           │
│   ┌──────────┐         ┌───────────┐         ┌──────────────┐   │
│   │ Use      │────────▶│ DIFFERENT │◀────────│ Modified!    │   │
│   │ path     │         │ path now! │         │              │   │
│   └──────────┘         └───────────┘         └──────────────┘   │
│                                                                  │
│   Problem: OS state can change between check and use             │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p>Virtual backends eliminate this entirely:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                   VIRTUAL BACKEND SECURITY                       │
│                                                                  │
│   Your Process                                                   │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    FileStorage                           │   │
│   │  ┌──────────┐    ┌───────────┐    ┌──────────────────┐  │   │
│   │  │ Resolve  │───▶│ SQLite    │───▶│ Return data      │  │   │
│   │  │ path     │    │ Transaction│   │                  │  │   │
│   │  └──────────┘    └───────────┘    └──────────────────┘  │   │
│   │                        │                                 │   │
│   │              ATOMIC - No external modification possible  │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   No OS filesystem. No other processes. No TOCTOU.               │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="security-comparison-strict-path-vs-virtual-backend"><a class="header" href="#security-comparison-strict-path-vs-virtual-backend">Security Comparison: strict-path vs Virtual Backend</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>strict-path (Real FS)</th><th>Virtual Backend</th></tr>
</thead>
<tbody>
<tr><td>Path traversal</td><td>Prevented (canonicalize + verify)</td><td><strong>Impossible</strong> (no host FS to traverse to)</td></tr>
<tr><td>Symlink race (TOCTOU)</td><td>Mitigated (canonicalize first)</td><td><strong>Impossible</strong> (we control all symlinks)</td></tr>
<tr><td>External symlink creation</td><td>Vulnerable window exists</td><td><strong>Impossible</strong> (single-process ownership)</td></tr>
<tr><td>Windows 8.3 short names</td><td>Partial (only existing files)</td><td><strong>N/A</strong> (no Windows FS)</td></tr>
<tr><td>Namespace escapes (/proc)</td><td>Fixed in soft-canonicalize</td><td><strong>Impossible</strong> (no /proc exists)</td></tr>
<tr><td>Concurrent modification</td><td>OS handles (may race)</td><td><strong>Atomic</strong> (SQLite transactions)</td></tr>
<tr><td>Tenant A accessing Tenant B</td><td>Requires careful path filtering</td><td><strong>Impossible</strong> (separate .db files)</td></tr>
</tbody>
</table>
</div>
<h3 id="encryption-separation-of-concerns"><a class="header" href="#encryption-separation-of-concerns">Encryption: Separation of Concerns</a></h3>
<p><strong>Design principle:</strong> Backends handle storage, middleware handles policy. Container-level encryption is the exception.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Security Level</th><th>Implementation</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td><strong>Locked (container)</strong></td><td><code>SqliteCipherBackend</code></td><td>Must encrypt entire <code>.db</code> file at storage level</td></tr>
<tr><td><strong>Privacy (file contents)</strong></td><td><code>FileEncryption&lt;SqliteBackend&gt;</code> middleware</td><td>Content encryption is policy</td></tr>
<tr><td><strong>Normal</strong></td><td><code>SqliteBackend</code></td><td>User applies encryption as needed</td></tr>
</tbody>
</table>
</div>
<p><strong>Why Locked mode requires a separate backend:</strong></p>
<ul>
<li>SQLCipher encrypts the entire database file transparently</li>
<li>Connection must be opened with password before ANY query</li>
<li>Cannot be added as middleware - it’s a property of the connection itself</li>
<li>Everything is encrypted: file contents, filenames, directory structure, timestamps, inodes</li>
</ul>
<h3 id="sqlitecipherbackend-built-in-feature-sqlite-cipher"><a class="header" href="#sqlitecipherbackend-built-in-feature-sqlite-cipher">SqliteCipherBackend (Built-in, feature: <code>sqlite-cipher</code>)</a></h3>
<p>Full container encryption using <a href="https://www.zetetic.net/sqlcipher/">SQLCipher</a>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// SQLite backend with full AES-256 encryption via SQLCipher.
/// Requires `sqlite-cipher` feature (uses rusqlite with bundled-sqlcipher).
///
/// Without the password, the .db file is indistinguishable from random bytes.
pub struct SqliteCipherBackend {
    conn: Connection,
}

impl SqliteCipherBackend {
    /// Open with password (derives key via PBKDF2).
    pub fn open(path: impl AsRef&lt;Path&gt;, password: &amp;str) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path.as_ref())?;

        // SQLCipher: Set encryption key derived from password
        conn.pragma_update(None, "key", password)?;

        // Verify we can read (wrong password = SQLITE_NOTADB)
        conn.query_row("SELECT count(*) FROM sqlite_master", [], |_| Ok(()))
            .map_err(|_| FsError::InvalidPassword)?;

        Self::init_schema(&amp;conn)?;
        Ok(Self { conn })
    }

    /// Open with raw 256-bit key (no key derivation).
    pub fn open_with_key(path: impl AsRef&lt;Path&gt;, key: &amp;[u8; 32]) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path.as_ref())?;

        // SQLCipher: Set raw key (hex-encoded with x'' prefix)
        let hex_key = format!("x'{}'", hex::encode(key));
        conn.pragma_update(None, "key", &amp;hex_key)?;

        conn.query_row("SELECT count(*) FROM sqlite_master", [], |_| Ok(()))
            .map_err(|_| FsError::InvalidPassword)?;

        Self::init_schema(&amp;conn)?;
        Ok(Self { conn })
    }

    /// Create new encrypted database with password.
    pub fn create(path: impl AsRef&lt;Path&gt;, password: &amp;str) -&gt; Result&lt;Self, FsError&gt; {
        if path.as_ref().exists() {
            return Err(FsError::AlreadyExists { path: path.as_ref().to_path_buf(), operation: "create" });
        }
        Self::open(path, password)
    }

    /// Change the password on an open database.
    pub fn change_password(&amp;self, new_password: &amp;str) -&gt; Result&lt;(), FsError&gt; {
        self.conn.pragma_update(None, "rekey", new_password)?;
        Ok(())
    }

    fn init_schema(conn: &amp;Connection) -&gt; Result&lt;(), FsError&gt; {
        conn.execute_batch(r#"
            -- Node table: directories, files, symlinks
            CREATE TABLE IF NOT EXISTS nodes (
                inode INTEGER PRIMARY KEY,
                parent_inode INTEGER NOT NULL,
                name TEXT NOT NULL,
                node_type INTEGER NOT NULL,  -- 0=file, 1=dir, 2=symlink
                size INTEGER NOT NULL DEFAULT 0,
                mode INTEGER NOT NULL DEFAULT 0o644,
                nlink INTEGER NOT NULL DEFAULT 1,
                uid INTEGER NOT NULL DEFAULT 0,
                gid INTEGER NOT NULL DEFAULT 0,
                created_at INTEGER,
                modified_at INTEGER,
                accessed_at INTEGER,
                symlink_target TEXT,
                UNIQUE(parent_inode, name),
                FOREIGN KEY (parent_inode) REFERENCES nodes(inode)
            );

            -- Content table: file data (separate for efficient large files)
            CREATE TABLE IF NOT EXISTS content (
                inode INTEGER PRIMARY KEY,
                data BLOB NOT NULL,
                FOREIGN KEY (inode) REFERENCES nodes(inode) ON DELETE CASCADE
            );

            -- Index for directory listing performance
            CREATE INDEX IF NOT EXISTS idx_parent ON nodes(parent_inode);

            -- Root directory (inode 1, parent is self)
            INSERT OR IGNORE INTO nodes (inode, parent_inode, name, node_type, mode)
            VALUES (1, 1, '', 1, 0o755);
        "#)?;
        Ok(())
    }
}

// Implements same traits as SqliteBackend - only difference is encrypted storage
impl Fs for SqliteCipherBackend { /* ... */ }
impl FsFull for SqliteCipherBackend { /* ... */ }
impl FsFuse for SqliteCipherBackend { /* ... */ }
<span class="boring">}</span></code></pre>
<h4 id="what-sqlcipher-encrypts"><a class="header" href="#what-sqlcipher-encrypts">What SQLCipher Encrypts</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Data</th><th>Encrypted?</th></tr>
</thead>
<tbody>
<tr><td>File contents</td><td>Yes</td></tr>
<tr><td>Filenames</td><td>Yes</td></tr>
<tr><td>Directory structure</td><td>Yes</td></tr>
<tr><td>File sizes</td><td>Yes</td></tr>
<tr><td>Timestamps</td><td>Yes</td></tr>
<tr><td>Permissions</td><td>Yes</td></tr>
<tr><td>Inode mappings</td><td>Yes</td></tr>
<tr><td>SQLite metadata</td><td>Yes</td></tr>
<tr><td><strong>Everything in the .db file</strong></td><td><strong>Yes</strong></td></tr>
</tbody>
</table>
</div>
<h4 id="cargo-configuration"><a class="header" href="#cargo-configuration">Cargo Configuration</a></h4>
<pre><code class="language-toml">[dependencies]
# Regular SQLite (no encryption)
rusqlite = { version = "0.31", features = ["bundled"] }

# SQLCipher (full encryption) - mutually exclusive with above
rusqlite = { version = "0.31", features = ["bundled-sqlcipher"] }
</code></pre>
<p><strong>Feature flags in anyfs:</strong></p>
<pre><code class="language-toml">[features]
default = ["memory"]
sqlite = ["rusqlite/bundled"]
sqlite-cipher = ["rusqlite/bundled-sqlcipher"]  # Replaces sqlite
</code></pre>
<p><strong>Note:</strong> <code>sqlite</code> and <code>sqlite-cipher</code> are mutually exclusive. SQLCipher is a drop-in replacement with the same schema and API.</p>
<h3 id="achieving-security-modes-with-composition"><a class="header" href="#achieving-security-modes-with-composition">Achieving Security Modes with Composition</a></h3>
<p>Users compose backends and middleware to achieve their desired security level:</p>
<h4 id="locked-mode-full-container-encryption"><a class="header" href="#locked-mode-full-container-encryption">Locked Mode (Full Container Encryption)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Everything encrypted - password required to access anything
let backend = SqliteCipherBackend::open("tenant.db", "correct-horse-battery-staple")?;
let fs = FileStorage::new(backend);

// Without password: .db file is random bytes
// With password: full access to everything
<span class="boring">}</span></code></pre>
<h4 id="privacy-mode-contents-encrypted-metadata-visible"><a class="header" href="#privacy-mode-contents-encrypted-metadata-visible">Privacy Mode (Contents Encrypted, Metadata Visible)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File contents encrypted, metadata (names, sizes, structure) visible
let backend = FileEncryption::new(
    SqliteBackend::open("tenant.db")?
)
.with_key(content_key);

let fs = FileStorage::new(backend);

// Host can: list files, see sizes, run statistics
// Host cannot: read file contents
<span class="boring">}</span></code></pre>
<h4 id="normal-mode-no-encryption"><a class="header" href="#normal-mode-no-encryption">Normal Mode (No Encryption)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// No encryption - user encrypts sensitive files themselves
let backend = SqliteBackend::open("tenant.db")?;
let fs = FileStorage::new(backend);

// User applies per-file encryption as needed
<span class="boring">}</span></code></pre>
<h4 id="mode-comparison"><a class="header" href="#mode-comparison">Mode Comparison</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Locked</th><th>Privacy</th><th>Normal</th></tr>
</thead>
<tbody>
<tr><td>Implementation</td><td><code>SqliteCipherBackend</code></td><td><code>FileEncryption&lt;SqliteBackend&gt;</code></td><td><code>SqliteBackend</code></td></tr>
<tr><td>File contents</td><td>Encrypted (SQLCipher)</td><td>Encrypted (AES-GCM)</td><td>Plaintext</td></tr>
<tr><td>Filenames</td><td>Encrypted</td><td>Visible</td><td>Visible</td></tr>
<tr><td>Directory structure</td><td>Encrypted</td><td>Visible</td><td>Visible</td></tr>
<tr><td>File sizes</td><td>Encrypted</td><td>Visible</td><td>Visible</td></tr>
<tr><td>Timestamps</td><td>Encrypted</td><td>Visible</td><td>Visible</td></tr>
<tr><td>Host can analyze</td><td>Nothing</td><td>Metadata only</td><td>Everything</td></tr>
<tr><td>Performance</td><td>Slowest (~10-15% overhead)</td><td>Medium</td><td>Fastest</td></tr>
<tr><td>Feature flag</td><td><code>sqlite-cipher</code></td><td><code>sqlite</code> + middleware</td><td><code>sqlite</code></td></tr>
</tbody>
</table>
</div>
<h4 id="why-this-is-toctou-proof"><a class="header" href="#why-this-is-toctou-proof">Why This Is TOCTOU-Proof</a></h4>
<ol>
<li><strong>No external filesystem</strong> - Paths exist only in our SQLite tables</li>
<li><strong>Atomic transactions</strong> - Path resolution + data access in single transaction</li>
<li><strong>Single-process ownership</strong> - No other process can modify the .db during operation</li>
<li><strong>We control symlinks</strong> - Symlinks are just rows in <code>nodes</code> table, we decide when to follow</li>
<li><strong>No OS involvement</strong> - OS never resolves our virtual paths</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is TOCTOU-proof:
impl SecureSqliteBackend {
    fn resolve_and_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Single transaction wraps everything
        let tx = self.conn.transaction()?;

        // 1. Resolve path (following symlinks in OUR table)
        let inode = self.resolve_path_internal(&amp;tx, path)?;

        // 2. Read content
        // No TOCTOU - same transaction, same snapshot
        let data = tx.query_row(
            "SELECT data FROM content WHERE inode = ?",
            [inode],
            |row| row.get(0)
        )?;

        // Transaction ensures atomicity
        Ok(data)
    }
}
<span class="boring">}</span></code></pre>
<h4 id="multi-tenant-isolation-1"><a class="header" href="#multi-tenant-isolation-1">Multi-Tenant Isolation</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Each tenant gets their own .db file - complete physical isolation
fn create_tenant_storage(tenant_id: &amp;str, encrypted: bool) -&gt; impl Fs {
    let path = format!("tenants/{}.db", tenant_id);

    if encrypted {
        let password = get_tenant_password(tenant_id);
        SqliteCipherBackend::open(&amp;path, &amp;password).unwrap()
    } else {
        SqliteBackend::open(&amp;path).unwrap()
    }
}

// Tenant A literally cannot access Tenant B's data:
// - Different .db files
// - Different passwords (if encrypted)
// - No shared state whatsoever
// - No path filtering bugs possible - there's nothing to filter
<span class="boring">}</span></code></pre>
<p><strong>Comparison with strict-path approach:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Tenant Isolation</th></tr>
</thead>
<tbody>
<tr><td>Shared filesystem + strict-path</td><td>Logical isolation (paths filtered)</td></tr>
<tr><td>Shared filesystem + PathFilter</td><td>Logical isolation (middleware enforced)</td></tr>
<tr><td><strong>Separate .db file per tenant</strong></td><td><strong>Physical isolation (separate files)</strong></td></tr>
</tbody>
</table>
</div>
<p>Physical isolation is strictly stronger - there’s no bug in path filtering that could leak data because <strong>there’s no shared data to leak</strong>.</p>
<h4 id="host-analysis-with-privacy-mode"><a class="header" href="#host-analysis-with-privacy-mode">Host Analysis with Privacy Mode</a></h4>
<p>When using <code>FileEncryption&lt;SqliteBackend&gt;</code> (Privacy mode), the host can query metadata directly from SQLite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Host can analyze metadata without the content encryption key
fn get_tenant_statistics(tenant_db: &amp;str) -&gt; TenantStats {
    // Connect directly to SQLite (no content key needed)
    let conn = Connection::open(tenant_db)?;

    let (file_count, dir_count, total_size) = conn.query_row(
        "SELECT
            COUNT(*) FILTER (WHERE node_type = 0),
            COUNT(*) FILTER (WHERE node_type = 1),
            SUM(size)
         FROM nodes",
        [],
        |row| Ok((row.get(0)?, row.get(1)?, row.get(2)?))
    )?;

    TenantStats { file_count, dir_count, total_size }
}

// List all files (names visible, contents encrypted)
fn list_tenant_files(tenant_db: &amp;str) -&gt; Vec&lt;FileInfo&gt; {
    let conn = Connection::open(tenant_db)?;
    conn.prepare("SELECT name, size, modified_at FROM nodes WHERE node_type = 0")?
        .query_map([], |row| Ok(FileInfo { ... }))?
        .collect()
}
<span class="boring">}</span></code></pre>
<h4 id="replacing-strict-path-usage"><a class="header" href="#replacing-strict-path-usage">Replacing strict-path Usage</a></h4>
<p>For projects currently using strict-path for tenant isolation:</p>
<p><strong>Before (strict-path):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualRoot;

fn handle_tenant_request(tenant_id: &amp;str, requested_path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    // Shared filesystem, path containment via strict-path
    let root = VirtualRoot::new(format!("/data/tenants/{}", tenant_id))?;
    let safe_path = root.resolve(requested_path)?;  // TOCTOU window here
    std::fs::read(safe_path)  // Another process could have modified
}
<span class="boring">}</span></code></pre>
<p><strong>After (SqliteCipherBackend):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteCipherBackend;

fn handle_tenant_request(tenant_id: &amp;str, requested_path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    // Separate encrypted database per tenant - no path containment needed
    let backend = get_tenant_backend(tenant_id);  // Cached connection
    backend.read(requested_path)  // Atomic, TOCTOU-proof
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>strict-path</th><th>Virtual Backend</th></tr>
</thead>
<tbody>
<tr><td>Isolation model</td><td>Logical (path filtering)</td><td>Physical (separate files)</td></tr>
<tr><td>TOCTOU</td><td>Mitigated</td><td><strong>Eliminated</strong></td></tr>
<tr><td>External interference</td><td>Possible</td><td><strong>Impossible</strong></td></tr>
<tr><td>Symlink attacks</td><td>Resolved at check time</td><td><strong>We control all symlinks</strong></td></tr>
<tr><td>Cross-tenant leakage</td><td>Bug in filtering could leak</td><td><strong>No shared data exists</strong></td></tr>
<tr><td>Performance</td><td>Real FS I/O + canonicalization</td><td>SQLite (often faster for small files)</td></tr>
<tr><td>Encryption</td><td>Separate concern</td><td>Built-in (<code>SqliteCipherBackend</code>) or middleware</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<ol>
<li><strong>No ACLs</strong>: Simple permissions only (Unix mode bits)</li>
<li><strong>Side channels</strong>: Timing attacks, cache attacks require OS/hardware mitigations</li>
<li><strong>SQLite file access</strong>: Host OS can still access the <code>.db</code> file (use Locked mode for encryption)</li>
</ol>
<hr>
<p><em>For implementation details, see <a href="#anyfs---architecture-decision-records">Architecture Decision Records</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---technical-comparison-with-alternatives"><a class="header" href="#anyfs---technical-comparison-with-alternatives">AnyFS - Technical Comparison with Alternatives</a></h1>
<p>This document compares AnyFS with existing Rust filesystem abstractions.</p>
<hr>
<h2 id="executive-summary"><a class="header" href="#executive-summary">Executive Summary</a></h2>
<p>AnyFS is <strong>to filesystems what Axum/Tower is to HTTP</strong>: a composable middleware stack with pluggable backends.</p>
<p><strong>Key differentiators:</strong></p>
<ul>
<li><strong>Composable middleware</strong> - Stack quota, sandboxing, tracing, caching as independent layers</li>
<li><strong>Backend agnostic</strong> - Swap Memory/SQLite/RealFS without code changes</li>
<li><strong>Policy separation</strong> - Storage logic separate from policy enforcement</li>
<li><strong>Third-party extensibility</strong> - Custom backends and middleware depend only on <code>anyfs-backend</code></li>
</ul>
<hr>
<h2 id="compared-solutions"><a class="header" href="#compared-solutions">Compared Solutions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Solution</th><th>What it is</th><th style="text-align: center">Middleware</th><th style="text-align: center">Multiple Backends</th></tr>
</thead>
<tbody>
<tr><td><code>vfs</code></td><td>VFS trait + backends</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>AgentFS</td><td>SQLite agent runtime</td><td style="text-align: center">No</td><td style="text-align: center">No (SQLite only)</td></tr>
<tr><td>OpenDAL</td><td>Object storage layer</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes (cloud-focused)</td></tr>
<tr><td><strong>AnyFS</strong></td><td>VFS + middleware stack</td><td style="text-align: center"><strong>Yes</strong></td><td style="text-align: center"><strong>Yes</strong></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-architecture-comparison"><a class="header" href="#1-architecture-comparison">1. Architecture Comparison</a></h2>
<h3 id="vfs-crate"><a class="header" href="#vfs-crate"><code>vfs</code> Crate</a></h3>
<p>Path-based trait, no middleware pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FileSystem: Send + Sync {
    fn read_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn Iterator&lt;Item = String&gt;&gt;&gt;;
    fn open_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndRead&gt;&gt;;
    fn create_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndWrite&gt;&gt;;
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li>No standard way to add quotas, logging, sandboxing</li>
<li>Each concern must be built into backends or wrapped externally</li>
<li>Path validation is backend-specific</li>
</ul>
<h3 id="agentfs"><a class="header" href="#agentfs">AgentFS</a></h3>
<p>SQLite-based agent runtime:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fixed to SQLite, includes KV store and tool auditing
let fs = AgentFS::open("agent.db")?;
fs.write_file("/path", data)?;
fs.kv_set("key", "value")?;  // KV store bundled
fs.toolcall_start("tool")?;  // Auditing bundled
<span class="boring">}</span></code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li>Locked to SQLite (no memory backend for testing, no real FS)</li>
<li>Monolithic design (can’t use FS without KV/auditing)</li>
<li>No composable middleware</li>
</ul>
<h3 id="anyfs"><a class="header" href="#anyfs">AnyFS</a></h3>
<p>Tower-style middleware + pluggable backends:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, PathFilterLayer, RestrictionsLayer, TracingLayer, FileStorage};

// Compose middleware stack
let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_symlinks()
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(backend);
<span class="boring">}</span></code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Add/remove middleware without touching backends</li>
<li>Swap backends without touching middleware</li>
<li>Third-party extensions via <code>anyfs-backend</code> trait</li>
</ul>
<hr>
<h2 id="2-feature-comparison"><a class="header" href="#2-feature-comparison">2. Feature Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center">AnyFS</th><th style="text-align: center"><code>vfs</code></th><th style="text-align: center">AgentFS</th><th style="text-align: center">OpenDAL</th></tr>
</thead>
<tbody>
<tr><td><strong>Middleware pattern</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>Multiple backends</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>SQLite backend</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Memory backend</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>Real FS backend</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Quota enforcement</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">Manual</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Path sandboxing</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">Manual</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Feature gating</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Rate limiting</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Tracing/logging</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">Manual</td><td style="text-align: center">Built-in</td><td style="text-align: center">Middleware</td></tr>
<tr><td><strong>Streaming I/O</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>Async API</strong></td><td style="text-align: center">Future</td><td style="text-align: center">Partial</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>POSIX extension</strong></td><td style="text-align: center">Future</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>FUSE mountable</strong></td><td style="text-align: center">Future</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>KV store</strong></td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="3-middleware-stack"><a class="header" href="#3-middleware-stack">3. Middleware Stack</a></h2>
<p>AnyFS middleware can <strong>intercept, transform, and control</strong> operations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>Intercepts</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td><code>Quota</code></td><td>Writes</td><td>Reject if over limit</td></tr>
<tr><td><code>PathFilter</code></td><td>All ops</td><td>Block denied paths</td></tr>
<tr><td><code>Restrictions</code></td><td>Configurable operations</td><td>Block via <code>.deny_*()</code> methods</td></tr>
<tr><td><code>RateLimit</code></td><td>All ops</td><td>Throttle per second</td></tr>
<tr><td><code>ReadOnly</code></td><td>Writes</td><td>Block all writes</td></tr>
<tr><td><code>Tracing</code></td><td>All ops</td><td>Log with tracing crate</td></tr>
<tr><td><code>DryRun</code></td><td>Writes</td><td>Log without executing</td></tr>
<tr><td><code>Cache</code></td><td>Reads</td><td>LRU caching</td></tr>
<tr><td><code>Overlay</code></td><td>All ops</td><td>Union filesystem</td></tr>
<tr><td>Custom</td><td>Any</td><td>Encryption, compression, …</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="4-backend-trait"><a class="header" href="#4-backend-trait">4. Backend Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fs: Send + Sync {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
    fn open_write(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt;;
    // ... methods aligned with std::fs
}
<span class="boring">}</span></code></pre>
<p><strong>Design principles:</strong></p>
<ul>
<li><code>impl AsRef&lt;Path&gt;</code> for ergonomics (accepts <code>&amp;str</code>, <code>String</code>, <code>PathBuf</code>)</li>
<li>Aligned with <code>std::fs</code> naming</li>
<li>Streaming I/O via <code>open_read</code>/<code>open_write</code></li>
<li><code>Send</code> bound for async compatibility</li>
</ul>
<hr>
<h2 id="5-when-to-use-what"><a class="header" href="#5-when-to-use-what">5. When to Use What</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Need composable middleware</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need backend flexibility</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need SQLite + Memory + RealFS</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need just VFS abstraction (no policies)</td><td><code>vfs</code></td></tr>
<tr><td>Need AI agent runtime with KV + auditing</td><td>AgentFS</td></tr>
<tr><td>Need cloud object storage</td><td>OpenDAL</td></tr>
<tr><td>Need async-first design</td><td>OpenDAL (or wait for AnyFS async)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="6-deep-dive-vfs-crate-compatibility"><a class="header" href="#6-deep-dive-vfs-crate-compatibility">6. Deep Dive: <code>vfs</code> Crate Compatibility</a></h2>
<p>The <a href="https://github.com/manuel-woelker/rust-vfs"><code>vfs</code></a> crate is the most similar project. This section details why we don’t adopt their trait and how we’ll provide interop.</p>
<h3 id="vfsfilesystem-trait-complete"><a class="header" href="#vfsfilesystem-trait-complete"><code>vfs::FileSystem</code> Trait (Complete)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FileSystem: Send + Sync {
    // Required (9 methods)
    fn read_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn Iterator&lt;Item = String&gt;&gt;&gt;;
    fn create_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn open_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndRead&gt;&gt;;
    fn create_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndWrite&gt;&gt;;
    fn append_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndWrite&gt;&gt;;
    fn metadata(&amp;self, path: &amp;str) -&gt; VfsResult&lt;VfsMetadata&gt;;
    fn exists(&amp;self, path: &amp;str) -&gt; VfsResult&lt;bool&gt;;
    fn remove_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn remove_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;

    // Optional - default to NotSupported (6 methods)
    fn set_creation_time(&amp;self, path: &amp;str, time: SystemTime) -&gt; VfsResult&lt;()&gt;;
    fn set_modification_time(&amp;self, path: &amp;str, time: SystemTime) -&gt; VfsResult&lt;()&gt;;
    fn set_access_time(&amp;self, path: &amp;str, time: SystemTime) -&gt; VfsResult&lt;()&gt;;
    fn copy_file(&amp;self, src: &amp;str, dest: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn move_file(&amp;self, src: &amp;str, dest: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn move_dir(&amp;self, src: &amp;str, dest: &amp;str) -&gt; VfsResult&lt;()&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="feature-gap-analysis"><a class="header" href="#feature-gap-analysis">Feature Gap Analysis</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center"><code>vfs</code></th><th style="text-align: center">AnyFS</th><th>Gap</th></tr>
</thead>
<tbody>
<tr><td>Basic read/write</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td>Directory ops</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td>Streaming I/O</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td><code>rename</code></td><td style="text-align: center"><code>move_file</code></td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td><code>copy</code></td><td style="text-align: center"><code>copy_file</code></td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td><strong>Symlinks</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Critical</td></tr>
<tr><td><strong>Hard links</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Critical</td></tr>
<tr><td><strong>Permissions</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Critical</td></tr>
<tr><td><strong>truncate</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td><strong>sync/fsync</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td><strong>statfs</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td><strong>read_range</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td><strong>symlink_metadata</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td>Path type</td><td style="text-align: center"><code>&amp;str</code></td><td style="text-align: center"><code>impl AsRef&lt;Path&gt;</code></td><td>Different</td></tr>
<tr><td>Middleware</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Architectural</td></tr>
</tbody>
</table>
</div>
<h3 id="why-not-adopt-their-trait"><a class="header" href="#why-not-adopt-their-trait">Why Not Adopt Their Trait?</a></h3>
<ol>
<li><strong>No symlinks/hardlinks</strong> - Can’t virtualize real filesystem semantics</li>
<li><strong>No permissions</strong> - Our <code>Restrictions</code> middleware needs <code>set_permissions</code> to gate</li>
<li><strong>No durability primitives</strong> - No <code>sync</code>/<code>fsync</code> for data integrity</li>
<li><strong>No middleware pattern</strong> - Their <code>VfsPath</code> bakes in behaviors we want composable</li>
<li><strong><code>&amp;str</code> paths</strong> - We prefer <code>impl AsRef&lt;Path&gt;</code> for ergonomics</li>
</ol>
<p><strong>Our trait is a strict superset.</strong> Everything <code>vfs</code> can do, we can do. The reverse is not true.</p>
<h3 id="vfs-backends"><a class="header" href="#vfs-backends"><code>vfs</code> Backends</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>vfs Backend</th><th>AnyFS Equivalent</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>PhysicalFS</code></td><td><code>StdFsBackend</code></td><td>Both use real filesystem directly</td></tr>
<tr><td><code>MemoryFS</code></td><td><code>MemoryBackend</code></td><td>Both in-memory</td></tr>
<tr><td><code>OverlayFS</code></td><td><code>Overlay&lt;B1,B2&gt;</code></td><td>Both union filesystems</td></tr>
<tr><td><code>AltrootFS</code></td><td><code>VRootFsBackend</code></td><td>Both provide path containment</td></tr>
<tr><td><code>EmbeddedFS</code></td><td>(none)</td><td>Read-only embedded assets</td></tr>
<tr><td>(none)</td><td><code>SqliteBackend</code></td><td>We have SQLite</td></tr>
</tbody>
</table>
</div>
<h3 id="interoperability-plan"><a class="header" href="#interoperability-plan">Interoperability Plan</a></h3>
<p>Future <code>anyfs-vfs-compat</code> crate provides bidirectional adapters:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_vfs_compat::{VfsCompat, AnyFsCompat};

// Use a vfs backend in AnyFS
// Missing features return FsError::NotSupported
let backend = VfsCompat::new(vfs::MemoryFS::new());
let fs = FileStorage::new(backend);

// Use an AnyFS backend in vfs-based code
// Only exposes what vfs supports
let anyfs_backend = MemoryBackend::new();
let vfs_fs: Box&lt;dyn vfs::FileSystem&gt; = Box::new(AnyFsCompat::new(anyfs_backend));
<span class="boring">}</span></code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Migrate from <code>vfs</code> to AnyFS incrementally</li>
<li>Use <code>vfs::EmbeddedFS</code> in AnyFS (read-only embedded assets)</li>
<li>Use AnyFS backends in projects depending on <code>vfs</code></li>
</ul>
<hr>
<h2 id="7-tradeoffs"><a class="header" href="#7-tradeoffs">7. Tradeoffs</a></h2>
<h3 id="anyfs-advantages"><a class="header" href="#anyfs-advantages">AnyFS Advantages</a></h3>
<ul>
<li>Composable middleware pattern</li>
<li>Backend-agnostic</li>
<li>Third-party extensibility</li>
<li>Clean separation of concerns</li>
<li>Full filesystem semantics (symlinks, permissions, durability)</li>
</ul>
<h3 id="anyfs-limitations"><a class="header" href="#anyfs-limitations">AnyFS Limitations</a></h3>
<ul>
<li>Sync-first (async planned)</li>
<li>Smaller ecosystem (new project)</li>
<li>Not full POSIX emulation</li>
</ul>
<hr>
<p>If this document conflicts with <code>AGENTS.md</code> or <code>src/architecture/design-overview.md</code>, treat those as authoritative.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---build-vs-reuse-analysis"><a class="header" href="#anyfs---build-vs-reuse-analysis">AnyFS - Build vs. Reuse Analysis</a></h1>
<p><strong>Can your goals be achieved with existing crates, or does this project need to exist?</strong></p>
<hr>
<h2 id="core-requirements"><a class="header" href="#core-requirements">Core Requirements</a></h2>
<ol>
<li><strong>Backend flexibility</strong> - swap storage without changing application code</li>
<li><strong>Composable middleware</strong> - add/remove capabilities (quotas, sandboxing, logging)</li>
<li><strong>Tenant isolation</strong> - each tenant gets an isolated namespace</li>
<li><strong>Portable storage</strong> - single-file backend (SQLite) for easy move/copy/backup</li>
<li><strong>Filesystem semantics</strong> - <code>std::fs</code>-aligned operations including symlinks and hard links</li>
<li><strong>Path containment</strong> - prevent traversal attacks</li>
</ol>
<hr>
<h2 id="what-already-exists"><a class="header" href="#what-already-exists">What Already Exists</a></h2>
<h3 id="vfs-crate-rust"><a class="header" href="#vfs-crate-rust"><code>vfs</code> crate (Rust)</a></h3>
<p><strong>What it provides:</strong></p>
<ul>
<li>Filesystem abstraction with multiple backends</li>
<li>MemoryFS, PhysicalFS, AltrootFS, OverlayFS, EmbeddedFS</li>
</ul>
<p><strong>What it lacks:</strong></p>
<ul>
<li>SQLite backend</li>
<li>Composable middleware pattern</li>
<li>Quota/limit enforcement</li>
<li>Policy layers (feature gating, path filtering)</li>
</ul>
<h3 id="agentfs-turso"><a class="header" href="#agentfs-turso">AgentFS (Turso)</a></h3>
<p><strong>What it provides:</strong></p>
<ul>
<li>SQLite-based filesystem for AI agents</li>
<li>Key-value store</li>
<li>Tool call auditing</li>
<li>FUSE mounting</li>
</ul>
<p><strong>What it lacks:</strong></p>
<ul>
<li>Multiple backend types (SQLite only)</li>
<li>Composable middleware</li>
<li>Backend-agnostic abstraction</li>
</ul>
<h3 id="rusqlite"><a class="header" href="#rusqlite"><code>rusqlite</code></a></h3>
<p><strong>What it provides:</strong> SQLite bindings, transactions, blobs.</p>
<p><strong>What it lacks:</strong> Filesystem semantics, quota enforcement.</p>
<h3 id="strict-path"><a class="header" href="#strict-path"><code>strict-path</code></a></h3>
<p><strong>What it provides:</strong> Path validation and containment (<code>VirtualRoot</code>).</p>
<p><strong>What it lacks:</strong> Storage backends, filesystem API.</p>
<hr>
<h2 id="gap-analysis"><a class="header" href="#gap-analysis">Gap Analysis</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Requirement</th><th style="text-align: center"><code>vfs</code></th><th style="text-align: center">AgentFS</th><th style="text-align: center"><code>rusqlite</code></th><th style="text-align: center"><code>strict-path</code></th></tr>
</thead>
<tbody>
<tr><td>Filesystem API</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>Multiple backends</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">N/A</td><td style="text-align: center">No</td></tr>
<tr><td>SQLite backend</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes (raw)</td><td style="text-align: center">No</td></tr>
<tr><td>Composable middleware</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>Quota enforcement</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">Manual</td><td style="text-align: center">No</td></tr>
<tr><td>Path sandboxing</td><td style="text-align: center">Partial</td><td style="text-align: center">No</td><td style="text-align: center">Manual</td><td style="text-align: center">Yes</td></tr>
<tr><td>Symlink/hard link control</td><td style="text-align: center">Backend-dep</td><td style="text-align: center">Yes</td><td style="text-align: center">Manual</td><td style="text-align: center">N/A</td></tr>
</tbody>
</table>
</div>
<p><strong>Conclusion:</strong> No existing crate provides:</p>
<blockquote>
<p>“Backend-agnostic filesystem abstraction with composable middleware for quotas, sandboxing, and policy enforcement.”</p>
</blockquote>
<hr>
<h2 id="why-anyfs-exists"><a class="header" href="#why-anyfs-exists">Why AnyFS Exists</a></h2>
<p>AnyFS fills the gap by separating concerns:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Responsibility</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Trait (<code>Fs</code>, <code>Layer</code>) + types</td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware + ergonomic wrapper (<code>FileStorage&lt;M&gt;</code>)</td></tr>
</tbody>
</table>
</div>
<p>The middleware pattern (like Tower/Axum) enables composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, PathFilterLayer, RestrictionsLayer, TracingLayer, FileStorage};

let backend = SqliteBackend::open("tenant.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_symlinks()
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(backend);
fs.write("/workspace/doc.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="alternatives-considered"><a class="header" href="#alternatives-considered">Alternatives Considered</a></h2>
<h3 id="option-a-implement-sqlite-backend-for-vfs-crate"><a class="header" href="#option-a-implement-sqlite-backend-for-vfs-crate">Option A: Implement SQLite backend for <code>vfs</code> crate</a></h3>
<p><strong>Pros:</strong> Ecosystem compatibility.</p>
<p><strong>Cons:</strong></p>
<ul>
<li>No middleware pattern for quotas/policies</li>
<li>Would still need to build quota/sandboxing outside the trait</li>
<li>Doesn’t solve the composability problem</li>
</ul>
<h3 id="option-b-use-agentfs"><a class="header" href="#option-b-use-agentfs">Option B: Use AgentFS</a></h3>
<p><strong>Pros:</strong> Already exists, SQLite-based, FUSE support.</p>
<p><strong>Cons:</strong></p>
<ul>
<li>Locked to SQLite (can’t swap to memory/real FS)</li>
<li>No composable middleware</li>
<li>Includes KV store and auditing we may not need</li>
</ul>
<h3 id="option-c-anyfs-recommended"><a class="header" href="#option-c-anyfs-recommended">Option C: AnyFS (recommended)</a></h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Backend-agnostic (swap storage without code changes)</li>
<li>Composable middleware (add/remove capabilities)</li>
<li>Clean separation of concerns</li>
<li>Third-party extensibility</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>New project, not yet widely adopted</li>
</ul>
<hr>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Build AnyFS with reusable primitives (<code>rusqlite</code>, <code>strict-path</code>, <code>thiserror</code>, <code>tracing</code>) but maintain the two-crate split. The middleware pattern is what makes the design both flexible and safe.</p>
<p><strong>Compatibility option:</strong> Later, provide an adapter that implements <code>vfs</code> traits on top of <code>Fs</code> for projects that need <code>vfs</code> compatibility.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementation-plan"><a class="header" href="#implementation-plan">Implementation Plan</a></h1>
<p>This plan describes a phased rollout of the AnyFS ecosystem:</p>
<ul>
<li><code>anyfs-backend</code>: Layered traits (<code>Fs</code>, <code>FsFull</code>, <code>FsFuse</code>, <code>FsPosix</code>) + <code>Layer</code> + types</li>
<li><code>anyfs</code>: Built-in backends + middleware (feature-gated) + <code>FileStorage&lt;M&gt;</code> ergonomic wrapper</li>
</ul>
<hr>
<h2 id="implementation-guidelines"><a class="header" href="#implementation-guidelines">Implementation Guidelines</a></h2>
<p>These guidelines apply to ALL implementation work. Derived from analysis of issues in similar projects (<code>vfs</code>, <code>agentfs</code>).</p>
<h3 id="1-no-panic-policy"><a class="header" href="#1-no-panic-policy">1. No Panic Policy</a></h3>
<p><strong>NEVER panic in library code.</strong> Always return <code>Result&lt;T, FsError&gt;</code>.</p>
<ul>
<li>Audit all <code>.unwrap()</code> and <code>.expect()</code> calls - replace with <code>?</code> or proper error handling</li>
<li>Use <code>ok_or_else(|| FsError::...)</code> instead of <code>.unwrap()</code></li>
<li>Edge cases must return errors, not panic</li>
<li>Test in constrained environments (WASM) to catch hidden panics</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD
let entry = self.entries.get(&amp;path).unwrap();

// GOOD
let entry = self.entries.get(&amp;path)
    .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;
<span class="boring">}</span></code></pre>
<h3 id="2-thread-safety-requirements"><a class="header" href="#2-thread-safety-requirements">2. Thread Safety Requirements</a></h3>
<p>All backends must be safe for concurrent access:</p>
<ul>
<li><code>MemoryBackend</code>: Use <code>Arc&lt;RwLock&lt;...&gt;&gt;</code> for internal state</li>
<li><code>SqliteBackend</code>: Use WAL mode, handle <code>SQLITE_BUSY</code></li>
<li><code>VRootFsBackend</code>: File operations are inherently concurrent-safe</li>
</ul>
<p><strong>Required:</strong> Concurrent stress tests in conformance suite.</p>
<h3 id="3-consistent-path-handling"><a class="header" href="#3-consistent-path-handling">3. Consistent Path Handling</a></h3>
<p>FileStorage handles path resolution (symlink-aware, not just lexical normalization):</p>
<ul>
<li>Always absolute paths internally</li>
<li>Always <code>/</code> separator (even on Windows)</li>
<li>Resolve <code>..</code> and <code>.</code> via canonicalization (symlink-aware, not lexical)</li>
<li>Handle edge cases: <code>//</code>, trailing <code>/</code>, empty string</li>
</ul>
<p><strong>Public canonicalization API on FileStorage:</strong></p>
<ul>
<li><code>canonicalize(path)</code> - strict, all components must exist</li>
<li><code>soft_canonicalize(path)</code> - resolves existing, appends non-existent lexically</li>
<li><code>anchored_canonicalize(path, anchor)</code> - sandboxed resolution</li>
</ul>
<p><strong>Standalone utility:</strong></p>
<ul>
<li><code>normalize(path)</code> - lexical cleanup only (collapses <code>//</code>, removes trailing <code>/</code>). Does NOT resolve <code>.</code> or <code>..</code>.</li>
</ul>
<h3 id="4-error-type-design"><a class="header" href="#4-error-type-design">4. Error Type Design</a></h3>
<p><code>FsError</code> must be:</p>
<ul>
<li>Easy to pattern match</li>
<li>Include context (path, operation)</li>
<li>Derive <code>thiserror</code> for good messages</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum FsError {
    #[error("{operation}: not found: {path}")]
    NotFound { path: PathBuf, operation: &amp;'static str },

    #[error("{operation}: already exists: {path}")]
    AlreadyExists { path: PathBuf, operation: &amp;'static str },

    #[error("quota exceeded: limit {limit}, attempted {attempted}")]
    QuotaExceeded { limit: u64, attempted: u64 },

    #[error("feature not enabled: {feature}")]
    FeatureNotEnabled { feature: &amp;'static str },

    #[error("permission denied: {path} ({operation})")]
    PermissionDenied { path: PathBuf, operation: &amp;'static str },

    // ... etc
}
<span class="boring">}</span></code></pre>
<h3 id="5-documentation-requirements"><a class="header" href="#5-documentation-requirements">5. Documentation Requirements</a></h3>
<p>Every backend and middleware must document:</p>
<ul>
<li>Thread safety guarantees</li>
<li>Performance characteristics</li>
<li>Which operations are O(1) vs O(n)</li>
<li>Any platform-specific behavior</li>
</ul>
<hr>
<h2 id="phase-1-anyfs-backend-core-contract"><a class="header" href="#phase-1-anyfs-backend-core-contract">Phase 1: <code>anyfs-backend</code> (core contract)</a></h2>
<p><strong>Goal:</strong> Define the stable backend interface using layered traits.</p>
<h3 id="layered-trait-architecture"><a class="header" href="#layered-trait-architecture">Layered Trait Architecture</a></h3>
<pre><code>                    FsPosix
                       │
        ┌──────────────┼──────────────┐
        │              │              │
   FsHandles      FsLock       FsXattr
        │              │              │
        └──────────────┼──────────────┘
                       │
                    FsFuse
                       │
                   FsInode
                       │
                    FsFull
                       │
        ┌──────┬───────┼───────┬──────┐
        │      │       │       │      │
   FsLink  FsPerm  FsSync FsStats │
        │      │       │       │      │
        └──────┴───────┼───────┴──────┘
                       │
                       Fs  ← Most users only need this
                       │
           ┌───────────┼───────────┐
           │           │           │
        FsRead    FsWrite     FsDir
</code></pre>
<h3 id="core-traits-layer-1---required"><a class="header" href="#core-traits-layer-1---required">Core Traits (Layer 1 - Required)</a></h3>
<ul>
<li><strong><code>FsRead</code></strong>: <code>read</code>, <code>read_to_string</code>, <code>read_range</code>, <code>exists</code>, <code>metadata</code>, <code>open_read</code></li>
<li><strong><code>FsWrite</code></strong>: <code>write</code>, <code>append</code>, <code>remove_file</code>, <code>rename</code>, <code>copy</code>, <code>truncate</code>, <code>open_write</code></li>
<li><strong><code>FsDir</code></strong>: <code>read_dir</code>, <code>create_dir</code>, <code>create_dir_all</code>, <code>remove_dir</code>, <code>remove_dir_all</code></li>
</ul>
<h3 id="extended-traits-layer-2---optional-1"><a class="header" href="#extended-traits-layer-2---optional-1">Extended Traits (Layer 2 - Optional)</a></h3>
<ul>
<li><strong><code>FsLink</code></strong>: <code>symlink</code>, <code>hard_link</code>, <code>read_link</code>, <code>symlink_metadata</code></li>
<li><strong><code>FsPermissions</code></strong>: <code>set_permissions</code></li>
<li><strong><code>FsSync</code></strong>: <code>sync</code>, <code>fsync</code></li>
<li><strong><code>FsStats</code></strong>: <code>statfs</code></li>
</ul>
<h3 id="inode-trait-layer-3---for-fuse"><a class="header" href="#inode-trait-layer-3---for-fuse">Inode Trait (Layer 3 - For FUSE)</a></h3>
<ul>
<li><strong><code>FsInode</code></strong>: <code>path_to_inode</code>, <code>inode_to_path</code>, <code>lookup</code>, <code>metadata_by_inode</code>
<ul>
<li>Default implementations use path hashing/fallback</li>
<li>Override for hardlink support and FUSE efficiency</li>
</ul>
</li>
</ul>
<h3 id="posix-traits-layer-4---full-posix-1"><a class="header" href="#posix-traits-layer-4---full-posix-1">POSIX Traits (Layer 4 - Full POSIX)</a></h3>
<ul>
<li><strong><code>FsHandles</code></strong>: <code>open</code>, <code>read_at</code>, <code>write_at</code>, <code>close</code></li>
<li><strong><code>FsLock</code></strong>: <code>lock</code>, <code>try_lock</code>, <code>unlock</code></li>
<li><strong><code>FsXattr</code></strong>: <code>get_xattr</code>, <code>set_xattr</code>, <code>remove_xattr</code>, <code>list_xattr</code></li>
</ul>
<h3 id="convenience-supertraits-1"><a class="header" href="#convenience-supertraits-1">Convenience Supertraits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Basic filesystem - covers 90% of use cases
pub trait Fs: FsRead + FsWrite + FsDir {}
impl&lt;T: FsRead + FsWrite + FsDir&gt; Fs for T {}

/// Full filesystem with all std::fs features
pub trait FsFull: Fs + FsLink + FsPermissions + FsSync + FsStats {}

/// FUSE-mountable filesystem
pub trait FsFuse: FsFull + FsInode {}

/// Full POSIX filesystem
pub trait FsPosix: FsFuse + FsHandles + FsLock + FsXattr {}
<span class="boring">}</span></code></pre>
<h3 id="other-definitions"><a class="header" href="#other-definitions">Other Definitions</a></h3>
<ul>
<li>Define <code>Layer</code> trait (Tower-style middleware composition)</li>
<li>Define <code>FsExt</code> trait (extension methods for JSON, type checks)</li>
<li>Define core types (<code>Metadata</code>, <code>Permissions</code>, <code>FileType</code>, <code>DirEntry</code>, <code>StatFs</code>)</li>
<li>Define <code>FsError</code> with contextual variants (see guidelines above)</li>
<li>Define <code>ROOT_INODE = 1</code> constant</li>
<li>Define <code>SelfResolving</code> marker trait (opt-in for backends that handle their own path resolution, e.g., VRootFsBackend)</li>
</ul>
<p><strong>Exit criteria:</strong> <code>anyfs-backend</code> stands alone with minimal dependencies (<code>thiserror</code>).</p>
<hr>
<h2 id="phase-2-anyfs-backends--middleware"><a class="header" href="#phase-2-anyfs-backends--middleware">Phase 2: <code>anyfs</code> (backends + middleware)</a></h2>
<p><strong>Goal:</strong> Provide reference backends and core middleware.</p>
<h3 id="path-resolution-filestorages-responsibility"><a class="header" href="#path-resolution-filestorages-responsibility">Path Resolution (FileStorage’s Responsibility)</a></h3>
<p>FileStorage handles path resolution for ALL backends (unless they implement <code>SelfResolving</code>):</p>
<ul>
<li>Walks path component by component using <code>metadata()</code> and <code>read_link()</code></li>
<li>Handles <code>..</code> correctly after symlink resolution (symlink-aware, not lexical)</li>
<li>Respects <code>set_follow_symlinks(bool)</code> setting</li>
<li>Detects circular symlinks (max depth or visited set)</li>
<li>Returns canonical resolved path to the backend</li>
</ul>
<p><strong>Backends receive already-resolved paths</strong> - they just store/retrieve bytes.</p>
<h3 id="backends-feature-gated"><a class="header" href="#backends-feature-gated">Backends (feature-gated)</a></h3>
<p>Each backend implements the traits it supports:</p>
<ul>
<li><code>memory</code> (default): <code>MemoryBackend</code>
<ul>
<li>Implements: <code>Fs</code> + <code>FsLink</code> + <code>FsPermissions</code> + <code>FsSync</code> + <code>FsStats</code> + <code>FsInode</code> = <code>FsFuse</code></li>
<li>FileStorage handles path resolution (symlink-aware)</li>
<li>Inode source: internal node IDs (incrementing counter)</li>
<li><code>set_follow_symlinks(bool)</code> - control symlink following during resolution</li>
</ul>
</li>
<li><code>sqlite</code> (optional): <code>SqliteBackend</code>
<ul>
<li>Implements: <code>FsFuse</code> (all traits through Layer 3)</li>
<li>FileStorage handles path resolution (symlink-aware)</li>
<li>Inode source: SQLite row IDs (<code>INTEGER PRIMARY KEY</code>)</li>
<li><code>set_follow_symlinks(bool)</code> - control symlink following during resolution</li>
</ul>
</li>
<li><code>sqlite-cipher</code> (optional): <code>SqliteCipherBackend</code>
<ul>
<li>Implements: <code>FsFuse</code> (same as SqliteBackend)</li>
<li>Full AES-256 encryption via <a href="https://www.zetetic.net/sqlcipher/">SQLCipher</a></li>
<li>Password-protected: <code>.db</code> file is random bytes without password</li>
<li>Uses <code>rusqlite</code> with <code>bundled-sqlcipher</code> feature</li>
<li><code>open(path, password)</code> - derive key from password (PBKDF2)</li>
<li><code>open_with_key(path, key)</code> - use raw 256-bit key</li>
<li><code>change_password(new_password)</code> - re-key database</li>
<li><strong>Mutually exclusive with <code>sqlite</code> feature</strong> (different SQLite builds)</li>
</ul>
</li>
<li><code>stdfs</code> (optional): <code>StdFsBackend</code> - direct <code>std::fs</code> delegation
<ul>
<li>Implements: <code>FsPosix</code> (all traits including Layer 4) + <code>SelfResolving</code></li>
<li>Implements <code>SelfResolving</code> (OS handles resolution)</li>
<li>Inode source: OS inode numbers (<code>std::fs::Metadata::ino()</code>)</li>
<li>No path containment - full filesystem access</li>
<li>Use when you only need middleware layers without sandboxing</li>
</ul>
</li>
<li><code>vrootfs</code> (optional): <code>VRootFsBackend</code> using <code>strict-path</code> for containment
<ul>
<li>Implements: <code>FsPosix</code> (all traits including Layer 4) + <code>SelfResolving</code></li>
<li>Implements <code>SelfResolving</code> (OS handles resolution, <code>strict-path</code> prevents escapes)</li>
<li>Inode source: OS inode numbers (<code>std::fs::Metadata::ino()</code>)</li>
</ul>
</li>
</ul>
<h3 id="middleware-2"><a class="header" href="#middleware-2">Middleware</a></h3>
<ul>
<li><code>Quota&lt;B&gt;</code> + <code>QuotaLayer</code> - Resource limits</li>
<li><code>Restrictions&lt;B&gt;</code> + <code>RestrictionsLayer</code> - Opt-in restrictions (<code>.deny_symlinks()</code>, <code>.deny_hard_links()</code>, etc.)</li>
<li><code>PathFilter&lt;B&gt;</code> + <code>PathFilterLayer</code> - Path-based access control</li>
<li><code>ReadOnly&lt;B&gt;</code> + <code>ReadOnlyLayer</code> - Block writes</li>
<li><code>RateLimit&lt;B&gt;</code> + <code>RateLimitLayer</code> - Operation throttling</li>
<li><code>Tracing&lt;B&gt;</code> + <code>TracingLayer</code> - Instrumentation</li>
<li><code>DryRun&lt;B&gt;</code> + <code>DryRunLayer</code> - Log without executing</li>
<li><code>Cache&lt;B&gt;</code> + <code>CacheLayer</code> - LRU read cache</li>
<li><code>Overlay&lt;B1,B2&gt;</code> + <code>OverlayLayer</code> - Union filesystem</li>
</ul>
<h3 id="filestorageb-m-ergonomic-wrapper"><a class="header" href="#filestorageb-m-ergonomic-wrapper">FileStorage&lt;B, M&gt; (Ergonomic Wrapper)</a></h3>
<ul>
<li><code>FileStorage&lt;B, M&gt;</code> - Zero-cost wrapper with <code>std::fs</code>-aligned API
<ul>
<li>Generic backend <code>B</code> (no boxing, static dispatch)</li>
<li>Optional marker type <code>M</code> for compile-time container differentiation</li>
<li><code>.boxed()</code> method for opt-in type erasure when needed</li>
</ul>
</li>
<li><code>BackendStack</code> builder for fluent middleware composition</li>
<li>Accepts <code>impl AsRef&lt;Path&gt;</code> for convenience</li>
<li>Delegates all operations to wrapped backend</li>
</ul>
<p><strong>Axum-style design:</strong> Zero-cost by default, type erasure opt-in.</p>
<p><strong>Note:</strong> <code>FileStorage</code> contains NO policy logic. Policy is handled by middleware.</p>
<p><strong>Exit criteria:</strong> Each backend implements the appropriate trait level (<code>Fs</code>, <code>FsFull</code>, <code>FsFuse</code>) and passes conformance suite. Each middleware wraps backends implementing the same traits. Applications can use <code>FileStorage</code> as drop-in for <code>std::fs</code> patterns.</p>
<hr>
<h2 id="phase-3-conformance-test-suite"><a class="header" href="#phase-3-conformance-test-suite">Phase 3: Conformance test suite</a></h2>
<p><strong>Goal:</strong> Prevent backend divergence and validate middleware behavior.</p>
<h3 id="backend-conformance-tests"><a class="header" href="#backend-conformance-tests">Backend conformance tests</a></h3>
<p>Conformance tests are organized by trait layer:</p>
<h4 id="layer-1-fs-core---all-backends-must-pass"><a class="header" href="#layer-1-fs-core---all-backends-must-pass">Layer 1: <code>Fs</code> (Core) - All backends MUST pass</a></h4>
<ul>
<li><strong>FsRead</strong>: <code>read</code>/<code>read_to_string</code>/<code>read_range</code>/<code>exists</code>/<code>metadata</code>/<code>open_read</code></li>
<li><strong>FsWrite</strong>: <code>write</code>/<code>append</code>/<code>remove_file</code>/<code>rename</code>/<code>copy</code>/<code>truncate</code>/<code>open_write</code></li>
<li><strong>FsDir</strong>: <code>read_dir</code>/<code>create_dir*</code>/<code>remove_dir*</code></li>
</ul>
<h4 id="layer-2-fsfull-extended---backends-that-support-these-features"><a class="header" href="#layer-2-fsfull-extended---backends-that-support-these-features">Layer 2: <code>FsFull</code> (Extended) - Backends that support these features</a></h4>
<ul>
<li><strong>FsLink</strong>: <code>symlink</code>/<code>hard_link</code>/<code>read_link</code>/<code>symlink_metadata</code></li>
<li><strong>FsPermissions</strong>: <code>set_permissions</code></li>
<li><strong>FsSync</strong>: <code>sync</code>/<code>fsync</code></li>
<li><strong>FsStats</strong>: <code>statfs</code></li>
</ul>
<h4 id="layer-3-fsfuse-inode---backends-that-support-fuse-mounting"><a class="header" href="#layer-3-fsfuse-inode---backends-that-support-fuse-mounting">Layer 3: <code>FsFuse</code> (Inode) - Backends that support FUSE mounting</a></h4>
<ul>
<li><strong>FsInode</strong>: <code>path_to_inode</code>/<code>inode_to_path</code>/<code>lookup</code>/<code>metadata_by_inode</code></li>
</ul>
<h4 id="layer-4-fsposix-full-posix---backends-that-support-full-posix"><a class="header" href="#layer-4-fsposix-full-posix---backends-that-support-full-posix">Layer 4: <code>FsPosix</code> (Full POSIX) - Backends that support full POSIX</a></h4>
<ul>
<li><strong>FsHandles</strong>: <code>open</code>/<code>read_at</code>/<code>write_at</code>/<code>close</code></li>
<li><strong>FsLock</strong>: <code>lock</code>/<code>try_lock</code>/<code>unlock</code></li>
<li><strong>FsXattr</strong>: <code>get_xattr</code>/<code>set_xattr</code>/<code>remove_xattr</code>/<code>list_xattr</code></li>
</ul>
<h4 id="path-resolution-tests-virtual-backends-only"><a class="header" href="#path-resolution-tests-virtual-backends-only">Path Resolution Tests (virtual backends only)</a></h4>
<ul>
<li><code>/foo/../bar</code> resolves correctly when <code>foo</code> is a regular directory</li>
<li><code>/foo/../bar</code> resolves correctly when <code>foo</code> is a symlink (follows symlink, then <code>..</code>)</li>
<li>Symlink chains resolve correctly (A → B → C → target)</li>
<li>Circular symlink detection (A → B → A returns error, not infinite loop)</li>
<li>Max symlink depth enforced (prevent deep chains)</li>
<li><code>set_follow_symlinks(true)</code>: reading symlink follows to target</li>
<li><code>set_follow_symlinks(false)</code>: reading symlink returns symlink metadata, not target</li>
</ul>
<h4 id="path-edge-cases-learned-from-vfs-issues"><a class="header" href="#path-edge-cases-learned-from-vfs-issues">Path Edge Cases (learned from <code>vfs</code> issues)</a></h4>
<ul>
<li><code>//double//slashes//</code> normalizes correctly</li>
<li>Note: <code>/foo/../bar</code> requires resolution (see above), not simple normalization</li>
<li>Trailing slashes handled consistently</li>
<li>Empty path returns error (not panic)</li>
<li>Root path <code>/</code> works correctly</li>
<li>Very long paths (near OS limits)</li>
<li>Unicode paths</li>
<li>Paths with spaces and special characters</li>
</ul>
<h4 id="thread-safety-tests-learned-from-vfs-72-47"><a class="header" href="#thread-safety-tests-learned-from-vfs-72-47">Thread Safety Tests (learned from <code>vfs</code> #72, #47)</a></h4>
<ul>
<li>Concurrent <code>read</code> from multiple threads</li>
<li>Concurrent <code>write</code> to different files</li>
<li>Concurrent <code>create_dir_all</code> to same path (must not race)</li>
<li>Concurrent <code>read_dir</code> while modifying directory</li>
<li>Stress test: 100 threads, 1000 operations each</li>
</ul>
<h4 id="error-handling-tests-learned-from-vfs-8-23"><a class="header" href="#error-handling-tests-learned-from-vfs-8-23">Error Handling Tests (learned from <code>vfs</code> #8, #23)</a></h4>
<ul>
<li>Missing file returns <code>NotFound</code>, not panic</li>
<li>Missing parent directory returns error, not panic</li>
<li>Invalid UTF-8 in path returns error, not panic</li>
<li>All error variants are matchable</li>
</ul>
<h4 id="platform-tests"><a class="header" href="#platform-tests">Platform Tests</a></h4>
<ul>
<li>Windows path separators (<code>\</code> vs <code>/</code>)</li>
<li>Case sensitivity differences</li>
<li>Symlink behavior differences</li>
</ul>
<h3 id="middleware-tests"><a class="header" href="#middleware-tests">Middleware tests</a></h3>
<ul>
<li><code>Quota</code>: Limit enforcement, usage tracking, streaming writes</li>
<li><code>Restrictions</code>: Operation blocking via <code>.deny_*()</code> methods, error messages</li>
<li><code>PathFilter</code>: Glob pattern matching, deny-by-default</li>
<li><code>RateLimit</code>: Throttling behavior, burst handling</li>
<li><code>ReadOnly</code>: All write operations blocked</li>
<li><code>Tracing</code>: Operations logged correctly</li>
<li>Middleware composition order (inner to outer)</li>
<li>Middleware with streaming I/O (wrappers work correctly)</li>
</ul>
<h3 id="no-panic-tests"><a class="header" href="#no-panic-tests">No-Panic Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn no_panic_on_missing_file() {
    let backend = create_backend();
    let result = backend.read("/nonexistent");
    assert!(matches!(result, Err(FsError::NotFound { .. })));
}

#[test]
fn no_panic_on_invalid_operation() {
    let backend = create_backend();
    backend.write("/file.txt", b"data").unwrap();
    // Try to read directory on a file
    let result = backend.read_dir("/file.txt");
    assert!(matches!(result, Err(FsError::NotADirectory { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="wasm-compatibility-tests-learned-from-vfs-68"><a class="header" href="#wasm-compatibility-tests-learned-from-vfs-68">WASM Compatibility Tests (learned from <code>vfs</code> #68)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "wasm32")]
#[wasm_bindgen_test]
fn memory_backend_works_in_wasm() {
    let backend = MemoryBackend::new();
    backend.write("/test.txt", b"hello").unwrap();
    // Should not panic
}
<span class="boring">}</span></code></pre>
<p><strong>Exit criteria:</strong> All backends pass same suite; middleware tests are backend-agnostic; zero panics in any test.</p>
<hr>
<h2 id="phase-4-documentation--examples"><a class="header" href="#phase-4-documentation--examples">Phase 4: Documentation + examples</a></h2>
<ul>
<li>Keep <code>AGENTS.md</code> and <code>src/architecture/design-overview.md</code> authoritative</li>
<li>Provide example per backend</li>
<li>Provide backend implementer guide</li>
<li>Provide middleware implementer guide</li>
<li>Document performance characteristics per backend</li>
<li>Document thread safety guarantees per backend</li>
<li>Document platform-specific behavior</li>
</ul>
<hr>
<h2 id="phase-5-cicd-pipeline"><a class="header" href="#phase-5-cicd-pipeline">Phase 5: CI/CD Pipeline</a></h2>
<p><strong>Goal:</strong> Ensure quality across platforms and prevent regressions.</p>
<h3 id="cross-platform-testing"><a class="header" href="#cross-platform-testing">Cross-Platform Testing</a></h3>
<pre><code class="language-yaml"># .github/workflows/ci.yml
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    rust: [stable, beta]
</code></pre>
<p>Required CI checks:</p>
<ul>
<li><code>cargo test</code> on all platforms</li>
<li><code>cargo clippy -- -D warnings</code></li>
<li><code>cargo fmt --check</code></li>
<li><code>cargo doc --no-deps</code></li>
<li>WASM build test: <code>cargo build --target wasm32-unknown-unknown</code></li>
</ul>
<h3 id="additional-ci-jobs"><a class="header" href="#additional-ci-jobs">Additional CI Jobs</a></h3>
<ul>
<li><strong>Miri</strong> (undefined behavior detection): <code>cargo +nightly miri test</code></li>
<li><strong>Address Sanitizer</strong>: Detect memory issues</li>
<li><strong>Thread Sanitizer</strong>: Detect data races</li>
<li><strong>Coverage</strong>: Minimum 80% line coverage</li>
</ul>
<h3 id="release-checklist"><a class="header" href="#release-checklist">Release Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"> All CI checks pass</li>
<li><input disabled="" type="checkbox"> No new <code>clippy</code> warnings</li>
<li><input disabled="" type="checkbox"> CHANGELOG updated</li>
<li><input disabled="" type="checkbox"> Version bumped appropriately</li>
<li><input disabled="" type="checkbox"> Documentation builds without warnings</li>
</ul>
<hr>
<h2 id="future-work-post-mvp"><a class="header" href="#future-work-post-mvp">Future work (post-MVP)</a></h2>
<ul>
<li>Async API (<code>AsyncFs</code>, <code>AsyncFsFull</code>, etc.)</li>
<li>Import/export helpers (host path &lt;-&gt; container)</li>
<li>Encryption middleware</li>
<li>Compression middleware</li>
<li><code>no_std</code> support (learned from <code>vfs</code> #38)</li>
<li>Batch operations for performance (learned from <code>agentfs</code> #130)</li>
</ul>
<h3 id="anyfs-mount---mount-as-real-filesystem"><a class="header" href="#anyfs-mount---mount-as-real-filesystem"><code>anyfs-mount</code> - Mount as Real Filesystem</a></h3>
<p>Adapter to expose any <code>FsFuse</code> backend as a FUSE mount point.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, FsFuse};
use anyfs_mount::FuseMount;

// RAM drive with 1GB quota
let backend = MemoryBackend::new()
    .layer(QuotaLayer::new().max_total_size(1024 * 1024 * 1024));

// Backend must implement FsFuse (includes FsInode)
let mount = FuseMount::mount(backend, "/mnt/ramdisk")?;

// Now it's a real mount point:
// $ df -h /mnt/ramdisk
// $ cp large_file.bin /mnt/ramdisk/  # fast!
// $ gcc -o /mnt/ramdisk/build ...    # compile in RAM
<span class="boring">}</span></code></pre>
<p><strong>Cross-Platform Support:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>FUSE Provider</th><th>Rust Crate</th><th>User Must Install</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>Native kernel</td><td><code>fuser</code></td><td><code>fuse3</code> package</td></tr>
<tr><td>macOS</td><td>macFUSE</td><td><code>fuser</code></td><td><a href="https://osxfuse.github.io/">macFUSE</a></td></tr>
<tr><td>FreeBSD</td><td>Native</td><td><code>fuser</code></td><td>(built-in)</td></tr>
<tr><td>Windows</td><td>WinFsp</td><td><code>winfsp-rs</code></td><td><a href="https://winfsp.dev/">WinFsp</a></td></tr>
</tbody>
</table>
</div>
<p><code>anyfs-mount</code> provides a unified API across platforms:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsFuse&gt; FuseMount&lt;B&gt; {
    #[cfg(unix)]
    pub fn mount(backend: B, path: &amp;Path) -&gt; Result&lt;Self, ...&gt; {
        // Uses fuser crate
    }

    #[cfg(windows)]
    pub fn mount(backend: B, path: &amp;Path) -&gt; Result&lt;Self, ...&gt; {
        // Uses winfsp-rs crate
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Creative Use Cases:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Stack</th><th>What You Get</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>RAM drive</td></tr>
<tr><td><code>MemoryBackend</code> + <code>Quota</code></td><td>RAM drive with size limit</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Single-file portable drive</td></tr>
<tr><td><code>Overlay&lt;SqliteBackend, MemoryBackend&gt;</code></td><td>Persistent base + RAM scratch layer</td></tr>
<tr><td><code>Cache&lt;SqliteBackend&gt;</code></td><td>SQLite with RAM read cache</td></tr>
<tr><td><code>Tracing&lt;MemoryBackend&gt;</code></td><td>RAM drive with full audit log</td></tr>
<tr><td><code>ReadOnly&lt;SqliteBackend&gt;</code></td><td>Immutable snapshot mount</td></tr>
<tr><td><code>Encryption&lt;SqliteBackend&gt;</code></td><td>Encrypted portable drive</td></tr>
</tbody>
</table>
</div>
<p><strong>Example: AI Agent Sandbox</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sandboxed workspace mounted as real filesystem
let sandbox = FuseMount::mount(
    MemoryBackend::new()
        .layer(PathFilterLayer::new()
            .allow("/**")
            .deny("**/..*"))           // No hidden files
        .layer(RestrictionsLayer::new()
            .deny_symlinks())           // No symlink escapes
        .layer(QuotaLayer::new()
            .max_total_size(100 * 1024 * 1024)),
    "/mnt/agent-workspace"
)?;

// Agent's tools can now use standard filesystem APIs
// All operations are sandboxed, logged, and quota-limited
<span class="boring">}</span></code></pre>
<p><strong>Architecture:</strong></p>
<pre><code>┌────────────────────────────────────────────────┐
│  /mnt/myfs (FUSE mount point)                  │
├────────────────────────────────────────────────┤
│  anyfs-mount                                   │
│    - Linux/macOS/BSD: fuser                    │
│    - Windows: winfsp-rs                        │
├────────────────────────────────────────────────┤
│  Middleware stack (Quota, PathFilter, etc.)    │
├────────────────────────────────────────────────┤
│  FsFuse (Memory, SQLite, etc.)                │
│    └─ includes FsInode for efficient lookups  │
│                                                │
│  Optional: FsPosix for locks/xattr            │
└────────────────────────────────────────────────┘
</code></pre>
<p><strong>Requirements:</strong></p>
<ul>
<li>Backend must implement <code>FsFuse</code> (includes <code>FsInode</code> for efficient inode operations)</li>
<li>Backends implementing <code>FsPosix</code> get full lock/xattr support</li>
<li>Platform-specific FUSE provider must be installed</li>
</ul>
<h3 id="anyfs-vfs-compat---interop-with-vfs-crate"><a class="header" href="#anyfs-vfs-compat---interop-with-vfs-crate"><code>anyfs-vfs-compat</code> - Interop with <code>vfs</code> crate</a></h3>
<p>Adapter crate for bidirectional compatibility with the <a href="https://github.com/manuel-woelker/rust-vfs"><code>vfs</code></a> crate ecosystem.</p>
<p><strong>Why not adopt their trait?</strong> The <code>vfs::FileSystem</code> trait is too limited:</p>
<ul>
<li>No symlinks, hard links, or permissions</li>
<li>No <code>sync</code>/<code>fsync</code> for durability</li>
<li>No <code>truncate</code>, <code>statfs</code>, or <code>read_range</code></li>
<li>No middleware composition pattern</li>
</ul>
<p><strong>Our layered traits are a superset</strong> - <code>Fs</code> covers everything <code>vfs::FileSystem</code> does, plus our extended traits add more.</p>
<p><strong>Adapters:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wrap a vfs::FileSystem to use as AnyFS backend
// Only implements Fs (Layer 1) - no links, permissions, etc.
pub struct VfsCompat&lt;F: vfs::FileSystem&gt;(F);
impl&lt;F: vfs::FileSystem&gt; FsRead for VfsCompat&lt;F&gt; { ... }
impl&lt;F: vfs::FileSystem&gt; FsWrite for VfsCompat&lt;F&gt; { ... }
impl&lt;F: vfs::FileSystem&gt; FsDir for VfsCompat&lt;F&gt; { ... }
// VfsCompat&lt;F&gt; implements Fs via blanket impl

// Wrap an AnyFS backend to use as vfs::FileSystem
// Any backend implementing Fs works
pub struct AnyFsCompat&lt;B: Fs&gt;(B);
impl&lt;B: Fs&gt; vfs::FileSystem for AnyFsCompat&lt;B&gt; { ... }
<span class="boring">}</span></code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Migrate from <code>vfs</code> to AnyFS incrementally</li>
<li>Use existing <code>vfs</code> backends (EmbeddedFS) in AnyFS</li>
<li>Use AnyFS backends in projects that depend on <code>vfs</code></li>
</ul>
<h3 id="cloud-storage--remote-access"><a class="header" href="#cloud-storage--remote-access">Cloud Storage &amp; Remote Access</a></h3>
<p>The layered trait design enables building cloud storage services - each adapter requires only the traits it needs.</p>
<p><strong>Architecture:</strong></p>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│                          YOUR SERVER                                │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  Quota&lt;Tracing&lt;SqliteBackend&gt;&gt;  (implements FsFuse)          │  │
│  └───────────────────────────────────────────────────────────────┘  │
│         ▲              ▲              ▲              ▲              │
│         │              │              │              │              │
│    ┌────┴────┐   ┌─────┴─────┐  ┌─────┴─────┐  ┌─────┴─────┐       │
│    │ S3 API  │   │ gRPC/REST │  │    NFS    │  │  WebDAV   │       │
│    │  (Fs)   │   │   (Fs)    │  │ (FsFuse) │  │  (FsFull)│       │
│    └────┬────┘   └─────┬─────┘  └─────┬─────┘  └─────┬─────┘       │
└─────────┼──────────────┼──────────────┼──────────────┼─────────────┘
          │              │              │              │
          ▼              ▼              ▼              ▼
    AWS SDK/CLI    Your SDK/app    mount /cloud   mount /webdav
</code></pre>
<p><strong>Future crates for remote access:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Required Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-s3-server</code></td><td><code>Fs</code></td><td>Expose as S3-compatible API (objects = files)</td></tr>
<tr><td><code>anyfs-sftp-server</code></td><td><code>FsFull</code></td><td>SFTP server with permissions/links</td></tr>
<tr><td><code>anyfs-ssh-shell</code></td><td><code>FsFuse</code></td><td>SSH server with FUSE-mounted home directories</td></tr>
<tr><td><code>anyfs-remote</code></td><td><code>Fs</code></td><td><code>RemoteBackend</code> client (implements <code>Fs</code>)</td></tr>
<tr><td><code>anyfs-grpc</code></td><td><code>Fs</code></td><td>gRPC protocol adapter</td></tr>
<tr><td><code>anyfs-webdav</code></td><td><code>FsFull</code></td><td>WebDAV server (needs permissions)</td></tr>
<tr><td><code>anyfs-nfs</code></td><td><code>FsFuse</code></td><td>NFS server (needs inodes)</td></tr>
</tbody>
</table>
</div>
<h4 id="anyfs-s3-server---s3-compatible-object-storage"><a class="header" href="#anyfs-s3-server---s3-compatible-object-storage"><code>anyfs-s3-server</code> - S3-Compatible Object Storage</a></h4>
<p>Expose any <code>Fs</code> backend as an S3-compatible API. Users access your storage with standard AWS SDKs.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, TracingLayer};
use anyfs_s3_server::S3Server;

// Your storage backend with quotas and audit logging
let backend = SqliteBackend::open("storage.db")?
    .layer(TracingLayer::new())
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024 * 1024)  // 100GB
        .build());

S3Server::new(backend)
    .with_auth(auth_provider)       // Your auth implementation
    .with_bucket("user-files")      // Virtual bucket name
    .bind("0.0.0.0:9000")
    .run()
    .await?;
<span class="boring">}</span></code></pre>
<p><strong>Client usage (standard AWS CLI/SDK):</strong></p>
<pre><code class="language-bash"># Upload a file
aws s3 cp document.pdf s3://user-files/ --endpoint-url http://yourserver:9000

# List files
aws s3 ls s3://user-files/ --endpoint-url http://yourserver:9000

# Download a file
aws s3 cp s3://user-files/document.pdf ./local.pdf --endpoint-url http://yourserver:9000
</code></pre>
<h4 id="anyfs-remote---remote-backend-client"><a class="header" href="#anyfs-remote---remote-backend-client"><code>anyfs-remote</code> - Remote Backend Client</a></h4>
<p>An <code>Fs</code> implementation that connects to a remote server. Works with <code>FileStorage</code> or <code>anyfs-mount</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_remote::RemoteBackend;
use anyfs::FileStorage;

// Connect to your cloud service
let remote = RemoteBackend::connect("https://api.yourservice.com")
    .with_auth(api_key)
    .await?;

// Use like any other backend
let fs = FileStorage::new(remote);
fs.write("/documents/report.pdf", data)?;
<span class="boring">}</span></code></pre>
<p><strong>Combined with FUSE for transparent mount:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_remote::RemoteBackend;
use anyfs_fuse::FuseMount;

// Mount remote storage as local directory
let remote = RemoteBackend::connect("https://yourserver.com")?;
FuseMount::mount(remote, "/mnt/cloud")?;

// Now use standard filesystem tools:
// $ cp file.txt /mnt/cloud/
// $ ls /mnt/cloud/
// $ cat /mnt/cloud/file.txt
<span class="boring">}</span></code></pre>
<h4 id="anyfs-grpc---grpc-protocol"><a class="header" href="#anyfs-grpc---grpc-protocol"><code>anyfs-grpc</code> - gRPC Protocol</a></h4>
<p>Efficient binary protocol for remote <code>Fs</code> access.</p>
<p><strong>Server side:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_grpc::GrpcServer;

let backend = SqliteBackend::open("storage.db")?;
GrpcServer::new(backend)
    .bind("[::1]:50051")
    .serve()
    .await?;
<span class="boring">}</span></code></pre>
<p><strong>Client side:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_grpc::GrpcBackend;

let backend = GrpcBackend::connect("http://[::1]:50051").await?;
let fs = FileStorage::new(backend);
<span class="boring">}</span></code></pre>
<h4 id="multi-tenant-cloud-storage-example"><a class="header" href="#multi-tenant-cloud-storage-example">Multi-Tenant Cloud Storage Example</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, PathFilterLayer, TracingLayer};
use anyfs_s3_server::S3Server;

// Per-tenant backend factory
fn create_tenant_storage(tenant_id: &amp;str, quota_bytes: u64) -&gt; impl Fs {
    let db_path = format!("/data/tenants/{}.db", tenant_id);

    SqliteBackend::open(&amp;db_path).unwrap()
        .layer(TracingLayer::new()
            .with_target(&amp;format!("tenant.{}", tenant_id)))
        .layer(PathFilterLayer::builder()
            .allow("/**")
            .deny("../**")  // No path traversal
            .build())
        .layer(QuotaLayer::builder()
            .max_total_size(quota_bytes)
            .build())
}

// Tenant-aware S3 server
S3Server::new_multi_tenant(|request| {
    let tenant_id = extract_tenant(request)?;
    let quota = get_tenant_quota(tenant_id)?;
    Ok(create_tenant_storage(tenant_id, quota))
})
.bind("0.0.0.0:9000")
.run()
.await?;
<span class="boring">}</span></code></pre>
<h4 id="anyfs-sftp-server---sftp-access-with-shell-commands"><a class="header" href="#anyfs-sftp-server---sftp-access-with-shell-commands"><code>anyfs-sftp-server</code> - SFTP Access with Shell Commands</a></h4>
<p>Expose a <code>FsFull</code> backend as an SFTP server. Users connect with standard SSH/SFTP clients and navigate with familiar shell commands.</p>
<p><strong>Architecture:</strong></p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                      YOUR SERVER                                │
│                                                                 │
│  ┌───────────────┐    ┌───────────────────────────────────────┐ │
│  │ SFTP Server   │───▶│ User's isolated FileStorage           │ │
│  │ (anyfs-sftp)  │    │   └─▶ Quota&lt;SqliteBackend&gt;            │ │
│  └───────────────┘    │       └─▶ /data/users/alice.db        │ │
│         ▲             └───────────────────────────────────────┘ │
└─────────┼───────────────────────────────────────────────────────┘
          │
          │ sftp://
          │
    ┌─────┴─────┐
    │  Remote   │  $ cd /documents
    │  User     │  $ ls
    │  (shell)  │  $ put file.txt
    └───────────┘
</code></pre>
<p><strong>Server implementation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, TracingLayer};
use anyfs_sftp_server::SftpServer;

// Per-user isolated backend factory
fn get_user_storage(username: &amp;str) -&gt; impl FsFull {
    let db_path = format!("/data/users/{}.db", username);

    SqliteBackend::open(&amp;db_path).unwrap()
        .layer(TracingLayer::new()
            .with_target(&amp;format!("user.{}", username)))
        .layer(QuotaLayer::builder()
            .max_total_size(10 * 1024 * 1024 * 1024)  // 10GB per user
            .build())
}

SftpServer::new(get_user_storage)
    .with_host_key("/etc/ssh/host_key")
    .bind("0.0.0.0:22")
    .run()
    .await?;
<span class="boring">}</span></code></pre>
<p><strong>User experience (standard SFTP client):</strong></p>
<pre><code class="language-bash">$ sftp alice@yourserver.com
Connected to yourserver.com.
sftp&gt; pwd
/
sftp&gt; ls
documents/  photos/  backup/
sftp&gt; cd documents
sftp&gt; ls
report.pdf  notes.txt
sftp&gt; put local_file.txt
Uploading local_file.txt to /documents/local_file.txt
sftp&gt; get notes.txt
Downloading /documents/notes.txt
sftp&gt; mkdir projects
sftp&gt; rm old_file.txt
</code></pre>
<p>All operations happen on the user’s isolated SQLite database on your server.</p>
<h4 id="anyfs-ssh-shell---full-shell-access-with-sandboxed-home"><a class="header" href="#anyfs-ssh-shell---full-shell-access-with-sandboxed-home"><code>anyfs-ssh-shell</code> - Full Shell Access with Sandboxed Home</a></h4>
<p>Give users a real SSH shell where their home directory is backed by <code>FsFuse</code>.</p>
<p><strong>Server implementation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Quota};
use anyfs_fuse::FuseMount;
use anyfs_ssh_shell::SshShellServer;

// On user login, mount their isolated storage as $HOME
fn on_user_login(username: &amp;str) -&gt; Result&lt;(), Error&gt; {
    let db_path = format!("/data/users/{}.db", username);
    let backend = SqliteBackend::open(&amp;db_path)?
        .layer(QuotaLayer::builder()
            .max_total_size(10 * 1024 * 1024 * 1024)
            .build());

    let mount_point = format!("/home/{}", username);
    FuseMount::mount(backend, &amp;mount_point)?;
    Ok(())
}

SshShellServer::new()
    .on_login(on_user_login)
    .bind("0.0.0.0:22")
    .run()
    .await?;
<span class="boring">}</span></code></pre>
<p><strong>User experience (full shell):</strong></p>
<pre><code class="language-bash">$ ssh alice@yourserver.com
Welcome to YourServer!

alice@server:~$ pwd
/home/alice
alice@server:~$ ls -la
total 3
drwxr-xr-x  4 alice alice 4096 Dec 25 10:00 .
drwxr-xr-x  2 alice alice 4096 Dec 25 10:00 documents
drwxr-xr-x  2 alice alice 4096 Dec 25 10:00 photos

alice@server:~$ cat documents/notes.txt
Hello world!

alice@server:~$ echo "new content" &gt; documents/new_file.txt

alice@server:~$ du -sh .
150M    .

# Everything they do is actually stored in /data/users/alice.db on the server!
# They can use vim, gcc, python - all working on their isolated FsFuse backend
</code></pre>
<h4 id="isolated-shell-hosting-use-cases"><a class="header" href="#isolated-shell-hosting-use-cases">Isolated Shell Hosting Use Cases</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Backend Stack</th><th>What Users Get</th></tr>
</thead>
<tbody>
<tr><td>Shared hosting</td><td><code>Quota&lt;SqliteBackend&gt;</code></td><td>Shell + isolated home in SQLite</td></tr>
<tr><td>Dev containers</td><td><code>Overlay&lt;BaseImage, MemoryBackend&gt;</code></td><td>Shared base + ephemeral scratch</td></tr>
<tr><td>Coding education</td><td><code>Quota&lt;MemoryBackend&gt;</code></td><td>Temporary sandboxed environment</td></tr>
<tr><td>CI/CD runners</td><td><code>Tracing&lt;MemoryBackend&gt;</code></td><td>Audited ephemeral workspace</td></tr>
<tr><td>Secure file drop</td><td><code>PathFilter&lt;SqliteBackend&gt;</code></td><td>Write-only inbox directory</td></tr>
</tbody>
</table>
</div>
<h4 id="access-pattern-summary"><a class="header" href="#access-pattern-summary">Access Pattern Summary</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Access Method</th><th>Crate</th><th>Client Requirement</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td>S3 API</td><td><code>anyfs-s3-server</code></td><td>AWS SDK (any language)</td><td>Object storage, web apps</td></tr>
<tr><td>SFTP</td><td><code>anyfs-sftp-server</code></td><td>Any SFTP client</td><td>Shell-like file access</td></tr>
<tr><td>SSH Shell</td><td><code>anyfs-ssh-shell</code> + <code>anyfs-mount</code></td><td>SSH client</td><td>Full shell with sandboxed home</td></tr>
<tr><td>gRPC</td><td><code>anyfs-grpc</code></td><td>Generated client</td><td>High-performance apps</td></tr>
<tr><td>REST</td><td>Custom adapter</td><td>HTTP client</td><td>Simple integrations</td></tr>
<tr><td>FUSE mount</td><td><code>anyfs-mount</code> + <code>anyfs-remote</code></td><td>FUSE installed</td><td>Transparent local access</td></tr>
<tr><td>WebDAV</td><td><code>anyfs-webdav</code></td><td>WebDAV client/OS</td><td>File manager access</td></tr>
<tr><td>NFS</td><td><code>anyfs-nfs</code></td><td>NFS client</td><td>Unix network shares</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="lessons-learned-reference"><a class="header" href="#lessons-learned-reference">Lessons Learned (Reference)</a></h2>
<p>This plan incorporates lessons from issues in similar projects:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Source</th><th>Issue</th><th>Lesson Applied</th></tr>
</thead>
<tbody>
<tr><td>vfs #72</td><td>RwLock panic</td><td>Thread safety tests</td></tr>
<tr><td>vfs #47</td><td><code>create_dir_all</code> race</td><td>Concurrent stress tests</td></tr>
<tr><td>vfs #8, #23</td><td>Panics instead of errors</td><td>No-panic policy</td></tr>
<tr><td>vfs #24, #42</td><td>Path inconsistencies</td><td>Path edge case tests</td></tr>
<tr><td>vfs #33</td><td>Hard to match errors</td><td>Ergonomic <code>FsError</code> design</td></tr>
<tr><td>vfs #68</td><td>WASM panics</td><td>WASM compatibility tests</td></tr>
<tr><td>vfs #66</td><td><code>'static</code> confusion</td><td>Minimal trait bounds</td></tr>
<tr><td>agentfs #130</td><td>Slow file deletion</td><td>Performance documentation</td></tr>
<tr><td>agentfs #129</td><td>Signal handling</td><td>Proper <code>Drop</code> implementations</td></tr>
</tbody>
</table>
</div>
<p>See <a href="#lessons-from-similar-projects">Lessons from Similar Projects</a> for full analysis.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="backend-implementers-guide"><a class="header" href="#backend-implementers-guide">Backend Implementer’s Guide</a></h1>
<p>This guide walks you through implementing a custom AnyFS backend.</p>
<hr>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>AnyFS uses <strong>layered traits</strong> - you implement only what you need:</p>
<pre><code>FsPosix (full POSIX)
   │
FsFuse (FUSE-mountable)
   │
FsFull (std::fs features)
   │
   Fs (basic - 90% of use cases)
   │
FsRead + FsWrite + FsDir (core)
</code></pre>
<p>Key properties:</p>
<ul>
<li>Backends accept <code>impl AsRef&lt;Path&gt;</code> for all path parameters</li>
<li><strong>Backends receive already-resolved paths</strong> - FileStorage handles path resolution (symlinks, <code>..</code>, normalization)</li>
<li>Backends handle <strong>storage only</strong> - just store/retrieve bytes at given paths</li>
<li>Policy (limits, feature gates) is handled by middleware, not backends</li>
<li>Implement only the traits your backend supports</li>
<li><strong>Backends must be thread-safe</strong> - all trait methods use <code>&amp;self</code>, so backends must use interior mutability (e.g., <code>RwLock</code>, <code>Mutex</code>) for synchronization</li>
</ul>
<hr>
<h2 id="dependency"><a class="header" href="#dependency">Dependency</a></h2>
<p>Depend only on <code>anyfs-backend</code>:</p>
<pre><code class="language-toml">[dependencies]
anyfs-backend = "0.1"
</code></pre>
<hr>
<h2 id="choosing-which-traits-to-implement"><a class="header" href="#choosing-which-traits-to-implement">Choosing Which Traits to Implement</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Your Backend Supports</th><th>Implement</th></tr>
</thead>
<tbody>
<tr><td>Basic file operations</td><td><code>Fs</code> (= <code>FsRead</code> + <code>FsWrite</code> + <code>FsDir</code>)</td></tr>
<tr><td>Links, permissions, sync</td><td>Add <code>FsLink</code>, <code>FsPermissions</code>, <code>FsSync</code>, <code>FsStats</code></td></tr>
<tr><td>Hardlinks, FUSE mounting</td><td>Add <code>FsInode</code> → becomes <code>FsFuse</code></td></tr>
<tr><td>Full POSIX (handles, locks, xattr)</td><td>Add <code>FsHandles</code>, <code>FsLock</code>, <code>FsXattr</code> → becomes <code>FsPosix</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="minimal-backend-just-fs"><a class="header" href="#minimal-backend-just-fs">Minimal Backend: Just <code>Fs</code></a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Metadata, DirEntry};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

pub struct MyBackend {
    // Your storage fields
}

// Implement FsRead
impl FsRead for MyBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, FsError&gt; {
        let data = self.read(path)?;
        String::from_utf8(data).map_err(|e| FsError::Backend(e.to_string()))
    }

    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        todo!()
    }

    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        todo!()
    }

    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt; {
        todo!()
    }

    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
        let data = self.read(path)?;
        Ok(Box::new(std::io::Cursor::new(data)))
    }
}

// Implement FsWrite
impl FsWrite for MyBackend {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn append(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn remove_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn rename(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn copy(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn truncate(&amp;self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn open_write(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt; {
        todo!()
    }
}

// Implement FsDir
impl FsDir for MyBackend {
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt; {
        todo!()
    }

    fn create_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn create_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn remove_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn remove_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }
}

// MyBackend now implements Fs automatically (blanket impl)!
<span class="boring">}</span></code></pre>
<hr>
<h2 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h2>
<h3 id="step-1-pick-a-data-model"><a class="header" href="#step-1-pick-a-data-model">Step 1: Pick a Data Model</a></h3>
<p>Your backend needs internal storage. Options:</p>
<ul>
<li><strong>HashMap-based</strong>: <code>HashMap&lt;PathBuf, Entry&gt;</code> for simple cases</li>
<li><strong>Tree-based</strong>: Explicit directory tree structure</li>
<li><strong>Database-backed</strong>: SQLite, key-value store, etc.</li>
</ul>
<p>Minimum metadata per entry:</p>
<ul>
<li>File type (file/directory/symlink)</li>
<li>Size (for files)</li>
<li>Content (for files)</li>
<li>Timestamps (optional)</li>
<li>Permissions (optional)</li>
</ul>
<h3 id="step-2-implement-fsread-layer-1"><a class="header" href="#step-2-implement-fsread-layer-1">Step 2: Implement <code>FsRead</code> (Layer 1)</a></h3>
<p>Start with read operations (easiest):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsRead for MyBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, FsError&gt;;
    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;
    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt;;
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Streaming implementation options:</strong></p>
<p>For <code>MemoryBackend</code> or similar, you can use <code>std::io::Cursor</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
    let data = self.read(path)?;
    Ok(Box::new(std::io::Cursor::new(data)))
}
<span class="boring">}</span></code></pre>
<p>For <code>VRootFsBackend</code>, return the actual file handle:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
    let file = std::fs::File::open(self.resolve(path)?)?;
    Ok(Box::new(file))
}
<span class="boring">}</span></code></pre>
<h3 id="step-3-implement-fswrite-layer-1"><a class="header" href="#step-3-implement-fswrite-layer-1">Step 3: Implement <code>FsWrite</code> (Layer 1)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsWrite for MyBackend {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn append(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn rename(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn copy(&amp;self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn truncate(&amp;self, path: impl AsRef&lt;Path&gt;, size: u64) -&gt; Result&lt;(), FsError&gt;;
    fn open_write(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Note on truncate:</strong></p>
<ul>
<li>If <code>size &lt; current</code>: discard trailing bytes</li>
<li>If <code>size &gt; current</code>: extend with zero bytes</li>
<li>Required for FUSE support and editor save operations</li>
</ul>
<h3 id="step-4-implement-fsdir-layer-1"><a class="header" href="#step-4-implement-fsdir-layer-1">Step 4: Implement <code>FsDir</code> (Layer 1)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsDir for MyBackend {
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt;;
    fn create_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn create_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir_all(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Congratulations!</strong> After implementing <code>FsRead</code>, <code>FsWrite</code>, and <code>FsDir</code>, your backend implements <code>Fs</code> automatically (blanket impl). This covers 90% of use cases.</p>
<hr>
<h2 id="optional-layer-2-traits"><a class="header" href="#optional-layer-2-traits">Optional: Layer 2 Traits</a></h2>
<p>Add these if your backend supports the features:</p>
<h3 id="fslink---symlinks-and-hardlinks"><a class="header" href="#fslink---symlinks-and-hardlinks"><code>FsLink</code> - Symlinks and Hardlinks</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsLink for MyBackend {
    fn symlink(&amp;self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn hard_link(&amp;self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
    fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<ul>
<li>Symlinks store a target path as a string</li>
<li>Hard links share content with the original (update link count)</li>
</ul>
<h3 id="fspermissions-1"><a class="header" href="#fspermissions-1"><code>FsPermissions</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsPermissions for MyBackend {
    fn set_permissions(&amp;self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fssync---durability"><a class="header" href="#fssync---durability"><code>FsSync</code> - Durability</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsSync for MyBackend {
    fn sync(&amp;self) -&gt; Result&lt;(), FsError&gt;;
    fn fsync(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<ul>
<li><code>sync()</code>: Flush all pending writes to durable storage</li>
<li><code>fsync(path)</code>: Flush pending writes for a specific file</li>
<li><code>MemoryBackend</code> can no-op these (volatile by design)</li>
<li><code>SqliteBackend</code>: <code>PRAGMA wal_checkpoint</code> or connection flush</li>
<li><code>VRootFsBackend</code>: <code>std::fs::File::sync_all()</code></li>
</ul>
<h3 id="fsstats---filesystem-stats"><a class="header" href="#fsstats---filesystem-stats"><code>FsStats</code> - Filesystem Stats</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsStats for MyBackend {
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p>Return filesystem capacity information:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatFs {
    total_bytes: 0,      // 0 = unlimited
    used_bytes: ...,
    available_bytes: ...,
    total_inodes: 0,
    used_inodes: ...,
    available_inodes: ...,
    block_size: 4096,
    max_name_len: 255,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="optional-layer-3---fsinode-for-fuse"><a class="header" href="#optional-layer-3---fsinode-for-fuse">Optional: Layer 3 - <code>FsInode</code> (For FUSE)</a></h2>
<p>Implement <code>FsInode</code> if you need FUSE mounting or proper hardlink support:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsInode for MyBackend {
    fn path_to_inode(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;u64, FsError&gt;;
    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn lookup(&amp;self, parent_inode: u64, name: &amp;OsStr) -&gt; Result&lt;u64, FsError&gt;;
    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Default implementations exist</strong> (via blanket impl) - you only need to override for:</p>
<ul>
<li><strong>Hardlink support</strong>: Two paths must share the same inode</li>
<li><strong>FUSE efficiency</strong>: Direct inode operations without path lookup</li>
</ul>
<p><strong>Level 1: Simple backend (use defaults)</strong></p>
<p>Don’t implement <code>FsInode</code>. Hardlinks won’t work correctly, but basic operations will.</p>
<p><strong>Level 2: Hardlink support</strong></p>
<p>Override <code>path_to_inode</code> so hardlinked paths return the same inode:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node {
    id: u64,          // Unique node ID (the inode)
    nlink: u64,       // Hard link count
    content: Vec&lt;u8&gt;,
}

struct MemoryBackend {
    next_id: u64,
    nodes: HashMap&lt;u64, Node&gt;,           // inode -&gt; Node
    paths: HashMap&lt;PathBuf, u64&gt;,        // path -&gt; inode
}

impl FsInode for MemoryBackend {
    fn path_to_inode(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;u64, FsError&gt; {
        self.paths.get(path.as_ref())
            .copied()
            .ok_or_else(|| FsError::NotFound { path: path.as_ref().into() })
    }
    // ... implement others
}

impl FsLink for MemoryBackend {
    fn hard_link(&amp;self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let inode = self.path_to_inode(&amp;original)?;
        self.paths.insert(link.as_ref().to_path_buf(), inode);
        self.nodes.get_mut(&amp;inode).unwrap().nlink += 1;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Level 3: Full FUSE efficiency</strong></p>
<p>Override all 4 methods for O(1) inode operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsInode for SqliteBackend {
    fn path_to_inode(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;u64, FsError&gt; {
        self.conn.query_row(
            "SELECT id FROM nodes WHERE path = ?",
            [path.as_ref().to_string_lossy()],
            |row| Ok(row.get::&lt;_, i64&gt;(0)? as u64),
        ).map_err(|_| FsError::NotFound { path: path.as_ref().into() })
    }

    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt; {
        self.conn.query_row(
            "SELECT path FROM nodes WHERE id = ?",
            [inode as i64],
            |row| Ok(PathBuf::from(row.get::&lt;_, String&gt;(0)?)),
        ).map_err(|_| FsError::NotFound { path: format!("inode:{}", inode).into() })
    }

    fn lookup(&amp;self, parent_inode: u64, name: &amp;OsStr) -&gt; Result&lt;u64, FsError&gt; {
        self.conn.query_row(
            "SELECT id FROM nodes WHERE parent_id = ? AND name = ?",
            params![parent_inode as i64, name.to_string_lossy()],
            |row| Ok(row.get::&lt;_, i64&gt;(0)? as u64),
        ).map_err(|_| FsError::NotFound { path: name.into() })
    }

    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt; {
        self.conn.query_row(
            "SELECT type, size, nlink, created, modified FROM nodes WHERE id = ?",
            [inode as i64],
            |row| Ok(Metadata {
                inode,
                nlink: row.get(2)?,
                // ...
            }),
        ).map_err(|_| FsError::NotFound { path: format!("inode:{}", inode).into() })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Summary:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Your Backend</th><th>Implement</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>Simple (no hardlinks)</td><td>Nothing</td><td>Works with defaults</td></tr>
<tr><td>With hardlinks</td><td><code>FsInode::path_to_inode</code></td><td>Hardlinks work correctly</td></tr>
<tr><td>FUSE-optimized</td><td>Full <code>FsInode</code></td><td>Maximum performance</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="optional-layer-4---posix-traits"><a class="header" href="#optional-layer-4---posix-traits">Optional: Layer 4 - POSIX Traits</a></h2>
<p>For full POSIX semantics (file handles, locking, extended attributes):</p>
<h3 id="fshandles---file-handle-operations"><a class="header" href="#fshandles---file-handle-operations"><code>FsHandles</code> - File Handle Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsHandles for MyBackend {
    fn open(&amp;self, path: impl AsRef&lt;Path&gt;, flags: OpenFlags) -&gt; Result&lt;Handle, FsError&gt;;
    fn read_at(&amp;self, handle: Handle, buf: &amp;mut [u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn write_at(&amp;self, handle: Handle, data: &amp;[u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn close(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fslock---file-locking"><a class="header" href="#fslock---file-locking"><code>FsLock</code> - File Locking</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsLock for MyBackend {
    fn lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;(), FsError&gt;;
    fn try_lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;bool, FsError&gt;;
    fn unlock(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fsxattr---extended-attributes"><a class="header" href="#fsxattr---extended-attributes"><code>FsXattr</code> - Extended Attributes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsXattr for MyBackend {
    fn get_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn set_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str, value: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_xattr(&amp;self, path: impl AsRef&lt;Path&gt;, name: &amp;str) -&gt; Result&lt;(), FsError&gt;;
    fn list_xattr(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;String&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> Most backends don’t need Layer 4. Only implement if you’re wrapping a real filesystem (<code>VRootFsBackend</code>) or building a database that needs full POSIX semantics.</p>
<hr>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<p>Return appropriate <code>FsError</code> variants:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Situation</th><th>Error</th></tr>
</thead>
<tbody>
<tr><td>Path doesn’t exist</td><td><code>FsError::NotFound { path, operation }</code></td></tr>
<tr><td>Path already exists</td><td><code>FsError::AlreadyExists { path, operation }</code></td></tr>
<tr><td>Expected file, got dir</td><td><code>FsError::NotAFile { path }</code></td></tr>
<tr><td>Expected dir, got file</td><td><code>FsError::NotADirectory { path }</code></td></tr>
<tr><td>Remove non-empty dir</td><td><code>FsError::DirectoryNotEmpty { path }</code></td></tr>
<tr><td>Internal error</td><td><code>FsError::Backend { message }</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="what-backends-do-not-do"><a class="header" href="#what-backends-do-not-do">What Backends Do NOT Do</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Where It Lives</th></tr>
</thead>
<tbody>
<tr><td>Quota enforcement</td><td><code>Quota&lt;B&gt;</code> middleware</td></tr>
<tr><td>Feature gating</td><td><code>Restrictions&lt;B&gt;</code> middleware</td></tr>
<tr><td>Logging</td><td><code>Tracing&lt;B&gt;</code> middleware</td></tr>
<tr><td>Ergonomic API</td><td><code>FileStorage&lt;M&gt;</code> wrapper</td></tr>
</tbody>
</table>
</div>
<p><strong>Backends focus on storage.</strong> Keep them simple.</p>
<hr>
<h2 id="testing-your-backend"><a class="header" href="#testing-your-backend">Testing Your Backend</a></h2>
<p>Use the conformance test suite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::MyBackend;
    use anyfs_backend::Fs;

    fn create_backend() -&gt; MyBackend {
        MyBackend::new()
    }

    #[test]
    fn test_write_read() {
        let backend = create_backend();
        backend.write("/test.txt", b"hello").unwrap();
        let content = backend.read("/test.txt").unwrap();
        assert_eq!(content, b"hello");
    }

    #[test]
    fn test_create_dir() {
        let backend = create_backend();
        backend.create_dir("/foo").unwrap();
        assert!(backend.exists("/foo").unwrap());
    }

    // ... more tests
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="note-on-vrootfsbackend"><a class="header" href="#note-on-vrootfsbackend">Note on VRootFsBackend</a></h2>
<p>If you are implementing a backend that wraps a <strong>real host filesystem directory</strong>, consider using <code>strict-path::VirtualPath</code> and <code>strict-path::VirtualRoot</code> internally for path containment. This ensures paths cannot escape the designated root directory.</p>
<p>This is an implementation choice for filesystem-based backends, not a requirement of the <code>Fs</code> trait.</p>
<hr>
<h2 id="for-middleware-authors-wrapping-streams"><a class="header" href="#for-middleware-authors-wrapping-streams">For Middleware Authors: Wrapping Streams</a></h2>
<p>Middleware that needs to intercept streaming I/O must wrap the returned <code>Box&lt;dyn Read/Write&gt;</code>.</p>
<h3 id="countingwriter-example"><a class="header" href="#countingwriter-example">CountingWriter Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}};

pub struct CountingWriter&lt;W: Write&gt; {
    inner: W,
    bytes_written: Arc&lt;AtomicU64&gt;,
}

impl&lt;W: Write&gt; CountingWriter&lt;W&gt; {
    pub fn new(inner: W, counter: Arc&lt;AtomicU64&gt;) -&gt; Self {
        Self { inner, bytes_written: counter }
    }
}

impl&lt;W: Write + Send&gt; Write for CountingWriter&lt;W&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        let n = self.inner.write(buf)?;
        self.bytes_written.fetch_add(n as u64, Ordering::Relaxed);
        Ok(n)
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        self.inner.flush()
    }
}
<span class="boring">}</span></code></pre>
<h3 id="using-in-quota-middleware"><a class="header" href="#using-in-quota-middleware">Using in Quota Middleware</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: Fs&gt; Fs for Quota&lt;B&gt; {
    fn open_write(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt; {
        // Check if we're at quota before opening
        if self.usage.total_bytes &gt;= self.limits.max_total_size {
            return Err(FsError::QuotaExceeded { ... });
        }

        let inner = self.inner.open_write(path)?;
        Ok(Box::new(CountingWriter::new(inner, self.usage.bytes_counter.clone())))
    }
}
<span class="boring">}</span></code></pre>
<h3 id="alternatives-to-wrapping"><a class="header" href="#alternatives-to-wrapping">Alternatives to Wrapping</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>Alternative to wrapping</th></tr>
</thead>
<tbody>
<tr><td>PathFilter</td><td>Check path at open time, pass stream through</td></tr>
<tr><td>ReadOnly</td><td>Block <code>open_write</code> entirely</td></tr>
<tr><td>RateLimit</td><td>Count the open call, not stream bytes</td></tr>
<tr><td>Tracing</td><td>Log the open call, pass stream through</td></tr>
<tr><td>DryRun</td><td>Return <code>std::io::sink()</code> instead of real writer</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="creating-custom-middleware"><a class="header" href="#creating-custom-middleware">Creating Custom Middleware</a></h2>
<p>Custom middleware only requires <code>anyfs-backend</code> as a dependency - same as backends.</p>
<h3 id="dependency-1"><a class="header" href="#dependency-1">Dependency</a></h3>
<pre><code class="language-toml">[dependencies]
anyfs-backend = "0.1"
</code></pre>
<h3 id="the-pattern-5-minutes-to-understand"><a class="header" href="#the-pattern-5-minutes-to-understand">The Pattern (5 Minutes to Understand)</a></h3>
<p>Middleware is just a struct that:</p>
<ol>
<li>Wraps another <code>Fs</code></li>
<li>Implements <code>Fs</code> itself</li>
<li>Intercepts some methods, delegates others</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//  ┌─────────────────────────────────────┐
//  │  Your Middleware                    │
//  │  ┌─────────────────────────────────┐│
//  │  │  Inner Backend (any Fs) ││
//  │  └─────────────────────────────────┘│
//  └─────────────────────────────────────┘
//
//  Request → Middleware (intercept/modify) → Inner Backend
//  Response ← Middleware (intercept/modify) ← Inner Backend
<span class="boring">}</span></code></pre>
<h3 id="simplest-possible-middleware-operation-counter"><a class="header" href="#simplest-possible-middleware-operation-counter">Simplest Possible Middleware: Operation Counter</a></h3>
<p>This middleware counts how many operations are performed:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, FsError, Metadata, DirEntry, Permissions, StatFs};
use std::sync::atomic::{AtomicU64, Ordering};
use std::path::{Path, PathBuf};

/// Counts all operations performed on the backend.
pub struct Counter&lt;B&gt; {
    inner: B,
    pub count: AtomicU64,
}

impl&lt;B&gt; Counter&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self { inner, count: AtomicU64::new(0) }
    }

    pub fn operations(&amp;self) -&gt; u64 {
        self.count.load(Ordering::Relaxed)
    }
}

// Implement each trait the inner backend supports
impl&lt;B: FsRead&gt; FsRead for Counter&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);  // Count it
        self.inner.read(path)                         // Delegate
    }

    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.exists(path)
    }

    // ... repeat for all FsRead methods
}

impl&lt;B: FsWrite&gt; FsWrite for Counter&lt;B&gt; {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);  // Count it
        self.inner.write(path, data)                  // Delegate
    }

    // ... repeat for all FsWrite methods
}

impl&lt;B: FsDir&gt; FsDir for Counter&lt;B&gt; {
    // ... implement FsDir methods
}

// Counter&lt;B&gt; now implements Fs when B: Fs (blanket impl)
<span class="boring">}</span></code></pre>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = Counter::new(MemoryBackend::new());
backend.write("/file.txt", b"hello")?;
backend.read("/file.txt")?;
backend.read("/file.txt")?;

println!("Operations: {}", backend.operations());  // 3
<span class="boring">}</span></code></pre>
<p>That’s it. That’s the entire pattern.</p>
<h3 id="adding-a-layer-for-layer-syntax"><a class="header" href="#adding-a-layer-for-layer-syntax">Adding a Layer (for .layer() syntax)</a></h3>
<p>To enable the fluent <code>.layer()</code> syntax, add a Layer struct:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::Layer;

pub struct CounterLayer;

impl&lt;B: Fs&gt; Layer&lt;B&gt; for CounterLayer {
    type Backend = Counter&lt;B&gt;;

    fn layer(self, backend: B) -&gt; Counter&lt;B&gt; {
        Counter::new(backend)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Usage with .layer():</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = MemoryBackend::new()
    .layer(CounterLayer);
<span class="boring">}</span></code></pre>
<h3 id="real-example-readonly-middleware"><a class="header" href="#real-example-readonly-middleware">Real Example: ReadOnly Middleware</a></h3>
<p>A practical middleware that blocks all write operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReadOnly&lt;B&gt; {
    inner: B,
}

impl&lt;B&gt; ReadOnly&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self { inner }
    }
}

// FsRead: just delegate
impl&lt;B: FsRead&gt; FsRead for ReadOnly&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.inner.read(path)
    }

    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        self.inner.exists(path)
    }

    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)
    }

    // ... delegate all FsRead methods
}

// FsDir: delegate reads, block writes
impl&lt;B: FsDir&gt; FsDir for ReadOnly&lt;B&gt; {
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt; {
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, _path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "create_dir" })
    }

    fn create_dir_all(&amp;self, _path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "create_dir_all" })
    }

    fn remove_dir(&amp;self, _path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_dir" })
    }

    fn remove_dir_all(&amp;self, _path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_dir_all" })
    }
}

// FsWrite: block all operations
impl&lt;B: FsWrite&gt; FsWrite for ReadOnly&lt;B&gt; {
    fn write(&amp;self, _path: impl AsRef&lt;Path&gt;, _data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "write" })
    }

    fn remove_file(&amp;self, _path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_file" })
    }

    // ... block all FsWrite methods
}
<span class="boring">}</span></code></pre>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = ReadOnly::new(MemoryBackend::new());

backend.read("/file.txt");       // OK (if file exists)
backend.write("/file.txt", b""); // Error: ReadOnly
<span class="boring">}</span></code></pre>
<h3 id="middleware-decision-table"><a class="header" href="#middleware-decision-table">Middleware Decision Table</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>What You Want</th><th>Intercept</th><th>Delegate</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Count operations</td><td>All methods (before)</td><td>All methods</td><td><code>Counter</code></td></tr>
<tr><td>Block writes</td><td>Write methods</td><td>Read methods</td><td><code>ReadOnly</code></td></tr>
<tr><td>Transform data</td><td><code>read</code>/<code>write</code></td><td>Everything else</td><td><code>Encryption</code></td></tr>
<tr><td>Check permissions</td><td>All methods (before)</td><td>All methods</td><td><code>PathFilter</code></td></tr>
<tr><td>Log operations</td><td>All methods (before)</td><td>All methods</td><td><code>Tracing</code></td></tr>
<tr><td>Enforce limits</td><td>Write methods (check size)</td><td>Read methods</td><td><code>Quota</code></td></tr>
</tbody>
</table>
</div>
<h3 id="macro-for-boilerplate-optional"><a class="header" href="#macro-for-boilerplate-optional">Macro for Boilerplate (Optional)</a></h3>
<p>If you don’t want to manually delegate all 29 methods, you can use a macro:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! delegate {
    ($self:ident, $method:ident, $($arg:ident),*) =&gt; {
        $self.inner.$method($($arg),*)
    };
}

impl&lt;B: Fs&gt; Fs for MyMiddleware&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Your logic here
        delegate!(self, read, path)
    }

    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        delegate!(self, exists, path)
    }

    // ... etc
}
<span class="boring">}</span></code></pre>
<p>Or provide a <code>delegate_all!</code> macro in <code>anyfs-backend</code> that generates all the passthrough implementations.</p>
<h3 id="complete-example-encryption-middleware"><a class="header" href="#complete-example-encryption-middleware">Complete Example: Encryption Middleware</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, Layer, FsError, Metadata, DirEntry};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

/// Middleware that encrypts/decrypts file contents transparently.
pub struct Encrypted&lt;B&gt; {
    inner: B,
    key: [u8; 32],
}

impl&lt;B&gt; Encrypted&lt;B&gt; {
    pub fn new(inner: B, key: [u8; 32]) -&gt; Self {
        Self { inner, key }
    }

    fn encrypt(&amp;self, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
        // Your encryption logic here
        data.iter().map(|b| b ^ self.key[0]).collect()
    }

    fn decrypt(&amp;self, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
        // Your decryption logic here (symmetric for XOR)
        self.encrypt(data)
    }
}

// FsRead: decrypt on read
impl&lt;B: FsRead&gt; FsRead for Encrypted&lt;B&gt; {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let encrypted = self.inner.read(path)?;
        Ok(self.decrypt(&amp;encrypted))
    }

    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        self.inner.exists(path)
    }

    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)
    }

    // ... delegate other FsRead methods
}

// FsWrite: encrypt on write
impl&lt;B: FsWrite&gt; FsWrite for Encrypted&lt;B&gt; {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let encrypted = self.encrypt(data);
        self.inner.write(path, &amp;encrypted)
    }

    // ... delegate/encrypt other FsWrite methods
}

// FsDir: just delegate (directories don't need encryption)
impl&lt;B: FsDir&gt; FsDir for Encrypted&lt;B&gt; {
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt; {
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        self.inner.create_dir(path)
    }

    // ... delegate other FsDir methods
}

// Encrypted&lt;B&gt; now implements Fs when B: Fs (blanket impl)

/// Layer for creating Encrypted middleware.
pub struct EncryptedLayer {
    key: [u8; 32],
}

impl EncryptedLayer {
    pub fn new(key: [u8; 32]) -&gt; Self {
        Self { key }
    }
}

impl&lt;B: Fs&gt; Layer&lt;B&gt; for EncryptedLayer {
    type Backend = Encrypted&lt;B&gt;;

    fn layer(self, backend: B) -&gt; Self::Backend {
        Encrypted::new(backend, self.key)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use my_middleware::{EncryptedLayer, Encrypted};

// Direct construction
let fs = Encrypted::new(MemoryBackend::new(), key);

// Or via Layer trait
let fs = MemoryBackend::new()
    .layer(EncryptedLayer::new(key));
<span class="boring">}</span></code></pre>
<h3 id="middleware-checklist"><a class="header" href="#middleware-checklist">Middleware Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Depends only on <code>anyfs-backend</code></li>
<li><input disabled="" type="checkbox"> Implements the same traits as the inner backend (<code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code>, etc.)</li>
<li><input disabled="" type="checkbox"> Implements <code>Layer&lt;B&gt;</code> for <code>MyMiddlewareLayer</code></li>
<li><input disabled="" type="checkbox"> Delegates unmodified operations to inner backend</li>
<li><input disabled="" type="checkbox"> Handles streaming I/O appropriately (wrap, pass-through, or block)</li>
<li><input disabled="" type="checkbox"> Documents which operations are intercepted vs delegated</li>
</ul>
<hr>
<h2 id="backend-checklist"><a class="header" href="#backend-checklist">Backend Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Depends only on <code>anyfs-backend</code></li>
<li><input disabled="" type="checkbox"> Implements core traits: <code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code> (= <code>Fs</code>)</li>
<li><input disabled="" type="checkbox"> Optional: Implements <code>FsLink</code>, <code>FsPermissions</code>, <code>FsSync</code>, <code>FsStats</code> (= <code>FsFull</code>)</li>
<li><input disabled="" type="checkbox"> Optional: Implements <code>FsInode</code> for FUSE support (= <code>FsFuse</code>)</li>
<li><input disabled="" type="checkbox"> Optional: Implements <code>FsHandles</code>, <code>FsLock</code>, <code>FsXattr</code> for POSIX (= <code>FsPosix</code>)</li>
<li><input disabled="" type="checkbox"> Accepts <code>impl AsRef&lt;Path&gt;</code> for all paths</li>
<li><input disabled="" type="checkbox"> Returns correct <code>FsError</code> variants</li>
<li><input disabled="" type="checkbox"> Passes conformance tests for implemented traits</li>
<li><input disabled="" type="checkbox"> No panics (see below)</li>
<li><input disabled="" type="checkbox"> Thread-safe (see below)</li>
<li><input disabled="" type="checkbox"> Documents performance characteristics</li>
</ul>
<hr>
<h2 id="critical-implementation-guidelines"><a class="header" href="#critical-implementation-guidelines">Critical Implementation Guidelines</a></h2>
<p>These guidelines are derived from issues found in similar projects (<code>vfs</code>, <code>agentfs</code>). <strong>All implementations MUST follow these.</strong></p>
<h3 id="1-no-panic-policy-1"><a class="header" href="#1-no-panic-policy-1">1. No Panic Policy</a></h3>
<p><strong>NEVER use <code>.unwrap()</code> or <code>.expect()</code> in library code.</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - will panic on missing file
fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
    let entry = self.entries.get(path.as_ref()).unwrap();  // PANIC!
    Ok(entry.content.clone())
}

// GOOD - returns error
fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
    let path = path.as_ref();
    let entry = self.entries.get(path)
        .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;
    Ok(entry.content.clone())
}
<span class="boring">}</span></code></pre>
<p><strong>Edge cases that must NOT panic:</strong></p>
<ul>
<li>File doesn’t exist</li>
<li>Directory doesn’t exist</li>
<li>Path is empty string</li>
<li>Path is invalid UTF-8 (if using OsStr)</li>
<li>Parent directory missing</li>
<li>Trying to read a directory as a file</li>
<li>Trying to list a file as a directory</li>
<li>Concurrent access conflicts</li>
</ul>
<h3 id="2-thread-safety-required"><a class="header" href="#2-thread-safety-required">2. Thread Safety (Required)</a></h3>
<p><strong>All trait methods use <code>&amp;self</code>, not <code>&amp;mut self</code>.</strong> This means backends MUST use interior mutability for thread-safe concurrent access.</p>
<p><strong>Why <code>&amp;self</code>?</strong></p>
<ul>
<li>Enables concurrent access patterns (multiple readers, concurrent operations)</li>
<li>Matches real filesystem semantics (concurrent access is normal)</li>
<li>More flexible API (can share references without exclusive ownership)</li>
</ul>
<p><strong>Backend implementer responsibility:</strong></p>
<ul>
<li>Use <code>RwLock</code>, <code>Mutex</code>, or similar for internal state</li>
<li>Ensure operations are atomic (a single <code>write()</code> call shouldn’t produce partial results)</li>
<li>Handle lock poisoning gracefully</li>
</ul>
<p><strong>What the synchronization guarantees:</strong></p>
<ul>
<li>Memory safety (no data corruption)</li>
<li>Atomic operations (writes don’t interleave)</li>
</ul>
<p><strong>What it does NOT guarantee:</strong></p>
<ul>
<li>Order of concurrent writes to the same path (last write wins - standard FS behavior)</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, RwLock};
use std::collections::HashMap;
use std::path::PathBuf;

pub struct MemoryBackend {
    entries: Arc&lt;RwLock&lt;HashMap&lt;PathBuf, Entry&gt;&gt;&gt;,
}

impl FsRead for MemoryBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let entries = self.entries.read()
            .map_err(|_| FsError::Backend("lock poisoned".into()))?;
        // ...
    }
}

impl FsWrite for MemoryBackend {
    fn write(&amp;self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let mut entries = self.entries.write()
            .map_err(|_| FsError::Backend("lock poisoned".into()))?;
        // ...
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Common race conditions to avoid:</strong></p>
<ul>
<li><code>create_dir_all</code> called concurrently for same path</li>
<li><code>read</code> during <code>write</code> to same file</li>
<li><code>read_dir</code> while directory is being modified</li>
<li><code>rename</code> with concurrent access to source or destination</li>
</ul>
<h3 id="3-path-resolution---not-your-job"><a class="header" href="#3-path-resolution---not-your-job">3. Path Resolution - NOT Your Job</a></h3>
<p><strong>Backends do NOT handle path resolution.</strong> FileStorage handles:</p>
<ul>
<li>Resolving <code>..</code> and <code>.</code> components</li>
<li>Following symlinks (when <code>set_follow_symlinks(true)</code>)</li>
<li>Normalizing paths (<code>//</code> → <code>/</code>, trailing slashes, etc.)</li>
<li>Walking the virtual directory structure</li>
</ul>
<p>Your backend receives <strong>already-resolved, clean paths</strong>. Just store and retrieve bytes at those paths.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsRead for MyBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Path is already resolved - just use it directly
        let path = path.as_ref();
        self.storage.get(path).ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Exception:</strong> If your backend wraps a real filesystem (like <code>VRootFsBackend</code>), implement <code>SelfResolving</code> to tell FileStorage to skip resolution - the OS handles it.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SelfResolving for VRootFsBackend {}
<span class="boring">}</span></code></pre>
<h3 id="4-error-messages"><a class="header" href="#4-error-messages">4. Error Messages</a></h3>
<p>Include context in errors for debugging:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - no context
Err(FsError::NotFound)

// GOOD - includes path
Err(FsError::NotFound { path: path.to_path_buf() })

// BETTER - includes operation context
Err(FsError::Io {
    path: path.to_path_buf(),
    operation: "read",
    source: io_error,
})
<span class="boring">}</span></code></pre>
<h3 id="5-drop-implementation"><a class="header" href="#5-drop-implementation">5. Drop Implementation</a></h3>
<p>Ensure cleanup happens correctly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for SqliteBackend {
    fn drop(&amp;mut self) {
        // Flush any pending writes
        if let Err(e) = self.sync() {
            eprintln!("Warning: failed to sync on drop: {}", e);
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="6-performance-documentation"><a class="header" href="#6-performance-documentation">6. Performance Documentation</a></h3>
<p>Document the complexity of operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Memory-based virtual filesystem backend.
///
/// # Performance Characteristics
///
/// | Operation | Complexity | Notes |
/// |-----------|------------|-------|
/// | `read` | O(1) | HashMap lookup |
/// | `write` | O(n) | n = data size |
/// | `read_dir` | O(k) | k = entries in directory |
/// | `create_dir_all` | O(d) | d = path depth |
/// | `remove_dir_all` | O(n) | n = total descendants |
///
/// # Thread Safety
///
/// All operations are thread-safe. Uses `RwLock` internally.
/// Multiple concurrent reads are allowed.
/// Writes are exclusive.
pub struct MemoryBackend { ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="testing-requirements"><a class="header" href="#testing-requirements">Testing Requirements</a></h2>
<p>Your backend MUST pass these test categories:</p>
<h3 id="basic-functionality"><a class="header" href="#basic-functionality">Basic Functionality</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_read_write_roundtrip() { ... }

#[test]
fn test_create_dir_and_list() { ... }

#[test]
fn test_remove_file() { ... }
<span class="boring">}</span></code></pre>
<h3 id="edge-cases-no-panics"><a class="header" href="#edge-cases-no-panics">Edge Cases (No Panics)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_read_nonexistent_returns_error() {
    let backend = create_backend();
    assert!(matches!(
        backend.read("/nonexistent"),
        Err(FsError::NotFound { .. })
    ));
}

#[test]
fn test_read_dir_on_file_returns_error() {
    let backend = create_backend();
    backend.write("/file.txt", b"data").unwrap();
    assert!(matches!(
        backend.read_dir("/file.txt"),
        Err(FsError::NotADirectory { .. })
    ));
}

#[test]
fn test_empty_path_returns_error() {
    let backend = create_backend();
    assert!(backend.read("").is_err());
}
<span class="boring">}</span></code></pre>
<h3 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_concurrent_reads() {
    let backend = Arc::new(create_backend_with_data());
    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = backend.clone();
        std::thread::spawn(move || {
            for _ in 0..100 {
                backend.read("/test.txt").unwrap();
            }
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }
}

#[test]
fn test_concurrent_create_dir_all() {
    let backend = Arc::new(RwLock::new(create_backend()));
    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = backend.clone();
        std::thread::spawn(move || {
            let mut backend = backend.write().unwrap();
            // Should not panic or corrupt state
            let _ = backend.create_dir_all("/a/b/c/d");
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
<span class="boring">}</span></code></pre>
<h3 id="path-normalization"><a class="header" href="#path-normalization">Path Normalization</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_path_with_dotdot() {
    let backend = create_backend();
    backend.create_dir_all("/foo/bar").unwrap();
    backend.write("/foo/bar/test.txt", b"data").unwrap();

    // These should all access the same file
    assert_eq!(backend.read("/foo/bar/test.txt").unwrap(), b"data");
    assert_eq!(backend.read("/foo/bar/../bar/test.txt").unwrap(), b"data");
    assert_eq!(backend.read("/foo/./bar/test.txt").unwrap(), b"data");
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="memorybackend-snapshot--restore"><a class="header" href="#memorybackend-snapshot--restore">MemoryBackend Snapshot &amp; Restore</a></h2>
<p><code>MemoryBackend</code> supports cloning its entire state (snapshot) and serializing to bytes for persistence.</p>
<h3 id="core-concept"><a class="header" href="#core-concept">Core Concept</a></h3>
<p><strong>Snapshot = Clone the storage.</strong> That’s it.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MemoryBackend implements Clone
#[derive(Clone)]
pub struct MemoryBackend { ... }

// Snapshot is just .clone()
let snapshot = fs.clone();

// Restore is just assignment
fs = snapshot;
<span class="boring">}</span></code></pre>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MemoryBackend {
    /// Clone the entire filesystem state.
    /// This is a deep copy - modifications to the clone don't affect the original.
    pub fn clone(&amp;self) -&gt; Self { ... }  // via #[derive(Clone)]

    /// Serialize to bytes for persistence/transfer.
    pub fn to_bytes(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;

    /// Deserialize from bytes.
    pub fn from_bytes(data: &amp;[u8]) -&gt; Result&lt;Self, FsError&gt;;

    /// Save to file.
    pub fn save_to(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;

    /// Load from file.
    pub fn load_from(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="usage-1-1"><a class="header" href="#usage-1-1">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = MemoryBackend::new();
fs.write("/data.txt", b"important")?;

// Snapshot = clone
let checkpoint = fs.clone();

// Do risky work...
fs.write("/data.txt", b"corrupted")?;

// Rollback = replace with clone
fs = checkpoint;
assert_eq!(fs.read("/data.txt")?, b"important");
<span class="boring">}</span></code></pre>
<h3 id="persistence"><a class="header" href="#persistence">Persistence</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Save to disk
fs.save_to("state.bin")?;

// Load from disk
let fs = MemoryBackend::load_from("state.bin")?;
<span class="boring">}</span></code></pre>
<h3 id="sqlitebackend"><a class="header" href="#sqlitebackend">SqliteBackend</a></h3>
<p>SQLite already has persistence - the database file IS the snapshot. For explicit snapshots:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SqliteBackend {
    /// Create an in-memory copy of the database.
    pub fn clone_to_memory(&amp;self) -&gt; Result&lt;Self, FsError&gt;;

    /// Backup to another file.
    pub fn backup_to(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-guide"><a class="header" href="#testing-guide">Testing Guide</a></h1>
<p><strong>Comprehensive testing strategy for AnyFS</strong></p>
<hr>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>AnyFS uses a layered testing approach:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>What it tests</th><th>Run with</th></tr>
</thead>
<tbody>
<tr><td>Unit tests</td><td>Individual components</td><td><code>cargo test</code></td></tr>
<tr><td>Conformance tests</td><td>Backend trait compliance</td><td><code>cargo test --features conformance</code></td></tr>
<tr><td>Integration tests</td><td>Full stack behavior</td><td><code>cargo test --test integration</code></td></tr>
<tr><td>Stress tests</td><td>Concurrency &amp; limits</td><td><code>cargo test --release -- --ignored</code></td></tr>
<tr><td>Platform tests</td><td>Cross-platform behavior</td><td>CI matrix</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-backend-conformance-tests"><a class="header" href="#1-backend-conformance-tests">1. Backend Conformance Tests</a></h2>
<p>Every backend must pass the same conformance suite. This ensures backends are interchangeable.</p>
<h3 id="running-conformance-tests"><a class="header" href="#running-conformance-tests">Running Conformance Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_test::{run_conformance_suite, ConformanceLevel};

#[test]
fn memory_backend_conformance() {
    run_conformance_suite(
        MemoryBackend::new(),
        ConformanceLevel::Fs,  // or FsFull, FsFuse, FsPosix
    );
}

#[test]
fn sqlite_backend_conformance() {
    let temp = tempfile::tempdir().unwrap();
    let db_path = temp.path().join("test.db");
    run_conformance_suite(
        SqliteBackend::open(&amp;db_path).unwrap(),
        ConformanceLevel::FsFuse,
    );
}
<span class="boring">}</span></code></pre>
<h3 id="conformance-levels"><a class="header" href="#conformance-levels">Conformance Levels</a></h3>
<pre><code>FsPosix  ──▶ FsHandles, FsLock, FsXattr tests
    │
FsFuse   ──▶ FsInode tests (path_to_inode, lookup, etc.)
    │
FsFull   ──▶ FsLink, FsPermissions, FsSync, FsStats tests
    │
Fs       ──▶ FsRead, FsWrite, FsDir tests (REQUIRED for all)
</code></pre>
<h3 id="core-tests-fs-level"><a class="header" href="#core-tests-fs-level">Core Tests (Fs level)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_write_and_read() {
    let backend = create_backend();

    backend.write("/file.txt", b"hello world").unwrap();
    let content = backend.read("/file.txt").unwrap();

    assert_eq!(content, b"hello world");
}

#[test]
fn test_read_nonexistent_returns_not_found() {
    let backend = create_backend();

    let result = backend.read("/nonexistent.txt");

    assert!(matches!(result, Err(FsError::NotFound { .. })));
}

#[test]
fn test_create_dir_and_list() {
    let backend = create_backend();

    backend.create_dir("/mydir").unwrap();
    backend.write("/mydir/file.txt", b"data").unwrap();

    let entries = backend.read_dir("/mydir").unwrap();
    assert_eq!(entries.len(), 1);
    assert_eq!(entries[0].name, "file.txt");
}

#[test]
fn test_create_dir_all() {
    let backend = create_backend();

    backend.create_dir_all("/a/b/c/d").unwrap();

    assert!(backend.exists("/a/b/c/d").unwrap());
}

#[test]
fn test_remove_file() {
    let backend = create_backend();
    backend.write("/file.txt", b"data").unwrap();

    backend.remove_file("/file.txt").unwrap();

    assert!(!backend.exists("/file.txt").unwrap());
}

#[test]
fn test_remove_dir_all() {
    let backend = create_backend();
    backend.create_dir_all("/a/b/c").unwrap();
    backend.write("/a/b/c/file.txt", b"data").unwrap();

    backend.remove_dir_all("/a").unwrap();

    assert!(!backend.exists("/a").unwrap());
}

#[test]
fn test_rename() {
    let backend = create_backend();
    backend.write("/old.txt", b"data").unwrap();

    backend.rename("/old.txt", "/new.txt").unwrap();

    assert!(!backend.exists("/old.txt").unwrap());
    assert_eq!(backend.read("/new.txt").unwrap(), b"data");
}

#[test]
fn test_copy() {
    let backend = create_backend();
    backend.write("/original.txt", b"data").unwrap();

    backend.copy("/original.txt", "/copy.txt").unwrap();

    assert_eq!(backend.read("/original.txt").unwrap(), b"data");
    assert_eq!(backend.read("/copy.txt").unwrap(), b"data");
}

#[test]
fn test_metadata() {
    let backend = create_backend();
    backend.write("/file.txt", b"hello").unwrap();

    let meta = backend.metadata("/file.txt").unwrap();

    assert_eq!(meta.size, 5);
    assert!(meta.file_type.is_file());
}

#[test]
fn test_append() {
    let backend = create_backend();
    backend.write("/file.txt", b"hello").unwrap();

    backend.append("/file.txt", b" world").unwrap();

    assert_eq!(backend.read("/file.txt").unwrap(), b"hello world");
}

#[test]
fn test_truncate() {
    let backend = create_backend();
    backend.write("/file.txt", b"hello world").unwrap();

    backend.truncate("/file.txt", 5).unwrap();

    assert_eq!(backend.read("/file.txt").unwrap(), b"hello");
}

#[test]
fn test_read_range() {
    let backend = create_backend();
    backend.write("/file.txt", b"hello world").unwrap();

    let partial = backend.read_range("/file.txt", 6, 5).unwrap();

    assert_eq!(partial, b"world");
}
<span class="boring">}</span></code></pre>
<h3 id="extended-tests-fsfull-level"><a class="header" href="#extended-tests-fsfull-level">Extended Tests (FsFull level)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_symlink() {
    let backend = create_backend();
    backend.write("/target.txt", b"data").unwrap();

    backend.symlink("/target.txt", "/link.txt").unwrap();

    // read_link returns the target
    assert_eq!(backend.read_link("/link.txt").unwrap(), Path::new("/target.txt"));

    // reading the symlink follows it
    assert_eq!(backend.read("/link.txt").unwrap(), b"data");
}

#[test]
fn test_hard_link() {
    let backend = create_backend();
    backend.write("/original.txt", b"data").unwrap();

    backend.hard_link("/original.txt", "/hardlink.txt").unwrap();

    // Both point to same data
    assert_eq!(backend.read("/hardlink.txt").unwrap(), b"data");

    // Metadata shows nlink &gt; 1
    let meta = backend.metadata("/original.txt").unwrap();
    assert!(meta.nlink &gt;= 2);
}

#[test]
fn test_symlink_metadata() {
    let backend = create_backend();
    backend.write("/target.txt", b"data").unwrap();
    backend.symlink("/target.txt", "/link.txt").unwrap();

    // symlink_metadata returns metadata of the symlink itself
    let meta = backend.symlink_metadata("/link.txt").unwrap();
    assert!(meta.file_type.is_symlink());
}

#[test]
fn test_set_permissions() {
    let backend = create_backend();
    backend.write("/file.txt", b"data").unwrap();

    backend.set_permissions("/file.txt", Permissions::from_mode(0o644)).unwrap();

    let meta = backend.metadata("/file.txt").unwrap();
    assert_eq!(meta.permissions.mode() &amp; 0o777, 0o644);
}

#[test]
fn test_sync() {
    let backend = create_backend();
    backend.write("/file.txt", b"data").unwrap();

    // Should not error
    backend.sync().unwrap();
    backend.fsync("/file.txt").unwrap();
}

#[test]
fn test_statfs() {
    let backend = create_backend();

    let stats = backend.statfs().unwrap();

    assert!(stats.total_bytes &gt; 0 || stats.total_bytes == 0); // Memory may report 0
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="2-middleware-tests"><a class="header" href="#2-middleware-tests">2. Middleware Tests</a></h2>
<p>Each middleware is tested in isolation and in combination.</p>
<h3 id="quota-tests"><a class="header" href="#quota-tests">Quota Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_quota_blocks_when_exceeded() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(100).build());
    let fs = FileStorage::new(backend);

    let result = fs.write("/big.txt", &amp;[0u8; 200]);

    assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
}

#[test]
fn test_quota_allows_within_limit() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(1000).build());
    let fs = FileStorage::new(backend);

    fs.write("/small.txt", &amp;[0u8; 100]).unwrap();

    assert!(fs.exists("/small.txt").unwrap());
}

#[test]
fn test_quota_tracks_deletes() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(100).build());
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", &amp;[0u8; 50]).unwrap();
    fs.remove_file("/file.txt").unwrap();

    // Should be able to write again after delete
    fs.write("/file2.txt", &amp;[0u8; 50]).unwrap();
}

#[test]
fn test_quota_max_file_size() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_file_size(50).build());
    let fs = FileStorage::new(backend);

    let result = fs.write("/big.txt", &amp;[0u8; 100]);

    assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
}

#[test]
fn test_quota_streaming_write() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(100).build());
    let fs = FileStorage::new(backend);

    let mut writer = fs.open_write("/file.txt").unwrap();
    writer.write_all(&amp;[0u8; 50]).unwrap();
    writer.write_all(&amp;[0u8; 50]).unwrap();
    drop(writer);

    // Next write should fail
    let result = fs.write("/file2.txt", &amp;[0u8; 10]);
    assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="restrictions-tests"><a class="header" href="#restrictions-tests">Restrictions Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_restrictions_blocks_symlinks() {
    let backend = MemoryBackend::new()
        .layer(RestrictionsLayer::builder().deny_symlinks().build());
    let fs = FileStorage::new(backend);

    fs.write("/target.txt", b"data").unwrap();
    let result = fs.symlink("/target.txt", "/link.txt");

    assert!(matches!(result, Err(FsError::OperationDenied { .. })));
}

#[test]
fn test_restrictions_allows_non_blocked() {
    let backend = MemoryBackend::new()
        .layer(RestrictionsLayer::builder().deny_symlinks().build());  // Only block symlinks
    let fs = FileStorage::new(backend);

    // Hard links should still work
    fs.write("/target.txt", b"data").unwrap();
    fs.hard_link("/target.txt", "/link.txt").unwrap();
}

#[test]
fn test_restrictions_blocks_permissions() {
    let backend = MemoryBackend::new()
        .layer(RestrictionsLayer::builder().deny_permissions().build());
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", b"data").unwrap();
    let result = fs.set_permissions("/file.txt", Permissions::from_mode(0o777));

    assert!(matches!(result, Err(FsError::OperationDenied { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="pathfilter-tests"><a class="header" href="#pathfilter-tests">PathFilter Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_pathfilter_allows_matching() {
    let backend = MemoryBackend::new()
        .layer(PathFilterLayer::builder().allow("/workspace/**").build());
    let fs = FileStorage::new(backend);

    fs.create_dir_all("/workspace/project").unwrap();
    fs.write("/workspace/project/file.txt", b"data").unwrap();
}

#[test]
fn test_pathfilter_blocks_non_matching() {
    let backend = MemoryBackend::new()
        .layer(PathFilterLayer::builder().allow("/workspace/**").build());
    let fs = FileStorage::new(backend);

    let result = fs.write("/etc/passwd", b"data");

    assert!(matches!(result, Err(FsError::AccessDenied { .. })));
}

#[test]
fn test_pathfilter_deny_overrides_allow() {
    let backend = MemoryBackend::new()
        .layer(PathFilterLayer::builder()
            .allow("/workspace/**")
            .deny("**/.env")
            .build());
    let fs = FileStorage::new(backend);

    let result = fs.write("/workspace/.env", b"SECRET=xxx");

    assert!(matches!(result, Err(FsError::AccessDenied { .. })));
}

#[test]
fn test_pathfilter_read_dir_filters() {
    let mut inner = MemoryBackend::new();
    inner.write("/workspace/allowed.txt", b"data").unwrap();
    inner.write("/workspace/.env", b"secret").unwrap();

    let backend = inner
        .layer(PathFilterLayer::builder()
            .allow("/workspace/**")
            .deny("**/.env")
            .build());
    let fs = FileStorage::new(backend);

    let entries = fs.read_dir("/workspace").unwrap();

    // .env should be filtered out
    assert_eq!(entries.len(), 1);
    assert_eq!(entries[0].name, "allowed.txt");
}
<span class="boring">}</span></code></pre>
<h3 id="readonly-tests"><a class="header" href="#readonly-tests">ReadOnly Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_readonly_blocks_writes() {
    let mut inner = MemoryBackend::new();
    inner.write("/file.txt", b"original").unwrap();

    let backend = ReadOnly::new(inner);
    let fs = FileStorage::new(backend);

    let result = fs.write("/file.txt", b"modified");
    assert!(matches!(result, Err(FsError::ReadOnly { .. })));

    let result = fs.remove_file("/file.txt");
    assert!(matches!(result, Err(FsError::ReadOnly { .. })));
}

#[test]
fn test_readonly_allows_reads() {
    let mut inner = MemoryBackend::new();
    inner.write("/file.txt", b"data").unwrap();

    let backend = ReadOnly::new(inner);
    let fs = FileStorage::new(backend);

    assert_eq!(fs.read("/file.txt").unwrap(), b"data");
}
<span class="boring">}</span></code></pre>
<h3 id="middleware-composition-tests"><a class="header" href="#middleware-composition-tests">Middleware Composition Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_middleware_composition_order() {
    // Quota inside, Restrictions outside
    // Quota should be checked before restrictions
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(100).build())
        .layer(RestrictionsLayer::builder().deny_symlinks().build());

    let fs = FileStorage::new(backend);

    // Write should hit quota first
    let result = fs.write("/big.txt", &amp;[0u8; 200]);
    assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
}

#[test]
fn test_layer_syntax() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::new().max_total_size(1000))
        .layer(RestrictionsLayer::new().deny_symlinks())
        .layer(TracingLayer::new());

    let fs = FileStorage::new(backend);
    fs.write("/test.txt", b"data").unwrap();
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="3-filestorage-tests"><a class="header" href="#3-filestorage-tests">3. FileStorage Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_filestorage_type_inference() {
    // Type should be inferred
    let fs = FileStorage::new(MemoryBackend::new());
    // No explicit type needed
}

#[test]
fn test_filestorage_marker_types() {
    struct Sandbox;
    struct Production;

    let sandbox: FileStorage&lt;_, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
    let prod: FileStorage&lt;_, Production&gt; = FileStorage::new(MemoryBackend::new());

    fn only_sandbox(_fs: &amp;FileStorage&lt;impl Fs, Sandbox&gt;) {}

    only_sandbox(&amp;sandbox);  // Compiles
    // only_sandbox(&amp;prod);  // Would not compile
}

#[test]
fn test_filestorage_boxed() {
    let fs1 = FileStorage::new(MemoryBackend::new()).boxed();
    let fs2 = FileStorage::new(SqliteBackend::open(":memory:").unwrap()).boxed();

    // Both can be stored in same collection
    let _filesystems: Vec&lt;FileStorage&lt;Box&lt;dyn Fs&gt;&gt;&gt; = vec![fs1, fs2];
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="4-error-handling-tests"><a class="header" href="#4-error-handling-tests">4. Error Handling Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_error_not_found() {
    let fs = FileStorage::new(MemoryBackend::new());

    match fs.read("/nonexistent") {
        Err(FsError::NotFound { path, operation }) =&gt; {
            assert_eq!(path, Path::new("/nonexistent"));
            assert_eq!(operation, "read");
        }
        _ =&gt; panic!("Expected NotFound error"),
    }
}

#[test]
fn test_error_already_exists() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.create_dir("/mydir").unwrap();

    match fs.create_dir("/mydir") {
        Err(FsError::AlreadyExists { path, .. }) =&gt; {
            assert_eq!(path, Path::new("/mydir"));
        }
        _ =&gt; panic!("Expected AlreadyExists error"),
    }
}

#[test]
fn test_error_not_a_directory() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.write("/file.txt", b"data").unwrap();

    match fs.read_dir("/file.txt") {
        Err(FsError::NotADirectory { path }) =&gt; {
            assert_eq!(path, Path::new("/file.txt"));
        }
        _ =&gt; panic!("Expected NotADirectory error"),
    }
}

#[test]
fn test_error_directory_not_empty() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.create_dir("/mydir").unwrap();
    fs.write("/mydir/file.txt", b"data").unwrap();

    match fs.remove_dir("/mydir") {
        Err(FsError::DirectoryNotEmpty { path }) =&gt; {
            assert_eq!(path, Path::new("/mydir"));
        }
        _ =&gt; panic!("Expected DirectoryNotEmpty error"),
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="5-concurrency-tests"><a class="header" href="#5-concurrency-tests">5. Concurrency Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_concurrent_reads() {
    let backend = MemoryBackend::new();
    backend.write("/file.txt", b"data").unwrap();
    let backend = Arc::new(RwLock::new(backend));

    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = Arc::clone(&amp;backend);
        thread::spawn(move || {
            let guard = backend.read().unwrap();
            guard.read("/file.txt").unwrap()
        })
    }).collect();

    for handle in handles {
        assert_eq!(handle.join().unwrap(), b"data");
    }
}

#[test]
fn test_concurrent_create_dir_all() {
    let backend = Arc::new(Mutex::new(MemoryBackend::new()));

    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = Arc::clone(&amp;backend);
        thread::spawn(move || {
            let mut guard = backend.lock().unwrap();
            // Multiple threads creating same path should not race
            guard.create_dir_all("/a/b/c/d").unwrap();
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }

    assert!(backend.lock().unwrap().exists("/a/b/c/d").unwrap());
}

#[test]
#[ignore] // Run with: cargo test --release -- --ignored
fn stress_test_concurrent_operations() {
    let backend = Arc::new(Mutex::new(MemoryBackend::new()));

    let handles: Vec&lt;_&gt; = (0..100).map(|i| {
        let backend = Arc::clone(&amp;backend);
        thread::spawn(move || {
            for j in 0..100 {
                let path = format!("/thread_{}/file_{}.txt", i, j);
                let mut guard = backend.lock().unwrap();
                guard.create_dir_all(&amp;format!("/thread_{}", i)).ok();
                guard.write(&amp;path, b"data").unwrap();
                drop(guard);

                let guard = backend.lock().unwrap();
                let _ = guard.read(&amp;path);
            }
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="6-path-edge-case-tests"><a class="header" href="#6-path-edge-case-tests">6. Path Edge Case Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_path_normalization() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/a/b/../c/file.txt", b"data").unwrap();

    // Should be accessible via normalized path
    assert_eq!(fs.read("/a/c/file.txt").unwrap(), b"data");
}

#[test]
fn test_double_slashes() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("//a//b//file.txt", b"data").unwrap();

    assert_eq!(fs.read("/a/b/file.txt").unwrap(), b"data");
}

#[test]
fn test_root_path() {
    let fs = FileStorage::new(MemoryBackend::new());

    let entries = fs.read_dir("/").unwrap();
    assert!(entries.is_empty());
}

#[test]
fn test_empty_path_returns_error() {
    let fs = FileStorage::new(MemoryBackend::new());

    let result = fs.read("");
    assert!(result.is_err());
}

#[test]
fn test_unicode_paths() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/文件/データ.txt", b"data").unwrap();

    assert_eq!(fs.read("/文件/データ.txt").unwrap(), b"data");
}

#[test]
fn test_paths_with_spaces() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/my folder/my file.txt", b"data").unwrap();

    assert_eq!(fs.read("/my folder/my file.txt").unwrap(), b"data");
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="7-no-panic-guarantee-tests"><a class="header" href="#7-no-panic-guarantee-tests">7. No-Panic Guarantee Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn no_panic_missing_file() {
    let fs = FileStorage::new(MemoryBackend::new());
    let _ = fs.read("/missing");  // Should return Err, not panic
}

#[test]
fn no_panic_missing_parent() {
    let fs = FileStorage::new(MemoryBackend::new());
    let _ = fs.write("/missing/parent/file.txt", b"data");  // Should return Err
}

#[test]
fn no_panic_read_dir_on_file() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.write("/file.txt", b"data").unwrap();
    let _ = fs.read_dir("/file.txt");  // Should return Err, not panic
}

#[test]
fn no_panic_remove_nonempty_dir() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.create_dir("/dir").unwrap();
    fs.write("/dir/file.txt", b"data").unwrap();
    let _ = fs.remove_dir("/dir");  // Should return Err, not panic
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="8-symlink-security-tests"><a class="header" href="#8-symlink-security-tests">8. Symlink Security Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Virtual backend symlink following control
#[test]
fn test_virtual_backend_follow_symlinks_enabled() {
    let backend = MemoryBackend::new();
    backend.write("/target.txt", b"secret").unwrap();
    backend.symlink("/target.txt", "/link.txt").unwrap();

    // Default: following enabled
    assert_eq!(backend.read("/link.txt").unwrap(), b"secret");
}

#[test]
fn test_virtual_backend_follow_symlinks_disabled() {
    let backend = MemoryBackend::new();
    backend.set_follow_symlinks(false);
    backend.write("/target.txt", b"secret").unwrap();
    backend.symlink("/target.txt", "/link.txt").unwrap();

    // Reading symlink should fail or return symlink data
    let result = backend.read("/link.txt");
    assert!(matches!(result, Err(FsError::IsSymlink { .. })));
}

#[test]
fn test_symlink_chain_resolution() {
    let backend = MemoryBackend::new();
    backend.write("/target.txt", b"data").unwrap();
    backend.symlink("/target.txt", "/link1.txt").unwrap();
    backend.symlink("/link1.txt", "/link2.txt").unwrap();

    // Should follow chain
    assert_eq!(backend.read("/link2.txt").unwrap(), b"data");
}

#[test]
fn test_symlink_loop_detection() {
    let backend = MemoryBackend::new();
    backend.symlink("/link2.txt", "/link1.txt").unwrap();
    backend.symlink("/link1.txt", "/link2.txt").unwrap();

    let result = backend.read("/link1.txt");
    assert!(matches!(result, Err(FsError::SymlinkLoop { .. })));
}

#[test]
fn test_virtual_symlink_cannot_escape() {
    let backend = MemoryBackend::new();
    // Create a symlink pointing "outside" - but in virtual backend, paths are just keys
    backend.symlink("../../../etc/passwd", "/link.txt").unwrap();

    // Reading should fail (target doesn't exist), not read real /etc/passwd
    let result = backend.read("/link.txt");
    assert!(matches!(result, Err(FsError::NotFound { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="vrootfsbackend-containment-tests"><a class="header" href="#vrootfsbackend-containment-tests">VRootFsBackend Containment Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_vroot_prevents_path_traversal() {
    let temp = tempfile::tempdir().unwrap();
    let backend = VRootFsBackend::new(temp.path()).unwrap();
    let fs = FileStorage::new(backend);

    // Attempt to escape via ..
    let result = fs.read("/../../../etc/passwd");
    assert!(matches!(result, Err(FsError::AccessDenied { .. })));
}

#[test]
fn test_vroot_prevents_symlink_escape() {
    let temp = tempfile::tempdir().unwrap();
    std::fs::write(temp.path().join("file.txt"), b"data").unwrap();

    // Create symlink pointing outside the jail
    #[cfg(unix)]
    std::os::unix::fs::symlink("/etc/passwd", temp.path().join("escape")).unwrap();

    let backend = VRootFsBackend::new(temp.path()).unwrap();
    let fs = FileStorage::new(backend);

    // Reading should be blocked by strict-path
    let result = fs.read("/escape");
    assert!(matches!(result, Err(FsError::AccessDenied { .. })));
}

#[test]
fn test_vroot_allows_internal_symlinks() {
    let temp = tempfile::tempdir().unwrap();
    std::fs::write(temp.path().join("target.txt"), b"data").unwrap();

    #[cfg(unix)]
    std::os::unix::fs::symlink("target.txt", temp.path().join("link.txt")).unwrap();

    let backend = VRootFsBackend::new(temp.path()).unwrap();
    let fs = FileStorage::new(backend);

    // Internal symlinks should work
    assert_eq!(fs.read("/link.txt").unwrap(), b"data");
}

#[test]
fn test_vroot_canonicalizes_paths() {
    let temp = tempfile::tempdir().unwrap();
    let backend = VRootFsBackend::new(temp.path()).unwrap();
    let fs = FileStorage::new(backend);

    fs.create_dir("/a").unwrap();
    fs.write("/a/file.txt", b"data").unwrap();

    // Access via normalized path
    assert_eq!(fs.read("/a/../a/./file.txt").unwrap(), b"data");
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="9-ratelimit-middleware-tests"><a class="header" href="#9-ratelimit-middleware-tests">9. RateLimit Middleware Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ratelimit_allows_within_limit() {
    let backend = MemoryBackend::new()
        .layer(RateLimitLayer::builder().max_ops(10).per_second().build());
    let fs = FileStorage::new(backend);

    // Should succeed within limit
    for i in 0..5 {
        fs.write(&amp;format!("/file{}.txt", i), b"data").unwrap();
    }
}

#[test]
fn test_ratelimit_blocks_when_exceeded() {
    let backend = MemoryBackend::new()
        .layer(RateLimitLayer::builder().max_ops(3).per_second().build());
    let fs = FileStorage::new(backend);

    fs.write("/file1.txt", b"data").unwrap();
    fs.write("/file2.txt", b"data").unwrap();
    fs.write("/file3.txt", b"data").unwrap();

    let result = fs.write("/file4.txt", b"data");
    assert!(matches!(result, Err(FsError::RateLimitExceeded { .. })));
}

#[test]
fn test_ratelimit_resets_after_window() {
    let backend = MemoryBackend::new()
        .layer(RateLimitLayer::builder().max_ops(2).per(Duration::from_millis(100)).build());
    let fs = FileStorage::new(backend);

    fs.write("/file1.txt", b"data").unwrap();
    fs.write("/file2.txt", b"data").unwrap();

    // Wait for window to reset
    std::thread::sleep(Duration::from_millis(150));

    // Should succeed again
    fs.write("/file3.txt", b"data").unwrap();
}

#[test]
fn test_ratelimit_counts_all_operations() {
    let backend = MemoryBackend::new()
        .layer(RateLimitLayer::builder().max_ops(3).per_second().build());
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", b"data").unwrap();  // 1
    let _ = fs.read("/file.txt");              // 2
    let _ = fs.exists("/file.txt");            // 3

    let result = fs.metadata("/file.txt");
    assert!(matches!(result, Err(FsError::RateLimitExceeded { .. })));
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="10-tracing-middleware-tests"><a class="header" href="#10-tracing-middleware-tests">10. Tracing Middleware Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

#[derive(Default)]
struct TestLogger {
    logs: Arc&lt;Mutex&lt;Vec&lt;String&gt;&gt;&gt;,
}

impl TestLogger {
    fn entries(&amp;self) -&gt; Vec&lt;String&gt; {
        self.logs.lock().unwrap().clone()
    }
}

#[test]
fn test_tracing_logs_operations() {
    let logger = TestLogger::default();
    let logs = Arc::clone(&amp;logger.logs);

    let backend = MemoryBackend::new()
        .layer(TracingLayer::new()
            .with_logger(move |op| {
                logs.lock().unwrap().push(op.to_string());
            }));
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", b"data").unwrap();
    fs.read("/file.txt").unwrap();

    let entries = logger.entries();
    assert!(entries.iter().any(|e| e.contains("write")));
    assert!(entries.iter().any(|e| e.contains("read")));
}

#[test]
fn test_tracing_includes_path() {
    let logger = TestLogger::default();
    let logs = Arc::clone(&amp;logger.logs);

    let backend = MemoryBackend::new()
        .layer(TracingLayer::new()
            .with_logger(move |op| {
                logs.lock().unwrap().push(op.to_string());
            }));
    let fs = FileStorage::new(backend);

    fs.write("/important/secret.txt", b"data").unwrap();

    let entries = logger.entries();
    assert!(entries.iter().any(|e| e.contains("/important/secret.txt")));
}

#[test]
fn test_tracing_logs_errors() {
    let logger = TestLogger::default();
    let logs = Arc::clone(&amp;logger.logs);

    let backend = MemoryBackend::new()
        .layer(TracingLayer::new()
            .with_logger(move |op| {
                logs.lock().unwrap().push(op.to_string());
            }));
    let fs = FileStorage::new(backend);

    let _ = fs.read("/nonexistent.txt");

    let entries = logger.entries();
    assert!(entries.iter().any(|e| e.contains("NotFound") || e.contains("error")));
}

#[test]
fn test_tracing_with_span_context() {
    use tracing::{info_span, Instrument};

    let backend = MemoryBackend::new().layer(TracingLayer::new());
    let fs = FileStorage::new(backend);

    async {
        fs.write("/async.txt", b"data").unwrap();
    }
    .instrument(info_span!("test_operation"))
    .now_or_never();
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="11-backend-interchangeability-tests"><a class="header" href="#11-backend-interchangeability-tests">11. Backend Interchangeability Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Ensure all backends can be used interchangeably
fn generic_filesystem_test&lt;B: Fs&gt;(mut backend: B) {
    backend.create_dir("/test").unwrap();
    backend.write("/test/file.txt", b"hello").unwrap();
    assert_eq!(backend.read("/test/file.txt").unwrap(), b"hello");
    backend.remove_dir_all("/test").unwrap();
    assert!(!backend.exists("/test").unwrap());
}

#[test]
fn test_memory_backend_interchangeable() {
    generic_filesystem_test(MemoryBackend::new());
}

#[test]
fn test_sqlite_backend_interchangeable() {
    let (backend, _temp) = temp_sqlite_backend();
    generic_filesystem_test(backend);
}

#[test]
fn test_vroot_backend_interchangeable() {
    let temp = tempfile::tempdir().unwrap();
    let backend = VRootFsBackend::new(temp.path()).unwrap();
    generic_filesystem_test(backend);
}

#[test]
fn test_middleware_stack_interchangeable() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder()
            .max_total_size(1024 * 1024)
            .build())
        .layer(TracingLayer::new());
    generic_filesystem_test(backend);
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="12-property-based-tests"><a class="header" href="#12-property-based-tests">12. Property-Based Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn prop_write_read_roundtrip(data: Vec&lt;u8&gt;) {
        let backend = MemoryBackend::new();
        backend.write("/file.bin", &amp;data).unwrap();
        let read_data = backend.read("/file.bin").unwrap();
        prop_assert_eq!(data, read_data);
    }

    #[test]
    fn prop_path_normalization_idempotent(path in "[a-z/]{1,50}") {
        let backend = MemoryBackend::new();
        if let Ok(()) = backend.create_dir_all(&amp;path) {
            // Creating again should either succeed or return AlreadyExists
            let result = backend.create_dir_all(&amp;path);
            prop_assert!(result.is_ok() || matches!(result, Err(FsError::AlreadyExists { .. })));
        }
    }

    #[test]
    fn prop_quota_never_exceeds_limit(
        file_count in 1..10usize,
        file_sizes in prop::collection::vec(1..100usize, 1..10)
    ) {
        let limit = 500usize;
        let backend = MemoryBackend::new()
            .layer(QuotaLayer::builder().max_total_size(limit as u64).build());
        let fs = FileStorage::new(backend);

        let mut total_written = 0usize;
        for (i, size) in file_sizes.into_iter().take(file_count).enumerate() {
            let data = vec![0u8; size];
            match fs.write(&amp;format!("/file{}.txt", i), &amp;data) {
                Ok(()) =&gt; total_written += size,
                Err(FsError::QuotaExceeded { .. }) =&gt; break,
                Err(e) =&gt; panic!("Unexpected error: {:?}", e),
            }
        }
        prop_assert!(total_written &lt;= limit);
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="13-snapshot--restore-tests"><a class="header" href="#13-snapshot--restore-tests">13. Snapshot &amp; Restore Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MemoryBackend implements Clone - that's the snapshot mechanism
#[test]
fn test_clone_creates_independent_copy() {
    let mut original = MemoryBackend::new();
    original.write("/file.txt", b"original").unwrap();

    // Clone = snapshot
    let mut snapshot = original.clone();

    // Modify original
    original.write("/file.txt", b"modified").unwrap();
    original.write("/new.txt", b"new").unwrap();

    // Snapshot is unchanged
    assert_eq!(snapshot.read("/file.txt").unwrap(), b"original");
    assert!(!snapshot.exists("/new.txt").unwrap());
}

#[test]
fn test_checkpoint_and_rollback() {
    let fs = MemoryBackend::new();
    fs.write("/important.txt", b"original").unwrap();

    // Checkpoint = clone
    let checkpoint = fs.clone();

    // Do risky work
    fs.write("/important.txt", b"corrupted").unwrap();

    // Rollback = replace with checkpoint
    fs = checkpoint;
    assert_eq!(fs.read("/important.txt").unwrap(), b"original");
}

#[test]
fn test_persistence_roundtrip() {
    let temp = tempfile::tempdir().unwrap();
    let path = temp.path().join("state.bin");

    let fs = MemoryBackend::new();
    fs.write("/data.txt", b"persisted").unwrap();

    // Save
    fs.save_to(&amp;path).unwrap();

    // Load
    let restored = MemoryBackend::load_from(&amp;path).unwrap();
    assert_eq!(restored.read("/data.txt").unwrap(), b"persisted");
}

#[test]
fn test_to_bytes_from_bytes() {
    let fs = MemoryBackend::new();
    fs.create_dir_all("/a/b/c").unwrap();
    fs.write("/a/b/c/file.txt", b"nested").unwrap();

    let bytes = fs.to_bytes().unwrap();
    let restored = MemoryBackend::from_bytes(&amp;bytes).unwrap();

    assert_eq!(restored.read("/a/b/c/file.txt").unwrap(), b"nested");
}

#[test]
fn test_from_bytes_invalid_data() {
    let result = MemoryBackend::from_bytes(b"garbage");
    assert!(result.is_err());
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="14-running-tests"><a class="header" href="#14-running-tests">14. Running Tests</a></h2>
<pre><code class="language-bash"># All tests
cargo test

# Specific backend conformance
cargo test memory_backend_conformance
cargo test sqlite_backend_conformance

# Middleware tests
cargo test quota
cargo test restrictions
cargo test pathfilter

# Stress tests (release mode)
cargo test --release -- --ignored

# With coverage
cargo tarpaulin --out Html

# Cross-platform (CI)
cargo test --target x86_64-unknown-linux-gnu
cargo test --target x86_64-pc-windows-msvc
cargo test --target x86_64-apple-darwin

# WASM
cargo test --target wasm32-unknown-unknown
</code></pre>
<hr>
<h2 id="9-test-utilities"><a class="header" href="#9-test-utilities">9. Test Utilities</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-test crate

/// Create a temporary backend for testing
pub fn temp_sqlite_backend() -&gt; (SqliteBackend, tempfile::TempDir) {
    let temp = tempfile::tempdir().unwrap();
    let db_path = temp.path().join("test.db");
    let backend = SqliteBackend::open(&amp;db_path).unwrap();
    (backend, temp)
}

/// Run a test against multiple backends
pub fn test_all_backends&lt;F&gt;(test: F)
where
    F: Fn(&amp;mut dyn Fs),
{
    // Memory
    let backend = MemoryBackend::new();
    test(&amp;mut backend);

    // SQLite
    let (mut backend, _temp) = temp_sqlite_backend();
    test(&amp;mut backend);
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lessons-from-similar-projects"><a class="header" href="#lessons-from-similar-projects">Lessons from Similar Projects</a></h1>
<p><strong>Analysis of issues from <code>vfs</code> and <code>agentfs</code> to inform AnyFS design.</strong></p>
<p>This chapter documents problems encountered by similar projects and how AnyFS addresses them. These lessons are incorporated into our <a href="#implementation-plan">Implementation Plan</a> and <a href="#backend-implementers-guide">Backend Guide</a>.</p>
<hr>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Priority</th><th>Issue</th><th>AnyFS Response</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>Panics instead of errors</td><td>No-panic policy, always return <code>Result</code></td></tr>
<tr><td>2</td><td>Thread safety problems</td><td>Concurrent stress tests required</td></tr>
<tr><td>3</td><td>Inconsistent path handling</td><td>Normalize in one place, test edge cases</td></tr>
<tr><td>4</td><td>Poor error ergonomics</td><td><code>FsError</code> with context fields</td></tr>
<tr><td>5</td><td>Missing documentation</td><td>Performance &amp; thread safety docs required</td></tr>
<tr><td>6</td><td>Platform issues</td><td>Cross-platform CI pipeline</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-thread-safety-issues"><a class="header" href="#1-thread-safety-issues">1. Thread Safety Issues</a></h2>
<h3 id="what-happened"><a class="header" href="#what-happened">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/72">#72</a></td><td>RwLock panic in production</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/47">#47</a></td><td><code>create_dir_all</code> races with itself</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Insufficient synchronization in concurrent access patterns.</p>
<h3 id="anyfs-response"><a class="header" href="#anyfs-response">AnyFS Response</a></h3>
<ul>
<li><strong>Test concurrent operations explicitly</strong> - stress test with multiple threads</li>
<li><strong>Document thread safety guarantees</strong> per backend</li>
<li><strong><code>Fs: Send</code></strong> bound is intentional</li>
<li><strong><code>MemoryBackend</code> uses <code>Arc&lt;RwLock&lt;...&gt;&gt;</code></strong> for interior mutability</li>
</ul>
<p><strong>Required tests:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_concurrent_create_dir_all() {
    let backend = Arc::new(RwLock::new(create_backend()));
    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = backend.clone();
        std::thread::spawn(move || {
            let mut backend = backend.write().unwrap();
            let _ = backend.create_dir_all("/a/b/c/d");
        })
    }).collect();
    for handle in handles {
        handle.join().unwrap();
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="2-panics-instead-of-errors"><a class="header" href="#2-panics-instead-of-errors">2. Panics Instead of Errors</a></h2>
<h3 id="what-happened-1"><a class="header" href="#what-happened-1">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/8">#8</a></td><td>AltrootFS panics when file doesn’t exist</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/23">#23</a></td><td>Unhandled edge cases cause panics</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/68">#68</a></td><td>MemoryFS panics in WebAssembly</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Using <code>.unwrap()</code> or <code>.expect()</code> on fallible operations.</p>
<h3 id="anyfs-response-1"><a class="header" href="#anyfs-response-1">AnyFS Response</a></h3>
<p><strong>No-panic policy:</strong> Never use <code>.unwrap()</code> or <code>.expect()</code> in library code.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - will panic
let entry = self.entries.get(&amp;path).unwrap();

// GOOD - returns error
let entry = self.entries.get(&amp;path)
    .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;
<span class="boring">}</span></code></pre>
<p><strong>Edge cases that must return errors (not panic):</strong></p>
<ul>
<li>File doesn’t exist</li>
<li>Directory doesn’t exist</li>
<li>Path is empty string</li>
<li>Invalid UTF-8 in path</li>
<li>Parent directory missing</li>
<li>Type mismatch (file vs directory)</li>
<li>Concurrent access conflicts</li>
</ul>
<hr>
<h2 id="3-path-handling-inconsistencies"><a class="header" href="#3-path-handling-inconsistencies">3. Path Handling Inconsistencies</a></h2>
<h3 id="what-happened-2"><a class="header" href="#what-happened-2">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/24">#24</a></td><td>Inconsistent path definition across backends</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/42">#42</a></td><td>Path join doesn’t behave Unix-like</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/22">#22</a></td><td>Non-UTF-8 path support questions</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Each backend implemented path handling differently.</p>
<h3 id="anyfs-response-2"><a class="header" href="#anyfs-response-2">AnyFS Response</a></h3>
<ul>
<li><strong>Normalize paths in ONE place</strong> (FileStorage or dedicated normalizer)</li>
<li><strong>Consistent semantics:</strong> always absolute, always <code>/</code> separator</li>
<li><strong>Use <code>impl AsRef&lt;Path&gt;</code></strong> but normalize internally</li>
</ul>
<p><strong>Required conformance tests:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Expected Output</th></tr>
</thead>
<tbody>
<tr><td><code>/foo/../bar</code></td><td><code>/bar</code></td></tr>
<tr><td><code>/foo/./bar</code></td><td><code>/foo/bar</code></td></tr>
<tr><td><code>//double//slash</code></td><td><code>/double/slash</code></td></tr>
<tr><td><code>/</code></td><td><code>/</code></td></tr>
<tr><td>`` (empty)</td><td>Error</td></tr>
<tr><td><code>/foo/bar/</code></td><td><code>/foo/bar</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="4-static-lifetime-requirements"><a class="header" href="#4-static-lifetime-requirements">4. Static Lifetime Requirements</a></h2>
<h3 id="what-happened-3"><a class="header" href="#what-happened-3">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/66">#66</a></td><td>Why does filesystem require <code>'static</code>?</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Design decision that confused users and limited flexibility.</p>
<h3 id="anyfs-response-3"><a class="header" href="#anyfs-response-3">AnyFS Response</a></h3>
<ul>
<li><strong>Avoid <code>'static</code> bounds</strong> unless necessary</li>
<li><strong>Our design:</strong> <code>Fs: Send</code> (not <code>'static</code>)</li>
<li><strong>Document why bounds exist</strong> when needed</li>
</ul>
<hr>
<h2 id="5-missing-symlink-support"><a class="header" href="#5-missing-symlink-support">5. Missing Symlink Support</a></h2>
<h3 id="what-happened-4"><a class="header" href="#what-happened-4">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/81">#81</a></td><td>Symlink support missing entirely</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Symlinks are complex and were deferred indefinitely.</p>
<h3 id="anyfs-response-4"><a class="header" href="#anyfs-response-4">AnyFS Response</a></h3>
<ul>
<li><strong>Symlinks are opt-in</strong> via <code>Restrictions</code> middleware</li>
<li><strong>Default deny is correct</strong> - most use cases don’t need symlinks</li>
<li><strong>When enabled, bound resolution depth</strong> (default: 40 hops)</li>
<li><strong><code>strict-path</code> prevents symlink escapes</strong> in <code>VRootFsBackend</code></li>
</ul>
<hr>
<h2 id="6-error-type-ergonomics"><a class="header" href="#6-error-type-ergonomics">6. Error Type Ergonomics</a></h2>
<h3 id="what-happened-5"><a class="header" href="#what-happened-5">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/33">#33</a></td><td>Error type hard to match programmatically</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Error enum wasn’t designed for pattern matching.</p>
<h3 id="anyfs-response-5"><a class="header" href="#anyfs-response-5">AnyFS Response</a></h3>
<p><code>FsError</code> includes context and is easy to match:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum FsError {
    #[error("{operation}: not found: {path}")]
    NotFound { path: PathBuf, operation: &amp;'static str },

    #[error("{operation}: already exists: {path}")]
    AlreadyExists { path: PathBuf, operation: &amp;'static str },

    #[error("quota exceeded: limit {limit}, attempted {attempted}")]
    QuotaExceeded { limit: u64, attempted: u64 },

    #[error("feature not enabled: {feature}")]
    FeatureNotEnabled { feature: &amp;'static str },

    #[error("permission denied: {path} ({operation})")]
    PermissionDenied { path: PathBuf, operation: &amp;'static str },

    // ...
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="7-seek--write-operations"><a class="header" href="#7-seek--write-operations">7. Seek + Write Operations</a></h2>
<h3 id="what-happened-6"><a class="header" href="#what-happened-6">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/35">#35</a></td><td>Missing file positioning features</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Initial API was too simple.</p>
<h3 id="anyfs-response-6"><a class="header" href="#anyfs-response-6">AnyFS Response</a></h3>
<ul>
<li><strong>Streaming I/O:</strong> <code>open_read</code>/<code>open_write</code> return <code>Box&lt;dyn Read/Write + Send&gt;</code></li>
<li><strong>Seek support varies by backend</strong> - document which support it</li>
<li><strong>Consider future:</strong> <code>open_read_seek</code> variant or capability query</li>
</ul>
<hr>
<h2 id="8-read-only-filesystem-request"><a class="header" href="#8-read-only-filesystem-request">8. Read-Only Filesystem Request</a></h2>
<h3 id="what-happened-7"><a class="header" href="#what-happened-7">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/58">#58</a></td><td>Request for immutable filesystem</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> No built-in way to enforce read-only access.</p>
<h3 id="anyfs-response-7"><a class="header" href="#anyfs-response-7">AnyFS Response</a></h3>
<p><strong>Already solved:</strong> <code>ReadOnly&lt;B&gt;</code> middleware blocks all writes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let readonly_fs = FileStorage::new(
    ReadOnly::new(SqliteBackend::open("archive.db")?)
);
// All write operations return FsError::ReadOnly
<span class="boring">}</span></code></pre>
<p>This validates our middleware approach.</p>
<hr>
<h2 id="9-performance-issues"><a class="header" href="#9-performance-issues">9. Performance Issues</a></h2>
<h3 id="what-happened-8"><a class="header" href="#what-happened-8">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/130">#130</a></td><td>File deletion is slow</td></tr>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/135">#135</a></td><td>Benchmark hangs</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> SQLite operations not optimized, FUSE overhead.</p>
<h3 id="anyfs-response-8"><a class="header" href="#anyfs-response-8">AnyFS Response</a></h3>
<ul>
<li><strong>Batch operations</strong> where possible in <code>SqliteBackend</code></li>
<li><strong>Use transactions</strong> for multi-file operations</li>
<li><strong>Document performance characteristics</strong> per backend</li>
<li><strong>Avoid FUSE</strong> - we’re a library, not a mount</li>
</ul>
<p><strong>Documentation requirement:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Performance Characteristics
///
/// | Operation | Complexity | Notes |
/// |-----------|------------|-------|
/// | `read` | O(1) | Single DB query |
/// | `write` | O(n) | n = data size |
/// | `remove_dir_all` | O(n) | n = descendants |
pub struct SqliteBackend { ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="10-signal-handling--shutdown"><a class="header" href="#10-signal-handling--shutdown">10. Signal Handling / Shutdown</a></h2>
<h3 id="what-happened-9"><a class="header" href="#what-happened-9">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/129">#129</a></td><td>Doesn’t shutdown on SIGTERM</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> FUSE mount cleanup issues.</p>
<h3 id="anyfs-response-9"><a class="header" href="#anyfs-response-9">AnyFS Response</a></h3>
<ul>
<li><strong>Not our problem</strong> - we’re a library, not a daemon</li>
<li><strong>Ensure <code>Drop</code> implementations clean up properly</strong></li>
<li><strong><code>SqliteBackend</code> flushes on drop</strong></li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for SqliteBackend {
    fn drop(&amp;mut self) {
        if let Err(e) = self.sync() {
            eprintln!("Warning: failed to sync on drop: {}", e);
        }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="11-platform-compatibility"><a class="header" href="#11-platform-compatibility">11. Platform Compatibility</a></h2>
<h3 id="what-happened-10"><a class="header" href="#what-happened-10">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/132">#132</a></td><td>FUSE-T support (macOS)</td></tr>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/138">#138</a></td><td>virtio-fs support</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Platform-specific FUSE variants.</p>
<h3 id="anyfs-response-10"><a class="header" href="#anyfs-response-10">AnyFS Response</a></h3>
<ul>
<li><strong>We avoid this</strong> - no FUSE, pure library</li>
<li><strong>Cross-platform by design</strong> - Memory and SQLite work everywhere</li>
<li><strong><code>VRootFsBackend</code> uses <code>strict-path</code></strong> which handles Windows/Unix</li>
</ul>
<p><strong>CI requirement:</strong></p>
<pre><code class="language-yaml">strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
</code></pre>
<hr>
<h2 id="12-multiple-sessions--concurrent-access"><a class="header" href="#12-multiple-sessions--concurrent-access">12. Multiple Sessions / Concurrent Access</a></h2>
<h3 id="what-happened-11"><a class="header" href="#what-happened-11">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/126">#126</a></td><td>Can’t have multiple sessions on same filesystem</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Locking/concurrency design.</p>
<h3 id="anyfs-response-11"><a class="header" href="#anyfs-response-11">AnyFS Response</a></h3>
<ul>
<li><strong><code>SqliteBackend</code> uses WAL mode</strong> for concurrent readers</li>
<li><strong>Document concurrency model</strong> per backend</li>
<li><strong><code>MemoryBackend</code> uses <code>Arc&lt;RwLock&lt;...&gt;&gt;</code></strong> for sharing</li>
</ul>
<hr>
<h2 id="issues-we-already-avoid"><a class="header" href="#issues-we-already-avoid">Issues We Already Avoid</a></h2>
<p>Our design decisions already prevent these problems:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Problem in Others</th><th>AnyFS Solution</th></tr>
</thead>
<tbody>
<tr><td>No middleware pattern</td><td>Tower-style composable middleware</td></tr>
<tr><td>No quota enforcement</td><td><code>Quota&lt;B&gt;</code> middleware</td></tr>
<tr><td>No read-only mode</td><td><code>ReadOnly&lt;B&gt;</code> middleware</td></tr>
<tr><td>Symlink complexity</td><td><code>Restrictions&lt;B&gt;</code> (opt-in)</td></tr>
<tr><td>Path escape via symlinks</td><td><code>strict-path</code> canonicalization</td></tr>
<tr><td>FUSE complexity</td><td>Pure library, no mount</td></tr>
<tr><td>SQLite-only</td><td>Multiple backends</td></tr>
<tr><td>Monolithic features</td><td>Composable middleware</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://github.com/manuel-woelker/rust-vfs/issues">rust-vfs Issues</a></li>
<li><a href="https://github.com/tursodatabase/agentfs/issues">agentfs Issues</a></li>
<li><a href="#implementation-plan">Implementation Plan</a> - incorporates these lessons</li>
<li><a href="#backend-implementers-guide">Backend Guide</a> - implementation requirements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="open-questions--future-considerations"><a class="header" href="#open-questions--future-considerations">Open Questions &amp; Future Considerations</a></h1>
<p><strong>Status:</strong> Under Discussion
<strong>Last Updated:</strong> 2025-12-28</p>
<hr>
<p>This document captures open questions and design considerations that may influence future development of AnyFS.</p>
<blockquote>
<p><strong>Note:</strong> Many items originally in this document have been resolved and implemented. See the Architecture Decision Records for final decisions.</p>
</blockquote>
<hr>
<h2 id="symlink-security-following-vs-creating"><a class="header" href="#symlink-security-following-vs-creating">Symlink Security: Following vs Creating</a></h2>
<p><strong>IMPORTANT:</strong> The current discussion about symlinks has been fundamentally reconsidered.</p>
<h3 id="the-correct-understanding"><a class="header" href="#the-correct-understanding">The Correct Understanding</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Action</th><th>Security Concern?</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td><strong>Creating symlinks</strong></td><td>No</td><td>Symlinks are just data. Creating them is harmless.</td></tr>
<tr><td><strong>Following symlinks</strong></td><td><strong>YES</strong></td><td>Following a symlink can escape containment.</td></tr>
</tbody>
</table>
</div>
<p><strong>Example attack:</strong></p>
<pre><code>/sandbox/escape -&gt; /etc/passwd

If we follow the symlink:
  read("/sandbox/escape") → reads /etc/passwd → JAIL ESCAPE
</code></pre>
<p>The security feature is <strong>controlling symlink resolution</strong>, not symlink creation.</p>
<h3 id="virtual-vs-real-backends-a-fundamental-difference"><a class="header" href="#virtual-vs-real-backends-a-fundamental-difference">Virtual vs Real Backends: A Fundamental Difference</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Who Controls Symlink Resolution?</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td><strong>We do</strong> (symlinks are stored data, we choose whether to follow)</td></tr>
<tr><td><code>SqliteBackend</code></td><td><strong>We do</strong> (symlinks are stored data, we choose whether to follow)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td><strong>The OS does</strong> (we call <code>std::fs::read</code>, OS follows symlinks)</td></tr>
</tbody>
</table>
</div>
<p><strong>This is the core problem:</strong> For virtual backends, we have full control. For real filesystem backends, the OS controls symlink resolution and we cannot easily change that.</p>
<h3 id="options-analysis"><a class="header" href="#options-analysis">Options Analysis</a></h3>
<h4 id="option-1-custom-path-resolution-for-vrootfsbackend"><a class="header" href="#option-1-custom-path-resolution-for-vrootfsbackend">Option 1: Custom Path Resolution for VRootFsBackend</a></h4>
<p>Walk each path component manually using <code>lstat</code> (symlink_metadata):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn resolve_no_follow(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
    let mut current = self.root.clone();
    for component in path.components() {
        current = current.join(component);
        let meta = std::fs::symlink_metadata(&amp;current)?;
        if meta.file_type().is_symlink() {
            return Err(FsError::SymlinkNotAllowed { path: current });
        }
    }
    Ok(current)
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pros</th><th>Cons</th></tr>
</thead>
<tbody>
<tr><td>Would work</td><td>Complex implementation</td></tr>
<tr><td>Consistent with virtual backends</td><td>TOCTOU vulnerability (symlink created between check and use)</td></tr>
<tr><td></td><td>Performance overhead (lstat per component)</td></tr>
<tr><td></td><td>Platform differences (Windows junctions, etc.)</td></tr>
</tbody>
</table>
</div>
<h4 id="option-2-two-different-traits"><a class="header" href="#option-2-two-different-traits">Option 2: Two Different Traits</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Virtual backends where we control everything
pub trait VirtualFs: Fs {
    fn set_symlink_resolution(&amp;self, enabled: bool);
}

/// Real filesystem backends where OS controls symlink resolution
pub trait RealFs: Fs {
    // OS controls symlinks, we just ensure containment
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pros</th><th>Cons</th></tr>
</thead>
<tbody>
<tr><td>Honest about capabilities</td><td>Complicates API</td></tr>
<tr><td>Clear separation of concerns</td><td>Middleware must handle both</td></tr>
<tr><td>No false promises</td><td>Harder to swap backends</td></tr>
<tr><td></td><td>Users must understand the difference</td></tr>
</tbody>
</table>
</div>
<h4 id="option-3-capability-query"><a class="header" href="#option-3-capability-query">Option 3: Capability Query</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fs {
    fn capabilities(&amp;self) -&gt; Capabilities;
    // ...
}

pub struct Capabilities {
    pub can_control_symlink_following: bool,
    pub supports_hard_links: bool,
    // ...
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pros</th><th>Cons</th></tr>
</thead>
<tbody>
<tr><td>Single trait surface</td><td>Runtime capability discovery</td></tr>
<tr><td>Backends self-describe</td><td>Middleware becomes conditional</td></tr>
<tr><td>Extensible</td><td>Can’t enforce at compile time</td></tr>
</tbody>
</table>
</div>
<h4 id="option-4-accept-the-limitation"><a class="header" href="#option-4-accept-the-limitation">Option 4: Accept the Limitation</a></h4>
<ul>
<li>For virtual backends: We control symlink following</li>
<li>For VRootFsBackend: Rely on <code>strict-path</code> to prevent escapes</li>
<li>Document that <code>Restrictions</code> symlink control only applies to virtual backends</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pros</th><th>Cons</th></tr>
</thead>
<tbody>
<tr><td>Simple</td><td>Inconsistent behavior</td></tr>
<tr><td>Honest</td><td>Feature doesn’t work everywhere</td></tr>
<tr><td>No complexity</td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="option-5-drop-the-symlink-control-feature"><a class="header" href="#option-5-drop-the-symlink-control-feature">Option 5: Drop the Symlink Control Feature</a></h4>
<p>User’s suggestion: Low ROI, just drop it.</p>
<ul>
<li>Virtual backends: Symlinks are data, inherently safe</li>
<li>VRootFsBackend: <code>strict-path</code> prevents escapes anyway</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pros</th><th>Cons</th></tr>
</thead>
<tbody>
<tr><td>Simplest</td><td>Loses archive extraction use case</td></tr>
<tr><td>No false expectations</td><td></td></tr>
<tr><td>Focus on what we can actually control</td><td></td></tr>
</tbody>
</table>
</div>
<h3 id="the-archive-extraction-use-case"><a class="header" href="#the-archive-extraction-use-case">The Archive Extraction Use Case</a></h3>
<p>One valid use case for symlink control:</p>
<blockquote>
<p>“Someone using our files container to contain their own user-based-tenants or as an archive extraction, where they wish to prevent symlinks as an easy resolution to make sure there is no jail-escape.”</p>
</blockquote>
<p>For this use case:</p>
<ul>
<li><strong>Virtual backends</strong>: Works perfectly - we can refuse to follow symlinks</li>
<li><strong>VRootFsBackend</strong>: Would need custom path resolution or OS-specific flags</li>
</ul>
<h3 id="what-strict-path-actually-does"><a class="header" href="#what-strict-path-actually-does">What <code>strict-path</code> Actually Does</a></h3>
<p><code>strict-path::VirtualRoot</code>:</p>
<ol>
<li>Takes a user path</li>
<li>Canonicalizes it (follows symlinks, resolves <code>.</code> and <code>..</code>)</li>
<li>Checks the canonical path is within the root</li>
<li>Returns the safe path</li>
</ol>
<p><strong>Key insight:</strong> <code>strict-path</code> FOLLOWS symlinks but ensures the final path is contained. It does NOT prevent symlink following.</p>
<pre><code>/root/link -&gt; ../escape
User requests: /link
strict-path: canonicalize(/root/link) = /escape
strict-path: /escape is NOT within /root → DENIED
</code></pre>
<p>This is secure against escape, but it’s “follow and check” not “don’t follow”.</p>
<h3 id="v1-decision-accept-the-limitation"><a class="header" href="#v1-decision-accept-the-limitation">v1 Decision: Accept the Limitation</a></h3>
<p>The design is straightforward:</p>
<ol>
<li>
<p><strong>Virtual backends always support symlinks</strong> - creating symlinks is just storing data.</p>
</li>
<li>
<p><strong>Virtual backends provide <code>set_follow_symlinks(bool)</code></strong> - the actual security control:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = MemoryBackend::new();
backend.set_follow_symlinks(false);  // Symlinks not resolved during path operations
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>VRootFsBackend cannot control symlink following</strong> - the OS handles resolution. <code>strict-path</code> prevents escapes but cannot disable following entirely.</p>
</li>
<li>
<p><strong>Everything works by default</strong> - all operations (<code>symlink()</code>, <code>hard_link()</code>, <code>set_permissions()</code>) work out of the box. Use <code>Restrictions</code> middleware to opt-in to restrictions when needed.</p>
</li>
</ol>
<h3 id="summary-3"><a class="header" href="#summary-3">Summary</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Virtual Backends</th><th>VRootFsBackend</th></tr>
</thead>
<tbody>
<tr><td>Symlink creation</td><td>Always allowed (just data)</td><td>Always allowed (just data)</td></tr>
<tr><td>Symlink following</td><td><code>set_follow_symlinks(bool)</code></td><td>OS controls (strict-path prevents escapes)</td></tr>
<tr><td>Jail escape protection</td><td><code>set_follow_symlinks(false)</code></td><td>strict-path containment</td></tr>
</tbody>
</table>
</div>
<h3 id="why-vrootfsbackend-cannot-control-symlink-following"><a class="header" href="#why-vrootfsbackend-cannot-control-symlink-following">Why VRootFsBackend Cannot Control Symlink Following</a></h3>
<p>VRootFsBackend calls OS functions (<code>std::fs::read()</code>, etc.) which follow symlinks automatically. We don’t implement path resolution - the OS does.</p>
<p><strong>Theoretical alternatives (not recommended):</strong></p>
<ul>
<li>Walk path manually before each operation → TOCTOU race condition</li>
<li>Use <code>O_NOFOLLOW</code> flags → Only affects final component, platform-specific</li>
<li>FUSE mount → Way too complex for a library</li>
</ul>
<p><strong>The honest answer:</strong> VRootFsBackend cannot disable symlink following. <code>strict-path</code> prevents escapes, but symlinks within the jail are followed by the OS. This is a fundamental limitation of wrapping a real filesystem.</p>
<hr>
<h2 id="virtual-vs-real-backends-path-resolution"><a class="header" href="#virtual-vs-real-backends-path-resolution">Virtual vs Real Backends: Path Resolution</a></h2>
<p><strong>Status:</strong> Resolved</p>
<p><strong>Question:</strong> Should path resolution logic be different for virtual backends (memory, SQLite) vs filesystem-based backends (StdFsBackend, VRootFsBackend)?</p>
<p><strong>Resolution:</strong> <code>FileStorage</code> handles symlink-aware path resolution for ALL backends by default. Backends do NOT perform path resolution - they receive already-resolved paths.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Type</th><th>Path Resolution</th><th>Symlink Handling</th></tr>
</thead>
<tbody>
<tr><td>MemoryBackend</td><td><strong>FileStorage</strong> (symlink-aware)</td><td><code>set_follow_symlinks(bool)</code></td></tr>
<tr><td>SqliteBackend</td><td><strong>FileStorage</strong> (symlink-aware)</td><td><code>set_follow_symlinks(bool)</code></td></tr>
<tr><td>VRootFsBackend</td><td><strong>OS</strong> (implements <code>SelfResolving</code>)</td><td>OS follows symlinks (strict-path prevents escapes)</td></tr>
</tbody>
</table>
</div>
<p><strong>Key design decision:</strong> Backends that wrap a real filesystem implement the <code>SelfResolving</code> marker trait to tell <code>FileStorage</code> to skip resolution:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SelfResolving for VRootFsBackend {}
<span class="boring">}</span></code></pre>
<p>This ensures consistent behavior: all virtual backends get symlink-aware resolution from <code>FileStorage</code>, while real filesystem backends delegate to the OS.</p>
<hr>
<h2 id="compression-and-encryption"><a class="header" href="#compression-and-encryption">Compression and Encryption</a></h2>
<p><strong>Question:</strong> Does the current design allow backends to compress/decompress or encrypt/decrypt files transparently?</p>
<p><strong>Answer:</strong> Yes. The backend receives the data and stores it however it wants. A backend could:</p>
<ul>
<li>Compress data before writing to SQLite</li>
<li>Encrypt blobs with a user-provided key</li>
<li>Use a remote object store with encryption at rest</li>
</ul>
<p>This is an implementation detail of the backend, not visible to the <code>FileStorage</code> API.</p>
<hr>
<h2 id="hooks-and-callbacks"><a class="header" href="#hooks-and-callbacks">Hooks and Callbacks</a></h2>
<p><strong>Question:</strong> Should AnyFS support hooks or callbacks for file operations (e.g., audit logging, validation)?</p>
<p><strong>Considerations:</strong></p>
<ul>
<li>AgentFS (see comparison below) provides audit logging as a core feature</li>
<li>Hooks add complexity but enable powerful use cases</li>
<li>Could be implemented as a middleware pattern around FileStorage</li>
</ul>
<p><strong>Resolution:</strong> Implemented via <code>Tracing</code> middleware. Users can also wrap <code>FileStorage</code> or backends for custom hooks.</p>
<hr>
<h2 id="agentfs-comparison"><a class="header" href="#agentfs-comparison">AgentFS Comparison</a></h2>
<p><strong>Note:</strong> There are two projects named “AgentFS”:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="https://github.com/tursodatabase/agentfs">tursodatabase/agentfs</a></td><td>Full AI agent runtime (Turso/libSQL)</td></tr>
<tr><td><a href="https://github.com/cryptopatrick/agentfs">cryptopatrick/agentfs</a></td><td>Related to <a href="https://lib.rs/crates/agentdb">AgentDB</a> abstraction layer</td></tr>
</tbody>
</table>
</div>
<p>This section focuses on <strong>Turso’s AgentFS</strong>, which has a <a href="https://github.com/tursodatabase/agentfs/blob/main/SPEC.md">published spec</a>.</p>
<h3 id="what-agentfs-provides"><a class="header" href="#what-agentfs-provides">What AgentFS Provides</a></h3>
<p>AgentFS is an <strong>agent runtime</strong>, not just a filesystem. It provides three integrated subsystems:</p>
<ol>
<li><strong>Virtual Filesystem</strong> - POSIX-like, inode-based, chunked storage in SQLite</li>
<li><strong>Key-Value Store</strong> - Agent state and context storage</li>
<li><strong>Tool Call Audit Trail</strong> - Records all tool invocations for debugging/compliance</li>
</ol>
<h3 id="anyfs-vs-agentfs-different-abstractions"><a class="header" href="#anyfs-vs-agentfs-different-abstractions">AnyFS vs AgentFS: Different Abstractions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>AnyFS</th><th>AgentFS</th></tr>
</thead>
<tbody>
<tr><td><strong>Scope</strong></td><td>Filesystem abstraction</td><td>Agent runtime</td></tr>
<tr><td><strong>Filesystem</strong></td><td>Full</td><td>Full</td></tr>
<tr><td><strong>Key-Value store</strong></td><td>Not our domain</td><td>Included</td></tr>
<tr><td><strong>Tool auditing</strong></td><td><code>Tracing</code> middleware</td><td>Built-in</td></tr>
<tr><td><strong>Backends</strong></td><td>Memory, SQLite, VRootFs, custom</td><td>SQLite only (spec)</td></tr>
<tr><td><strong>Middleware</strong></td><td>Composable layers</td><td>Monolithic</td></tr>
</tbody>
</table>
</div>
<h3 id="relationship-options"><a class="header" href="#relationship-options">Relationship Options</a></h3>
<p><strong>AnyFS could be used BY AgentFS:</strong></p>
<ul>
<li>AgentFS could implement its filesystem portion using <code>Fs</code> trait</li>
<li>Our middleware (Quota, PathFilter, etc.) would work with their system</li>
</ul>
<p><strong>AgentFS-compatible backend for AnyFS:</strong></p>
<ul>
<li>Someone could implement <code>Fs</code> using AgentFS’s SQLite schema</li>
<li>Would enable interop with AgentFS tooling</li>
</ul>
<p><strong>What we should NOT do:</strong></p>
<ul>
<li>Add KV store to <code>Fs</code> (different abstraction, scope creep)</li>
<li>Add tool call auditing to core trait (that’s what <code>Tracing</code> middleware is for)</li>
</ul>
<h3 id="when-to-use-which"><a class="header" href="#when-to-use-which">When to Use Which</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Need just filesystem operations</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need composable middleware (quota, sandboxing)</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need full agent runtime (FS + KV + auditing)</td><td><strong>AgentFS</strong></td></tr>
<tr><td>Need multiple backend types (memory, real FS)</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need AgentFS-compatible SQLite format</td><td><strong>AgentFS</strong> or custom AnyFS backend</td></tr>
</tbody>
</table>
</div>
<h3 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h3>
<p>AnyFS and AgentFS solve different problems at different layers:</p>
<ul>
<li><strong>AnyFS</strong> = filesystem abstraction with composable middleware</li>
<li><strong>AgentFS</strong> = complete agent runtime with integrated storage</li>
</ul>
<p>They can complement each other rather than compete.</p>
<hr>
<h2 id="vfs-crate-comparison"><a class="header" href="#vfs-crate-comparison">VFS Crate Comparison</a></h2>
<p>The <a href="https://docs.rs/vfs/">vfs crate</a> provides virtual filesystem abstractions with:</p>
<ul>
<li><strong>PhysicalFS</strong>: Host filesystem access</li>
<li><strong>MemoryFS</strong>: In-memory storage</li>
<li><strong>AltrootFS</strong>: Rooted filesystem (similar to our VRootFsBackend)</li>
<li><strong>OverlayFS</strong>: Layered filesystem</li>
<li><strong>EmbeddedFS</strong>: Compile resources into binary</li>
</ul>
<p><strong>Similarities with AnyFS:</strong></p>
<ul>
<li>Trait-based abstraction over storage</li>
<li>Memory and physical filesystem backends</li>
</ul>
<p><strong>Differences:</strong></p>
<ul>
<li>VFS doesn’t have SQLite backend</li>
<li>VFS doesn’t have policy/quota layer</li>
<li>AnyFS focuses on isolation and limits</li>
</ul>
<p><strong>Why not use VFS?</strong> VFS is a good library, but AnyFS’s design goals differ:</p>
<ol>
<li>We want SQLite as a first-class backend</li>
<li>We need quota/limit enforcement</li>
<li>We want feature whitelisting (least privilege)</li>
</ol>
<hr>
<h2 id="fuse-mount-support"><a class="header" href="#fuse-mount-support">FUSE Mount Support</a></h2>
<p><strong>Status:</strong> Resolved - Implemented in <code>anyfs-mount</code></p>
<p><strong>What is FUSE?</strong>
<a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE (Filesystem in Userspace)</a> allows implementing filesystems in userspace rather than kernel code. It enables:</p>
<ul>
<li>Mounting any backend as a real filesystem</li>
<li>Using standard Unix tools (ls, cat, etc.) on AnyFS containers</li>
<li>Integration with existing workflows</li>
</ul>
<p><strong>Resolution:</strong> Implemented via <code>anyfs-mount</code> crate with cross-platform support:</p>
<ul>
<li>Linux: FUSE (native)</li>
<li>macOS: macFUSE</li>
<li>Windows: WinFsp</li>
</ul>
<p>See <a href="#cross-platform-virtual-drive-mounting">Cross-Platform Mounting</a> for full details.</p>
<hr>
<h2 id="type-system-protection-for-cross-container-operations"><a class="header" href="#type-system-protection-for-cross-container-operations">Type-System Protection for Cross-Container Operations</a></h2>
<p><strong>Status:</strong> Resolved - Implemented via marker types</p>
<p><strong>Question:</strong> Should we use the type system to prevent accidentally mixing data between containers?</p>
<p><strong>Resolution:</strong> Implemented via <code>FileStorage&lt;B, M&gt;</code> where <code>M</code> is a marker type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Sandbox;
struct UserData;

let sandbox: FileStorage&lt;_, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
let userdata: FileStorage&lt;_, UserData&gt; = FileStorage::new(SqliteBackend::open("data.db")?);

fn process_sandbox(fs: &amp;FileStorage&lt;impl Fs, Sandbox&gt;) { /* only accepts Sandbox */ }

process_sandbox(&amp;sandbox);   // OK
process_sandbox(&amp;userdata);  // Compile error!
<span class="boring">}</span></code></pre>
<p>See <a href="#filestorageb-m-anyfs">FileStorage&lt;B, M&gt;</a> for details.</p>
<hr>
<h2 id="naming-considerations"><a class="header" href="#naming-considerations">Naming Considerations</a></h2>
<p>Based on review feedback, the following naming concerns were raised:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Current Name</th><th>Concern</th><th>Alternatives Considered</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-traits</code></td><td>“traits” is vague</td><td><code>anyfs-backend</code> (adopted)</td></tr>
<tr><td><code>anyfs-container</code></td><td>Could imply Docker</td><td>Merged into <code>anyfs</code> (adopted)</td></tr>
<tr><td><code>anyfs</code></td><td>Sounds like Hebrew “ani efes” (I am zero)</td><td><code>anyfs</code> retained for simplicity</td></tr>
</tbody>
</table>
</div>
<p><strong>Decision:</strong> Renamed <code>anyfs-traits</code> to <code>anyfs-backend</code>. Merged <code>anyfs-container</code> into <code>anyfs</code>.</p>
<hr>
<h2 id="posix-behavior"><a class="header" href="#posix-behavior">POSIX Behavior</a></h2>
<p><strong>Question:</strong> How POSIX-compatible should AnyFS be?</p>
<p><strong>Answer:</strong> AnyFS is <strong>not</strong> a POSIX emulator. We use <code>std::fs</code>-like naming and semantics for familiarity, but we don’t aim for full POSIX compliance. Specific differences:</p>
<ul>
<li>Symlink-aware path resolution (FileStorage walks the virtual structure using <code>metadata()</code> and <code>read_link()</code>)</li>
<li>No file descriptors or open file handles in the basic API</li>
<li>Simplified permissions model</li>
<li>No device files, FIFOs, or sockets</li>
</ul>
<hr>
<h2 id="async-support"><a class="header" href="#async-support">Async Support</a></h2>
<p><strong>Question:</strong> Should <code>Fs</code> traits be async?</p>
<p><strong>Decision:</strong> Sync-first, async-ready (see ADR-010).</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>All built-in backends are naturally synchronous (rusqlite, std::fs, memory)</li>
<li>No runtime dependency (tokio/async-std) required</li>
<li>Rust 1.75+ has native async traits, so adding later is low-cost</li>
</ul>
<p><strong>Async-ready design:</strong></p>
<ul>
<li>Traits require <code>Send</code> - compatible with async executors</li>
<li>Return types are <code>Result&lt;T, FsError&gt;</code> - works with async</li>
<li>No hidden blocking state</li>
<li>Methods are stateless per-call</li>
</ul>
<p><strong>Future path:</strong> When needed (e.g., S3/network backends), add parallel <code>AsyncFs</code> trait:</p>
<ul>
<li>Separate trait, not replacing <code>Fs</code></li>
<li>Blanket impl possible via <code>spawn_blocking</code></li>
<li>No breaking changes to existing sync API</li>
</ul>
<hr>
<h2 id="summary-1-1"><a class="header" href="#summary-1-1">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Topic</th><th>v1 Decision</th></tr>
</thead>
<tbody>
<tr><td>Symlink security</td><td>Virtual backends: <code>set_follow_symlinks()</code>. VRootFsBackend: <code>strict-path</code> escapes only.</td></tr>
<tr><td>Path resolution</td><td>FileStorage (symlink-aware); VRootFs = OS via <code>SelfResolving</code></td></tr>
<tr><td>Compression/encryption</td><td>Backend responsibility</td></tr>
<tr><td>Hooks/callbacks</td><td><code>Tracing</code> middleware</td></tr>
<tr><td>FUSE mount</td><td><code>anyfs-mount</code> crate (cross-platform)</td></tr>
<tr><td>Type-system protection</td><td><code>FileStorage&lt;B, M&gt;</code> marker types</td></tr>
<tr><td>POSIX compatibility</td><td>Not a goal</td></tr>
<tr><td><code>truncate</code></td><td>Added to <code>FsWrite</code></td></tr>
<tr><td><code>sync</code> / <code>fsync</code></td><td>Added to <code>FsSync</code></td></tr>
<tr><td>Async support</td><td>Sync-first, async-ready (ADR-010)</td></tr>
<tr><td>Layer trait</td><td>Tower-style composition (ADR-011)</td></tr>
<tr><td>Logging</td><td>Tracing with tracing ecosystem (ADR-012)</td></tr>
<tr><td>Extension methods</td><td><code>FsExt</code> (ADR-013)</td></tr>
<tr><td>Zero-copy bytes</td><td>Optional <code>bytes</code> feature (ADR-014)</td></tr>
<tr><td>Error context</td><td>Contextual <code>FsError</code> (ADR-015)</td></tr>
<tr><td>BackendStack builder</td><td>Fluent API via <code>.layer()</code></td></tr>
<tr><td>Path-based access control</td><td><code>PathFilter</code> middleware (ADR-016)</td></tr>
<tr><td>Read-only mode</td><td><code>ReadOnly</code> middleware (ADR-017)</td></tr>
<tr><td>Rate limiting</td><td><code>RateLimit</code> middleware (ADR-018)</td></tr>
<tr><td>Dry-run testing</td><td><code>DryRun</code> middleware (ADR-019)</td></tr>
<tr><td>Read caching</td><td><code>Cache</code> middleware (ADR-020)</td></tr>
<tr><td>Union filesystem</td><td><code>Overlay</code> middleware (ADR-021)</td></tr>
</tbody>
</table>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
